diff -duprN mm/arch/Kconfig n/arch/Kconfig
--- mm/arch/Kconfig	2016-09-20 17:29:26.000000000 +0530
+++ n/arch/Kconfig	2017-03-31 10:41:26.000000000 +0530
@@ -390,6 +390,74 @@ config HAVE_UNDERSCORE_SYMBOL_PREFIX
 	  Some architectures generate an _ in front of C symbols; things like
 	  module loading and assembly files need to know about this.
 
+config HAVE_ARCH_MMAP_RND_BITS
+	bool
+	help
+	  An arch should select this symbol if it supports setting a variable
+	  number of bits for use in establishing the base address for mmap
+	  allocations, has MMU enabled and provides values for both:
+	  - ARCH_MMAP_RND_BITS_MIN
+	  - ARCH_MMAP_RND_BITS_MAX
+
+config ARCH_MMAP_RND_BITS_MIN
+	int
+
+config ARCH_MMAP_RND_BITS_MAX
+	int
+
+config ARCH_MMAP_RND_BITS_DEFAULT
+	int
+
+config ARCH_MMAP_RND_BITS
+	int "Number of bits to use for ASLR of mmap base address" if EXPERT
+	range ARCH_MMAP_RND_BITS_MIN ARCH_MMAP_RND_BITS_MAX
+	default ARCH_MMAP_RND_BITS_DEFAULT if ARCH_MMAP_RND_BITS_DEFAULT
+	default ARCH_MMAP_RND_BITS_MIN
+	depends on HAVE_ARCH_MMAP_RND_BITS
+	help
+	  This value can be used to select the number of bits to use to
+	  determine the random offset to the base address of vma regions
+	  resulting from mmap allocations. This value will be bounded
+	  by the architecture's minimum and maximum supported values.
+
+	  This value can be changed after boot using the
+	  /proc/sys/vm/mmap_rnd_bits tunable
+
+config HAVE_ARCH_MMAP_RND_COMPAT_BITS
+	bool
+	help
+	  An arch should select this symbol if it supports running applications
+	  in compatibility mode, supports setting a variable number of bits for
+	  use in establishing the base address for mmap allocations, has MMU
+	  enabled and provides values for both:
+	  - ARCH_MMAP_RND_COMPAT_BITS_MIN
+	  - ARCH_MMAP_RND_COMPAT_BITS_MAX
+
+config ARCH_MMAP_RND_COMPAT_BITS_MIN
+	int
+
+config ARCH_MMAP_RND_COMPAT_BITS_MAX
+	int
+
+config ARCH_MMAP_RND_COMPAT_BITS_DEFAULT
+	int
+
+config ARCH_MMAP_RND_COMPAT_BITS
+	int "Number of bits to use for ASLR of mmap base address for compatible applications" if EXPERT
+	range ARCH_MMAP_RND_COMPAT_BITS_MIN ARCH_MMAP_RND_COMPAT_BITS_MAX
+	default ARCH_MMAP_RND_COMPAT_BITS_DEFAULT if ARCH_MMAP_RND_COMPAT_BITS_DEFAULT
+	default ARCH_MMAP_RND_COMPAT_BITS_MIN
+	depends on HAVE_ARCH_MMAP_RND_COMPAT_BITS
+	help
+	  This value can be used to select the number of bits to use to
+	  determine the random offset to the base address of vma regions
+	  resulting from mmap allocations for compatible applications This
+	  value will be bounded by the architecture's minimum and maximum
+	  supported values.
+
+	  This value can be changed after boot using the
+	  /proc/sys/vm/mmap_rnd_compat_bits tunable
+
 #
 # ABI hall of shame
 #
diff -duprN mm/arch/arm/Kconfig n/arch/arm/Kconfig
--- mm/arch/arm/Kconfig	2016-09-20 17:29:24.000000000 +0530
+++ n/arch/arm/Kconfig	2017-03-31 10:41:26.000000000 +0530
@@ -21,6 +21,7 @@ config ARM
 	select HARDIRQS_SW_RESEND
 	select HAVE_ARCH_JUMP_LABEL if !XIP_KERNEL
 	select HAVE_ARCH_KGDB
+	select HAVE_ARCH_MMAP_RND_BITS if MMU
 	select HAVE_ARCH_SECCOMP_FILTER
 	select HAVE_ARCH_TRACEHOOK
 	select HAVE_BPF_JIT
@@ -292,6 +293,14 @@ config MMU
 	  Select if you want MMU-based virtualised addressing space
 	  support by paged memory management. If unsure, say 'Y'.
 
+config ARCH_MMAP_RND_BITS_MIN
+	default 8
+
+config ARCH_MMAP_RND_BITS_MAX
+	default 14 if PAGE_OFFSET=0x40000000
+	default 15 if PAGE_OFFSET=0x80000000
+	default 16
+
 #
 # The "ARM system type" choice list is ordered alphabetically by option
 # text.  Please add new entries in the option alphabetic order.
diff -duprN mm/arch/arm/boot/dts/exynos5422-chagallve_common.dtsi n/arch/arm/boot/dts/exynos5422-chagallve_common.dtsi
--- mm/arch/arm/boot/dts/exynos5422-chagallve_common.dtsi	2016-09-20 17:29:25.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5422-chagallve_common.dtsi	2017-03-31 10:41:26.000000000 +0530
@@ -1968,6 +1968,7 @@
 		compatible = "samsung,exynos5430-ion";
 
 		contig-names = "common",
+			       "video_ext",
 			       "mfc_sh",
 			       "g2d_wfd",
 			       "video",
@@ -1977,17 +1978,20 @@
 			       "secdma";
 
 		contig = <0 0x400000 0x0>,
+		         <1 0x600000 0x0>,
 		         <2 0x100000 0x0>,
 		         <10 0x800000 0x0>,
 		         <11 0xA800000 0x0>,
 		         <9 0x100000 0x0>,
-		         <8 0x100000 0x0>,
-		         <12 0x100000 0x0>,
+		         <8 0x200000 0x0>,
+		         <12 0x200000 0x0>,
 		         <13 0x20000 0x0>;
 
-		contig-isolate_on_boot = <0>, <2>, <8>,
+		contig-isolate_on_boot = <0>, <1>, <2>, <8>,
 					  <9>, <10>, <11>, <12>, <13>;
 
+		secure = <11>, <9>, <8>, <1>;
+
 		ion_noncontig_heap {
 			id-type = <0 0>;
 		};
diff -duprN mm/arch/arm/boot/dts/exynos5422-klimtve_common.dtsi n/arch/arm/boot/dts/exynos5422-klimtve_common.dtsi
--- mm/arch/arm/boot/dts/exynos5422-klimtve_common.dtsi	2016-09-20 17:29:27.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5422-klimtve_common.dtsi	2017-03-31 10:41:26.000000000 +0530
@@ -1947,6 +1947,7 @@
 		compatible = "samsung,exynos5430-ion";
 
 		contig-names = "common",
+			       "video_ext",
 			       "mfc_sh",
 			       "g2d_wfd",
 			       "video",
@@ -1956,17 +1957,20 @@
 			       "secdma";
 
 		contig = <0 0x400000 0x0>,
+		         <1 0x600000 0x0>,
 		         <2 0x100000 0x0>,
 		         <10 0x800000 0x0>,
 		         <11 0xA800000 0x0>,
 		         <9 0x100000 0x0>,
-		         <8 0x100000 0x0>,
-		         <12 0x100000 0x0>,
+		         <8 0x200000 0x0>,
+		         <12 0x200000 0x0>,
 		         <13 0x20000 0x0>;
 
-		contig-isolate_on_boot = <0>, <2>, <8>,
+		contig-isolate_on_boot = <0>, <1>, <2>, <8>,
 					  <9>, <10>, <11>, <12>, <13>;
 
+		secure = <11>, <9>, <8>, <1>;
+
 		ion_noncontig_heap {
 			id-type = <0 0>;
 		};
diff -duprN mm/arch/arm/boot/dts/exynos5422_evt0-k3g_common.dtsi n/arch/arm/boot/dts/exynos5422_evt0-k3g_common.dtsi
--- mm/arch/arm/boot/dts/exynos5422_evt0-k3g_common.dtsi	2016-09-20 17:29:28.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5422_evt0-k3g_common.dtsi	2017-03-31 10:41:26.000000000 +0530
@@ -1585,6 +1585,7 @@
 		compatible = "samsung,exynos5430-ion";
 
 		contig-names = "common",
+			       "video_ext",
 			       "mfc_sh",
 			       "g2d_wfd",
 			       "video",
@@ -1594,17 +1595,20 @@
 			       "secdma";
 
 		contig = <0 0x400000 0x0>,
+		         <1 0x600000 0x0>,
 		         <2 0x100000 0x0>,
 		         <10 0x800000 0x0>,
 		         <11 0xA800000 0x0>,
 		         <9 0x100000 0x0>,
-		         <8 0x100000 0x0>,
-		         <12 0x100000 0x0>,
+		         <8 0x200000 0x0>,
+		         <12 0x200000 0x0>,
 		         <13 0x20000 0x0>;
 
-		contig-isolate_on_boot = <0>, <2>, <8>,
+		contig-isolate_on_boot = <0>, <1>, <2>, <8>,
 					  <9>, <10>, <11>, <12>, <13>;
 
+		secure = <11>, <9>, <8>, <1>;
+
 		ion_noncontig_heap {
 			id-type = <0 0>;
 		};
diff -duprN mm/arch/arm/boot/dts/exynos5422_evt0-universal5422.dts n/arch/arm/boot/dts/exynos5422_evt0-universal5422.dts
--- mm/arch/arm/boot/dts/exynos5422_evt0-universal5422.dts	2016-09-20 17:29:28.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5422_evt0-universal5422.dts	2017-03-31 10:41:26.000000000 +0530
@@ -909,6 +909,7 @@
 		compatible = "samsung,exynos5430-ion";
 
 		contig-names = "common",
+			       "video_ext",
 			       "mfc_sh",
 			       "g2d_wfd",
 			       "video",
@@ -918,17 +919,20 @@
 			       "secdma";
 
 		contig = <0 0x400000 0x0>,
+		         <1 0x600000 0x0>,
 		         <2 0x100000 0x0>,
 		         <10 0x800000 0x0>,
 		         <11 0x6C00000 0x0>,
 		         <9 0x100000 0x0>,
-		         <8 0x100000 0x0>,
-		         <12 0x100000 0x0>,
+		         <8 0x200000 0x0>,
+		         <12 0x200000 0x0>,
 		         <13 0x20000 0x0>;
 
-		contig-isolate_on_boot = <0>, <2>, <8>,
+		contig-isolate_on_boot = <0>, <1>, <2>, <8>,
 					  <9>, <10>, <11>, <12>, <13>;
 
+		secure = <11>, <9>, <8>, <1>;
+
 		ion_noncontig_heap {
 			id-type = <0 0>;
 		};
diff -duprN mm/arch/arm/boot/dts/exynos5422_evt0-xyref5422.dts n/arch/arm/boot/dts/exynos5422_evt0-xyref5422.dts
--- mm/arch/arm/boot/dts/exynos5422_evt0-xyref5422.dts	2016-09-20 17:29:28.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5422_evt0-xyref5422.dts	2017-03-31 10:41:26.000000000 +0530
@@ -1130,6 +1130,7 @@
 		compatible = "samsung,exynos5430-ion";
 
 		contig-names = "common",
+			       "video_ext",
 			       "mfc_sh",
 			       "g2d_wfd",
 			       "video",
@@ -1139,17 +1140,20 @@
 			       "secdma";
 
 		contig = <0 0x400000 0x0>,
+		         <1 0x600000 0x0>,
 		         <2 0x100000 0x0>,
 		         <10 0x800000 0x0>,
 		         <11 0x6C00000 0x0>,
 		         <9 0x100000 0x0>,
-		         <8 0x100000 0x0>,
-		         <12 0x100000 0x0>,
+		         <8 0x200000 0x0>,
+		         <12 0x200000 0x0>,
 		         <13 0x20000 0x0>;
 
-		contig-isolate_on_boot = <0>, <2>, <8>,
+		contig-isolate_on_boot = <0>, <1>, <2>, <8>,
 					  <9>, <10>, <11>, <12>, <13>;
 
+		secure = <11>, <9>, <8>, <1>;
+
 		ion_noncontig_heap {
 			id-type = <0 0>;
 		};
diff -duprN mm/arch/arm/boot/dts/exynos5430-a7_battery.dtsi n/arch/arm/boot/dts/exynos5430-a7_battery.dtsi
--- mm/arch/arm/boot/dts/exynos5430-a7_battery.dtsi	2016-09-20 17:29:28.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5430-a7_battery.dtsi	2017-03-31 10:41:26.000000000 +0530
@@ -116,20 +116,20 @@
 		
 		battery,temp_check_type = <2>; /* SEC_BATTERY_TEMP_CHECK_TEMP */
 		battery,temp_check_count = <1>;
-		battery,temp_high_threshold_event = <600>;
-		battery,temp_high_recovery_event = <480>;
+		battery,temp_high_threshold_event = <580>;
+		battery,temp_high_recovery_event = <530>;
 		battery,temp_low_threshold_event = <(-50)>;
 		battery,temp_low_recovery_event = <(-10)>;
-		battery,temp_high_threshold_normal = <600>;
-		battery,temp_high_recovery_normal = <480>;
+		battery,temp_high_threshold_normal = <580>;
+		battery,temp_high_recovery_normal = <530>;
 		battery,temp_low_threshold_normal = <(-50)>;
 		battery,temp_low_recovery_normal = <(-10)>;
-		battery,temp_high_threshold_lpm = <600>;
-		battery,temp_high_recovery_lpm = <480>;
+		battery,temp_high_threshold_lpm = <580>;
+		battery,temp_high_recovery_lpm = <530>;
 		battery,temp_low_threshold_lpm = <(-50)>;
 		battery,temp_low_recovery_lpm = <(-10)>;
 		battery,full_check_type = <7>; /* SEC_BATTERY_FULLCHARGED_CHGPSY */
-		battery,full_check_type_2nd = <3>; /* SEC_BATTERY_FULLCHARGED_TIME */
+		battery,full_check_type_2nd = <7>; /* SEC_BATTERY_FULLCHARGED_CHGPSY */
 		battery,full_check_count = <1>;
 		battery,chg_gpio_full_check = <0>;
 		battery,chg_polarity_full_check = <1>;
@@ -171,7 +171,7 @@
 			battery,input_current_limit = <1500 500 500 1500 500 1000 1000 500 500 1000 1000 1500 1500 500 1000 500 700 1000 500 1000 1500 500 500>;
 			battery,fast_charging_current = <1500 0 500 1500 500 1000 1000 500 0 1200 1500 1500 1500 (-1) 1300 500 800 1300 500 1000 1500 0 0>;
 			battery,full_check_current_1st = <200 0 200 200 200 200 200 200 0 200 200 200 200 0 200 200 200 200 200 200 200 0 0>;
-			battery,full_check_current_2nd = <2400 0 2400 2400 2400 2400 2400 2400 0 2400 2400 2400 2400 0 2400 2400 2400 2400 2400 2400 2400 0 0>;
+			battery,full_check_current_2nd = <150 0 150 150 150 150 150 150 0 150 150 150 150 0 150 150 150 150 150 150 150 0 0>;
 
 			
 		};
diff -duprN mm/arch/arm/boot/dts/exynos5430-a7_common.dtsi n/arch/arm/boot/dts/exynos5430-a7_common.dtsi
--- mm/arch/arm/boot/dts/exynos5430-a7_common.dtsi	2016-09-20 17:29:25.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5430-a7_common.dtsi	2017-03-31 10:41:26.000000000 +0530
@@ -1383,6 +1383,7 @@
 		compatible = "samsung,exynos5430-ion";
 
 		contig-names = "common",
+			       "video_ext",
 			       "mfc_sh",
 			       "g2d_wfd",
 			       "video",
@@ -1392,17 +1393,20 @@
 			       "secdma";
 
 		contig = <0 0x400000 0x0>,
+		         <1 0x600000 0x0>,
 		         <2 0x100000 0x0>,
 		         <10 0x800000 0x0>,
 		         <11 0x7300000 0x0>,
 		         <9 0x100000 0x0>,
-		         <8 0x200000 0x0>,
-		         <12 0x200000 0x0>,
+		         <8 0x300000 0x0>,
+		         <12 0x300000 0x0>,
 		         <13 0x20000 0x0>;
 
-		contig-isolate_on_boot = <0>, <2>, <8>,
+		contig-isolate_on_boot = <0>, <1>, <2>, <8>,
 					  <9>, <10>, <11>, <12>, <13>;
 
+		secure = <11>, <9>, <8>, <1>;
+
 		ion_noncontig_heap {
 			id-type = <0 0>;
 		};
diff -duprN mm/arch/arm/boot/dts/exynos5430-a8_battery.dtsi n/arch/arm/boot/dts/exynos5430-a8_battery.dtsi
--- mm/arch/arm/boot/dts/exynos5430-a8_battery.dtsi	2016-09-20 17:29:25.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5430-a8_battery.dtsi	2017-03-31 10:41:26.000000000 +0530
@@ -35,6 +35,7 @@
 
 	i2c_4: i2c@14E80000 {
 		status = "okay";
+		samsung,i2c-max-bus-freq = <400000>;
 		sm5703-fuelgauge@71 {
 			compatible = "samsung,sm5703-fuelgauge";
 			reg = <0x71>;
@@ -105,7 +106,7 @@
 		battery,input_current_limit = <1750 0 0 1750 500 900 1000 500 1000 0 760 1900 1800 0 1400 400 700 1300 300 1000 1600>;
 		battery,fast_charging_current = <2100 0 0 2100 750 1200 1000 750 1200 0 900 1600 2100 0 1400 400 700 1300 300 1000 1900>;
 		battery,full_check_current_1st = <200 0 0 200 200 200 200 200 200 0 200 200 200 0 200 200 200 200 200 200 200>;
-		battery,full_check_current_2nd = <2400 0 0 2400 2400 2400 2400 2400 2400 0 2400 2400 2400 0 2400 2400 2400 2400 2400 2400 2400>;
+		battery,full_check_current_2nd = <150 0 0 150 150 150 150 150 150 0 150 150 150 0 150 150 150 150 150 150 150>;
 
 		battery,inbat_voltage = <1>;
 		battery,inbat_voltage_table_adc = <2661 2620 2600 2586 2566 2536 2513 2486 2461 2431
@@ -151,7 +152,7 @@
 		battery,temp_low_threshold_lpm = <(-50)>;
 		battery,temp_low_recovery_lpm = <0>;
 		battery,full_check_type = <7>; /* SEC_BATTERY_FULLCHARGED_CHGPSY */
-		battery,full_check_type_2nd = <3>; /* SEC_BATTERY_FULLCHARGED_TIME */
+		battery,full_check_type_2nd = <7>; /* SEC_BATTERY_FULLCHARGED_CHGPSY */
 		battery,full_check_count = <1>;
 		battery,chg_gpio_full_check = <0>;
 		battery,chg_polarity_full_check = <1>;
diff -duprN mm/arch/arm/boot/dts/exynos5430-a8_battery_03.dtsi n/arch/arm/boot/dts/exynos5430-a8_battery_03.dtsi
--- mm/arch/arm/boot/dts/exynos5430-a8_battery_03.dtsi	2016-09-20 17:29:25.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5430-a8_battery_03.dtsi	2017-03-31 10:41:26.000000000 +0530
@@ -35,6 +35,7 @@
 
 	i2c_4: i2c@14E80000 {
 		status = "okay";
+		samsung,i2c-max-bus-freq = <400000>;
 		sm5703-fuelgauge@71 {
 			compatible = "samsung,sm5703-fuelgauge";
 			reg = <0x71>;
@@ -106,7 +107,7 @@
 		battery,input_current_limit = <1750 0 0 1750 500 900 1000 500 1000 0 760 1900 1800 0 1400 400 700 1300 300 1000 1600>;
 		battery,fast_charging_current = <2100 0 0 2100 750 1200 1000 750 1200 0 900 1600 2100 0 1400 400 700 1300 300 1000 1900>;
 		battery,full_check_current_1st = <200 0 0 200 200 200 200 200 200 0 200 200 200 0 200 200 200 200 200 200 200>;
-		battery,full_check_current_2nd = <2400 0 0 2400 2400 2400 2400 2400 2400 0 2400 2400 2400 0 2400 2400 2400 2400 2400 2400 2400>;
+		battery,full_check_current_2nd = <150 0 0 150 150 150 150 150 150 0 150 150 150 0 150 150 150 150 150 150 150>;
 
 		battery,inbat_voltage = <1>;
 		battery,inbat_voltage_table_adc = <2661 2620 2600 2586 2566 2536 2513 2486 2461 2431
@@ -152,7 +153,7 @@
 		battery,temp_low_threshold_lpm = <(-50)>;
 		battery,temp_low_recovery_lpm = <0>;
 		battery,full_check_type = <7>; /* SEC_BATTERY_FULLCHARGED_CHGPSY */
-		battery,full_check_type_2nd = <3>; /* SEC_BATTERY_FULLCHARGED_TIME */
+		battery,full_check_type_2nd = <7>; /* SEC_BATTERY_FULLCHARGED_CHGPSY */
 		battery,full_check_count = <1>;
 		battery,chg_gpio_full_check = <0>;
 		battery,chg_polarity_full_check = <1>;
diff -duprN mm/arch/arm/boot/dts/exynos5430-a8_battery_05.dtsi n/arch/arm/boot/dts/exynos5430-a8_battery_05.dtsi
--- mm/arch/arm/boot/dts/exynos5430-a8_battery_05.dtsi	2016-09-20 17:29:25.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5430-a8_battery_05.dtsi	2017-03-31 10:41:26.000000000 +0530
@@ -35,6 +35,7 @@
 
 	i2c_4: i2c@14E80000 {
 		status = "okay";
+		samsung,i2c-max-bus-freq = <400000>;
 		sm5703-fuelgauge@71 {
 			compatible = "samsung,sm5703-fuelgauge";
 			reg = <0x71>;
@@ -106,7 +107,7 @@
 		battery,input_current_limit = <1750 0 0 1750 500 900 1000 500 1000 0 760 1900 1800 0 1400 400 700 1300 300 1000 1600>;
 		battery,fast_charging_current = <2100 0 0 2100 750 1200 1000 750 1200 0 900 1600 2100 0 1400 400 700 1300 300 1000 1900>;
 		battery,full_check_current_1st = <200 0 0 200 200 200 200 200 200 0 200 200 200 0 200 200 200 200 200 200 200>;
-		battery,full_check_current_2nd = <2400 0 0 2400 2400 2400 2400 2400 2400 0 2400 2400 2400 0 2400 2400 2400 2400 2400 2400 2400>;
+		battery,full_check_current_2nd = <100 0 0 100 100 100 100 100 100 0 100 100 100 0 100 100 100 100 100 100 100>;
 
 		battery,inbat_voltage = <1>;
 		battery,inbat_voltage_table_adc = <2661 2620 2600 2586 2566 2536 2513 2486 2461 2431
@@ -152,7 +153,7 @@
 		battery,temp_low_threshold_lpm = <(-50)>;
 		battery,temp_low_recovery_lpm = <0>;
 		battery,full_check_type = <7>; /* SEC_BATTERY_FULLCHARGED_CHGPSY */
-		battery,full_check_type_2nd = <3>; /* SEC_BATTERY_FULLCHARGED_TIME */
+		battery,full_check_type_2nd = <7>; /* SEC_BATTERY_FULLCHARGED_CHGPSY */
 		battery,full_check_count = <1>;
 		battery,chg_gpio_full_check = <0>;
 		battery,chg_polarity_full_check = <1>;
@@ -194,6 +195,7 @@
 		battery,swelling_low_temp_block = <50>;
 		battery,swelling_low_temp_recov = <100>;
 		battery,swelling_chg_current = <1300>;
+		battery,swelling_topoff_current = <175>;
 		battery,swelling_drop_float_voltage = <4200>;
 		battery,swelling_high_rechg_voltage = <4150>;
 		battery,swelling_low_rechg_voltage = <4050>;
@@ -238,7 +240,7 @@
 		battery,chg_gpio_status = <0>;
 		battery,chg_polarity_status = <0>;
 		battery,chg_float_voltage = <4390>;
-		chg_autostop = <0>;
+		chg_autostop = <1>;
 		chg_autoset = <1>;
 		chg_aiclen = <1>;
 		chg_aiclth = <4300>;
diff -duprN mm/arch/arm/boot/dts/exynos5430-a8_common.dtsi n/arch/arm/boot/dts/exynos5430-a8_common.dtsi
--- mm/arch/arm/boot/dts/exynos5430-a8_common.dtsi	2016-09-20 17:29:28.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5430-a8_common.dtsi	2017-03-31 10:41:26.000000000 +0530
@@ -49,6 +49,7 @@
 		bypass-for-allpass;
 		use-fine-tuning;
 		use-enable-shift;
+		ignore-lv1;                 /*Feature only applicable for A800F model */
 		ignore-phase = <(1 << 7 | 1 << 6)>;
 		fifo-depth = <0x80>;
 		card-detect-delay = <200>;
@@ -717,7 +718,7 @@
 
 			front_preview_int = <400000>; /* L0 */
 			front_preview_cam = <466000>; /* L3 */
-			front_preview_mif = <543000>; /* L2 */
+			front_preview_mif = <825000>; /* L0 */
 			front_preview_i2c = <0>;
 
 			front_capture_int = <400000>; /* L0 */
@@ -1044,6 +1045,7 @@
 		compatible = "samsung,exynos5430-ion";
 
 		contig-names = "common",
+				"video_ext",
 				"mfc_sh",
 				"g2d_wfd",
 				"video",
@@ -1053,17 +1055,20 @@
 				"secdma";
 
 		contig = <0 0x600000 0x0>,
+			<1 0x600000 0x0>,
 			<2 0x100000 0x0>,
 			<10 0x800000 0x0>,
 			<11 0x8100000 0x0>,
 			<9 0x100000 0x0>,
-			<8 0x200000 0x0>,
-			<12 0x200000 0x0>,
+		 	<8 0x300000 0x0>,
+		 	<12 0x300000 0x0>,
 			<13 0x20000 0x0>;
 
-		contig-isolate_on_boot = <0>, <2>, <8>,
+		contig-isolate_on_boot = <0>, <1>, <2>, <8>,
 					  <9>, <10>, <11>, <12>, <13>;
 
+		secure = <11>, <9>, <8>, <1>;
+
 		ion_noncontig_heap {
 			id-type = <0 0>;
 		};
@@ -1170,16 +1175,51 @@
 				90 1700000 0 1300000 0 543000 267000 0 0 1
 				>;
 		};
+
 		boot_device@4 {
-			 net_boost,label="WIFI";
-			 net_boost,node="wlan0";
+			net_boost,label="CLAT";
+			net_boost,node="clat clat4 v4-rmnet0 v4-rmnet1 v4-rmnet2 v4-rmnet3 v4-rmnet4 v4-rmnet5 v4-rmnet6 v4-rmnet7";
+			net_boost,table_size = <3>;
+			/*		 <Throughput ARM_min ARM_max KFC_min KFC_max MIF INT Task Irq HMPBoost> */
+			net_boost,table= <120 1400000 0 0 0 825000 0 1 0 0
+					  130 1500000 0 0 0 825000 0 1 0 0
+					  150 1600000 0 0 0 825000 0 1 0 0>;
+		};
+		boot_device@5 {
+			net_boost,label="USB";
+			net_boost,node="rndis0";
+			net_boost,table_size = <1>;
+			net_boost,table= <0 0 0 0 0 0 0 0 1 0>;
+		};
+
+		boot_device@6 {
+			net_boost,label="WIFI";
+			net_boost,node="wlan0";
+			net_boost,table_size = <1>;
+			net_boost,table= <
+				180 0 0 0 0 0 0 1 1 1
+				>;
+		 };
+		boot_device@7 {
+			net_boost,label="WIFI TX";
+			net_boost,node="wlan0";
 			net_boost,table_size = <3>;
 			net_boost,table= <
 				20 1000000 0 800000 0 0 200000 0 0 0
+				35 1200000 0 1000000 0 0 200000 0 0 0
 				60 1500000 0 1200000 0 0 200000 0 0 0
 				180 1800000 0 1300000 0 543000 267000 1 1 1
 				>;
-		 };
+		};
+		boot_device@8 {
+			net_boost,label="WIFI RX";
+			net_boost,node="wlan0";
+			net_boost,table_size = <2>;
+			net_boost,table= <
+				80 1500000 0 1200000 0 0 200000 0 0 0
+				180 1800000 0 1300000 0 543000 267000 1 1 1
+				>;
+		};
 	};
 
 	fimg2d_pdata {
diff -duprN mm/arch/arm/boot/dts/exynos5430-a8_kor_open_00.dts n/arch/arm/boot/dts/exynos5430-a8_kor_open_00.dts
--- mm/arch/arm/boot/dts/exynos5430-a8_kor_open_00.dts	2016-09-20 17:29:26.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5430-a8_kor_open_00.dts	2017-03-31 10:41:26.000000000 +0530
@@ -70,9 +70,9 @@
 		cfg_en: cfg-en {
 			samsung,pins ="gpg1-4";
 			samsung,pin-function = <1>;
-			samsung,pin-pud = <1>;
+			samsung,pin-pud = <0>;
 			samsung,pin-con-pdn = <3>;
-			samsung,pin-pud-pdn = <1>;
+			samsung,pin-pud-pdn = <0>;
 		};
 	};
 
diff -duprN mm/arch/arm/boot/dts/exynos5430-a8_kor_open_02.dts n/arch/arm/boot/dts/exynos5430-a8_kor_open_02.dts
--- mm/arch/arm/boot/dts/exynos5430-a8_kor_open_02.dts	2016-09-20 17:29:26.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5430-a8_kor_open_02.dts	2017-03-31 10:41:26.000000000 +0530
@@ -70,9 +70,9 @@
 		cfg_en: cfg-en {
 			samsung,pins ="gpg1-4";
 			samsung,pin-function = <1>;
-			samsung,pin-pud = <1>;
+			samsung,pin-pud = <0>;
 			samsung,pin-con-pdn = <3>;
-			samsung,pin-pud-pdn = <1>;
+			samsung,pin-pud-pdn = <0>;
 		};
 	};
 
diff -duprN mm/arch/arm/boot/dts/exynos5430-a8_kor_open_03.dts n/arch/arm/boot/dts/exynos5430-a8_kor_open_03.dts
--- mm/arch/arm/boot/dts/exynos5430-a8_kor_open_03.dts	2016-09-20 17:29:26.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5430-a8_kor_open_03.dts	2017-03-31 10:41:26.000000000 +0530
@@ -70,9 +70,9 @@
 		cfg_en: cfg-en {
 			samsung,pins ="gpg1-4";
 			samsung,pin-function = <1>;
-			samsung,pin-pud = <1>;
+			samsung,pin-pud = <0>;
 			samsung,pin-con-pdn = <3>;
-			samsung,pin-pud-pdn = <1>;
+			samsung,pin-pud-pdn = <0>;
 		};
 	};
 
diff -duprN mm/arch/arm/boot/dts/exynos5430-a8_kor_open_05.dts n/arch/arm/boot/dts/exynos5430-a8_kor_open_05.dts
--- mm/arch/arm/boot/dts/exynos5430-a8_kor_open_05.dts	2016-09-20 17:29:26.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5430-a8_kor_open_05.dts	2017-03-31 10:41:26.000000000 +0530
@@ -70,9 +70,9 @@
 		cfg_en: cfg-en {
 			samsung,pins ="gpg1-4";
 			samsung,pin-function = <1>;
-			samsung,pin-pud = <1>;
+			samsung,pin-pud = <0>;
 			samsung,pin-con-pdn = <3>;
-			samsung,pin-pud-pdn = <1>;
+			samsung,pin-pud-pdn = <0>;
 		};
 	};
 
diff -duprN mm/arch/arm/boot/dts/exynos5430-a8_mea_open_03.dts n/arch/arm/boot/dts/exynos5430-a8_mea_open_03.dts
--- mm/arch/arm/boot/dts/exynos5430-a8_mea_open_03.dts	2016-09-20 17:29:26.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5430-a8_mea_open_03.dts	2017-03-31 10:41:26.000000000 +0530
@@ -69,9 +69,9 @@
 		cfg_en: cfg-en {
 			samsung,pins ="gpg1-4";
 			samsung,pin-function = <1>;
-			samsung,pin-pud = <1>;
+			samsung,pin-pud = <0>;
 			samsung,pin-con-pdn = <3>;
-			samsung,pin-pud-pdn = <1>;
+			samsung,pin-pud-pdn = <0>;
 		};
 	};
 
diff -duprN mm/arch/arm/boot/dts/exynos5430-a8_mea_open_04.dts n/arch/arm/boot/dts/exynos5430-a8_mea_open_04.dts
--- mm/arch/arm/boot/dts/exynos5430-a8_mea_open_04.dts	2016-09-20 17:29:26.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5430-a8_mea_open_04.dts	2017-03-31 10:41:26.000000000 +0530
@@ -69,9 +69,9 @@
 		cfg_en: cfg-en {
 			samsung,pins ="gpg1-4";
 			samsung,pin-function = <1>;
-			samsung,pin-pud = <1>;
+			samsung,pin-pud = <0>;
 			samsung,pin-con-pdn = <3>;
-			samsung,pin-pud-pdn = <1>;
+			samsung,pin-pud-pdn = <0>;
 		};
 	};
 
diff -duprN mm/arch/arm/boot/dts/exynos5430-a8_mea_open_05.dts n/arch/arm/boot/dts/exynos5430-a8_mea_open_05.dts
--- mm/arch/arm/boot/dts/exynos5430-a8_mea_open_05.dts	2016-09-20 17:29:26.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5430-a8_mea_open_05.dts	2017-03-31 10:41:26.000000000 +0530
@@ -69,9 +69,9 @@
 		cfg_en: cfg-en {
 			samsung,pins ="gpg1-4";
 			samsung,pin-function = <1>;
-			samsung,pin-pud = <1>;
+			samsung,pin-pud = <0>;
 			samsung,pin-con-pdn = <3>;
-			samsung,pin-pud-pdn = <1>;
+			samsung,pin-pud-pdn = <0>;
 		};
 	};
 
diff -duprN mm/arch/arm/boot/dts/exynos5430-s_common.dtsi n/arch/arm/boot/dts/exynos5430-s_common.dtsi
--- mm/arch/arm/boot/dts/exynos5430-s_common.dtsi	2016-09-20 17:29:26.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5430-s_common.dtsi	2017-03-31 10:41:26.000000000 +0530
@@ -1109,6 +1109,7 @@
 		compatible = "samsung,exynos5430-ion";
 
 		contig-names = "common",
+			       "video_ext",
 			       "mfc_sh",
 			       "g2d_wfd",
 			       "video",
@@ -1118,17 +1119,20 @@
 			       "secdma";
 
 		contig = <0 0x400000 0x0>,
+		         <1 0x600000 0x0>,
 		         <2 0x100000 0x0>,
 		         <10 0x800000 0x0>,
 		         <11 0x6600000 0x0>,
 		         <9 0x100000 0x0>,
-		         <8 0x200000 0x0>,
-		         <12 0x200000 0x0>,
+		         <8 0x300000 0x0>,
+		         <12 0x300000 0x0>,
 		         <13 0x20000 0x0>;
 
-		contig-isolate_on_boot = <0>, <2>, <8>,
+		contig-isolate_on_boot = <0>, <1>, <2>, <8>,
 					  <9>, <10>, <11>, <12>, <13>;
 
+		secure = <11>, <9>, <8>, <1>;
+
 		ion_noncontig_heap {
 			id-type = <0 0>;
 		};
diff -duprN mm/arch/arm/boot/dts/exynos5430-universal5430.dts n/arch/arm/boot/dts/exynos5430-universal5430.dts
--- mm/arch/arm/boot/dts/exynos5430-universal5430.dts	2016-09-20 17:29:28.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5430-universal5430.dts	2017-03-31 10:41:26.000000000 +0530
@@ -1212,6 +1212,7 @@
 		compatible = "samsung,exynos5430-ion";
 
 		contig-names = "common",
+			       "video_ext",
 			       "mfc_sh",
 			       "g2d_wfd",
 			       "video",
@@ -1221,17 +1222,20 @@
 			       "secdma";
 
 		contig = <0 0x400000 0x0>,
+		         <1 0x600000 0x0>,
 		         <2 0x100000 0x0>,
 		         <10 0x800000 0x0>,
 		         <11 0xC800000 0x0>,
 		         <9 0x100000 0x0>,
-		         <8 0x200000 0x0>,
-		         <12 0x200000 0x0>,
+		         <8 0x300000 0x0>,
+		         <12 0x300000 0x0>,
 		         <13 0x20000 0x0>;
 
-		contig-isolate_on_boot = <0>, <2>, <8>,
+		contig-isolate_on_boot = <0>, <1>, <2>, <8>,
 					  <9>, <10>, <11>, <12>, <13>;
 
+		secure = <11>, <9>, <8>, <1>;
+
 		ion_noncontig_heap {
 			id-type = <0 0>;
 		};
diff -duprN mm/arch/arm/boot/dts/exynos5430-xyref5430.dts n/arch/arm/boot/dts/exynos5430-xyref5430.dts
--- mm/arch/arm/boot/dts/exynos5430-xyref5430.dts	2016-09-20 17:29:28.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5430-xyref5430.dts	2017-03-31 10:41:26.000000000 +0530
@@ -1182,6 +1182,7 @@
 		compatible = "samsung,exynos5430-ion";
 
 		contig-names = "common",
+			       "video_ext",
 			       "mfc_sh",
 			       "g2d_wfd",
 			       "video",
@@ -1191,17 +1192,20 @@
 			       "secdma";
 
 		contig = <0 0x400000 0x0>,
+		         <1 0x600000 0x0>,
 		         <2 0x100000 0x0>,
 		         <10 0x800000 0x0>,
 		         <11 0x8100000 0x0>,
 		         <9 0x100000 0x0>,
-		         <8 0x200000 0x0>,
-		         <12 0x200000 0x0>,
+		         <8 0x300000 0x0>,
+		         <12 0x300000 0x0>,
 		         <13 0x20000 0x0>;
 
-		contig-isolate_on_boot = <0>, <2>, <8>,
+		contig-isolate_on_boot = <0>, <1>, <2>, <8>,
 					  <9>, <10>, <11>, <12>, <13>;
 
+		secure = <11>, <9>, <8>, <1>;
+
 		ion_noncontig_heap {
 			id-type = <0 0>;
 		};
diff -duprN mm/arch/arm/boot/dts/exynos5433-a8hplte_battery_00.dtsi n/arch/arm/boot/dts/exynos5433-a8hplte_battery_00.dtsi
--- mm/arch/arm/boot/dts/exynos5433-a8hplte_battery_00.dtsi	2016-09-20 17:29:28.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5433-a8hplte_battery_00.dtsi	2017-03-31 10:41:26.000000000 +0530
@@ -127,7 +127,7 @@
 		battery,input_current_limit = <1750 0 0 1750 500 900 1000 500 1000 0 760 1900 1800 0 1400 400 700 1300 300 1000 1600>;
 		battery,fast_charging_current = <2100 0 0 2100 750 1200 1000 750 1200 0 900 1600 2100 0 1400 400 700 1300 300 1000 1900>;
 		battery,full_check_current_1st = <200 0 0 200 200 200 200 200 200 0 200 200 200 0 200 200 200 200 200 200 200>;
-		battery,full_check_current_2nd = <150 0 0 150 150 150 150 150 150 0 150 150 150 0 150 150 150 150 150 150 150>;
+		battery,full_check_current_2nd = <100 0 0 100 100 100 100 100 100 0 100 100 100 0 100 100 100 100 100 100 100>;
 
 		battery,inbat_voltage = <1>;
 		battery,inbat_voltage_table_adc = <2661 2620 2600 2586 2566 2536 2513 2486 2461 2431
@@ -215,6 +215,7 @@
 		battery,swelling_low_temp_block = <50>;
 		battery,swelling_low_temp_recov = <100>;
 		battery,swelling_chg_current = <1300>;
+		battery,swelling_topoff_current = <175>;
 		battery,swelling_drop_float_voltage = <4200>;
 		battery,swelling_high_rechg_voltage = <4150>;
 		battery,swelling_low_rechg_voltage = <4050>;
@@ -259,7 +260,7 @@
 		battery,chg_gpio_status = <0>;
 		battery,chg_polarity_status = <0>;
 		battery,chg_float_voltage = <4390>;
-		chg_autostop = <0>;
+		chg_autostop = <1>;
 		chg_autoset = <1>;
 		chg_aiclen = <1>;
 		chg_aiclth = <4300>;
diff -duprN mm/arch/arm/boot/dts/exynos5433-a8hplte_common.dtsi n/arch/arm/boot/dts/exynos5433-a8hplte_common.dtsi
--- mm/arch/arm/boot/dts/exynos5433-a8hplte_common.dtsi	2016-09-20 17:29:28.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5433-a8hplte_common.dtsi	2017-03-31 10:41:26.000000000 +0530
@@ -578,16 +578,16 @@
 
 			/* Frequency table */
 			/* for level	:		1_Head, 2_Tail, 3_Head, 4_Head/Tail, 5_Head, 9_Head, 9_Tail */
-			input_booster,cpu_freqs = <1200000 0 0 0 1000000 1800000 1500000>;
-			input_booster,hmp_boost = <1 0 0 0 1 1 1>;
-			input_booster,kfc_freqs = <1000000 1300000 1300000 1300000 800000 1300000 1300000>;
-			input_booster,mif_freqs = <667000 413000 413000 667000 667000 825000 825000>;
-			input_booster,int_freqs = <334000 133000 133000 133000 334000 400000 400000>;
+			input_booster,cpu_freqs = <1200000 0 0 0 0 1800000 1400000>;
+			input_booster,hmp_boost = <1 0 0 0 0 1 1>;
+			input_booster,kfc_freqs = <0 1200000 1200000 1200000 1200000 1300000 1300000>;
+			input_booster,mif_freqs = <667000 413000 413000 413000 413000 825000 825000>;
+			input_booster,int_freqs = <267000 0 0 0 0 400000 400000>;
 
 			/* Time table */
-			input_booster,head_times = <130 130 130 130 120 500 0>;
+			input_booster,head_times = <130 130 130 130 130 500 0>;
 			input_booster,tail_times = <500 500 500 200 500 1000 0>;
-			input_booster,phase_times = <0 0 0 0 20 0 0>;
+			input_booster,phase_times = <0 0 0 0 0 0 0>;
 		};
 		booster_key@2 {
 			input_booster,label = "KEY";
@@ -1228,15 +1228,6 @@
 			net_boost,table= <64 0 0 1300000 0 825000 400000 0 0 0>;
 		};
 		boot_device@3 {
-			net_boost,label="WIFI";
-			net_boost,node="wlan0";
-			net_boost,table_size = <3>;
-			/*		 <Throughput ARM_min ARM_max KFC_min KFC_max MIF INT Task Irq HMPBoost> */
-			net_boost,table= <60 1000000 0 800000 0 0 200000 0 0 0
-					  100 1200000 0 1000000 0 0 200000 0 0 1
-					  180 1700000 0 1100000 0 543000 267000 0 0 1>;
-		};
-		boot_device@4 {
 			net_boost,label="P2P";
 			net_boost,node="p2p-wlan0-0";
 			net_boost,table_size = <3>;
@@ -1245,7 +1236,7 @@
 					  50 1200000 0 1000000 0 0 200000 0 0 0
 					  90 1700000 0 1100000 0 543000 267000 0 0 1>;
 		};
-		boot_device@5 {
+		boot_device@4 {
 			net_boost,label="CLAT";
 			net_boost,node="clat clat4";
 			net_boost,table_size = <3>;
@@ -1254,6 +1245,32 @@
 					  130 1500000 0 0 0 825000 0 0 0 0
 					  150 1600000 0 0 0 825000 0 0 0 0>;
 		};
+
+		boot_device@5 {
+			net_boost,label="WIFI";
+			net_boost,node="wlan0";
+			net_boost,table_size = <1>;
+			net_boost,table= <
+				180 0 0 0 0 0 0 1 1 1
+				>;
+		 };
+		boot_device@6 {
+			net_boost,label="WIFI TX";
+			net_boost,node="wlan0";
+			net_boost,table_size = <3>;
+			net_boost,table= <60 1000000 0 800000 0 0 200000 0 0 0
+					  100 1200000 0 1000000 0 0 200000 0 0 1
+					  180 1700000 0 1100000 0 543000 267000 0 0 1>;
+		};
+		boot_device@7 {
+			net_boost,label="WIFI RX";
+			net_boost,node="wlan0";
+			net_boost,table_size = <2>;
+			net_boost,table= <
+				80 1500000 0 1200000 0 0 200000 0 0 0
+				180 1800000 0 1300000 0 543000 267000 1 1 1
+				>;
+		};
 	};
 
 	/* BT Uart */
diff -duprN mm/arch/arm/boot/dts/exynos5433-a8hplte_jpn-isdbt-00.dtsi n/arch/arm/boot/dts/exynos5433-a8hplte_jpn-isdbt-00.dtsi
--- mm/arch/arm/boot/dts/exynos5433-a8hplte_jpn-isdbt-00.dtsi	1970-01-01 05:30:00.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5433-a8hplte_jpn-isdbt-00.dtsi	2017-03-31 10:41:26.000000000 +0530
@@ -0,0 +1,57 @@
+ /* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/{
+	spi_1: spi@14d30000 {
+		#address-cells = <1>;
+		#size-cells = <0>;
+		num-cs = <1>;
+
+		dma-mode;
+		dmas = <&pdma0 11
+			&pdma0 10>;
+		dma-names = "tx", "rx";
+
+		swap-mode;
+		status = "ok";
+		spi-clkoff-time = <100>;
+
+		isdbt-spi@0 {
+			compatible = "isdbt_spi_comp";
+			reg = <0>;
+			spi-max-frequency = <50000000>;
+			controller-data {
+				cs-gpio = <&gpd6 3 0>;
+				samsung,spi-feedback-delay = <3>;
+			};
+		};
+	};
+
+	isdbt_fc8300_data {
+		compatible = "isdb_fc8300_pdata";
+		isdbt,isdb-gpio-pwr-en = <&gpf5 6 0>;
+		isdbt,isdb-gpio-rst = <&gpf1 7 0>;
+		isdbt,isdb-gpio-irq = <&gpa0 1 0x01>;
+		/* isdbt,isdb-gpio-i2c_sda = <&gpd0 2 0>; */
+		/* isdbt,isdb-gpio-i2c_scl = <&gpd0 3 0>; */
+		isdbt,isdb-gpio-spi_do = <&gpd6 5 0>;
+		isdbt,isdb-gpio-spi_di = <&gpd6 4 0>;
+		isdbt,isdb-gpio-spi_cs = <&gpd6 3 0>;
+		isdbt,isdb-gpio-spi_clk = <&gpd6 2 0>;
+		isdbt,isdb-bbm-xtal-freq = <24000>;
+		/* isdbt,ldo_vdd_1p8 = "VDD_1.8V_ESE"; */
+
+		clocks = <&clock 4300>;
+		clock-names = "isdbt_clkout";
+	};
+
+};
diff -duprN mm/arch/arm/boot/dts/exynos5433-a8hplte_jpn-secnfc-tuner-r00.dtsi n/arch/arm/boot/dts/exynos5433-a8hplte_jpn-secnfc-tuner-r00.dtsi
--- mm/arch/arm/boot/dts/exynos5433-a8hplte_jpn-secnfc-tuner-r00.dtsi	1970-01-01 05:30:00.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5433-a8hplte_jpn-secnfc-tuner-r00.dtsi	2017-03-31 10:41:26.000000000 +0530
@@ -0,0 +1,160 @@
+/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/{
+
+//	/delete-node/ i2c@50;
+//	/delete-node/ serial@14C20000;
+	i2c@2B {
+		compatible = "i2c-gpio";
+		gpios = <&gpd4 3 0 &gpd4 4 0>;
+		i2c-gpio,delay-us = <2>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		status = "ok";
+		felica_i2c@2B
+		{
+			compatible = "felica,felica-i2c";
+			reg = <0x2B>;
+		};
+	};
+
+	serial@14C20000 {
+		/delete-property/ pinctrl-names;
+		/delete-property/ pinctrl-0;
+	};
+
+	pinctrl@14CC0000 {
+		/delete-node/ uart1_bus;
+
+		uart1_bus: uart1-bus {
+			samsung,pins = "gpd1-3", "gpd1-2", "gpd1-1", "gpd1-0";
+			samsung,pin-function = <2>;
+			samsung,pin-pud = <0>;
+			samsung,pin-con-pdn = <3>;	/* Prev state on sleep */
+			samsung,pin-pud-pdn = <0>;
+		};
+
+		uart1_lpm: uart1-lpm {
+			samsung,pins = "gpd1-3", "gpd1-2", "gpd1-1", "gpd1-0";
+			samsung,pin-function = <0>;
+			samsung,pin-pud = <0>;
+			samsung,pin-drv = <0>;
+		};
+	};
+
+	pinctrl@10580000
+	{
+		felica_nfc_pon: pon	/* VEN PIN */
+		{
+			samsung,pins = "gpf1-4";
+			samsung,pin-function = <1>;	/* Output */
+			samsung,pin-pud = <0>;		/* NONE */
+			samsung,pin-drv = <3>;		/* High */
+			samsung,pin-con-pdn = <3>;	/* Prev state on sleep */
+			samsung,pin-pud-pdn = <0>;
+		};
+
+		felica_nfc_pon_lpm: lpm
+		{
+			samsung,pins = "gpf1-4";
+                        samsung,pin-function = <0>;     /* input */
+                        samsung,pin-pud = <0>;          /* NONE*/
+                        samsung,pin-drv = <0>;          /* High */
+		};
+
+		felica_nfc_int: int	/* IRQ PIN */
+		{
+			samsung,pins = "gpa1-0";
+			samsung,pin-function = <0xf>;	/* WAKE_EXT_INT */
+			samsung,pin-pud = <1>;		/* Pull Down Enabled */
+			samsung,pin-drv = <3>;		/* High */
+		};
+
+		sec_nfc_rfs: sec-nfc-rfs
+		{
+			samsung,pins = "gpf1-6";
+			samsung,pin-function = <1>;
+			samsung,pin-pud = <0>;
+			samsung,pin-drv = <0>;
+		};
+
+		sec_nfc_rfs_lpm: sec-nfc-rfs-lpm
+		{
+			samsung,pins = "gpf1-6";
+			samsung,pin-function = <0>;
+			samsung,pin-pud = <0>;
+			samsung,pin-drv = <0>;
+		};
+	};
+
+	pinctrl@14CC0000
+	{
+		//SIM_PWR_SEL
+		sec_nfc_ldo: active
+		{
+			samsung,pins = "gpc0-2";
+	                samsung,pin-function = <1>;
+			samsung,pin-pud = <0>;
+			samsung,pin-drv = <0>;
+			samsung,pin-val = <1>;
+			samsung,pin-con-pdn = <3>;
+			samsung,pin-pud-pdn = <0>;
+		};
+		sec_nfc_ldo_lpm: lpm
+                {
+                        samsung,pins = "gpc0-2";
+                        samsung,pin-function = <0>;
+                        samsung,pin-pud = <0>;
+                        samsung,pin-drv = <0>;
+                };
+	};
+
+	senn3ab_fn
+	{
+		status = "okay";
+		compatible = "sec-nfc-fn";
+		interrupt-parent = <&gpa1>;
+		interrupts = <0 0>;
+
+		sec-nfc-fn,int-gpio = <&gpa1 0 0x00>;
+	};
+
+	senn3ab
+	{
+		status = "okay";
+		compatible = "sec-nfc";
+		interrupt-parent = <&gpa1>;
+		interrupts = <0 0 0>;
+
+
+		sec-nfc,irq-gpio = <&gpa1 0 0x00>;
+		sec-nfc,pon-gpio = <&gpf1 4 0x00>;
+		sec-nfc,rfs-gpio = <&gpf1 6 0x0>;
+//		sec-nfc,tvdd-gpio = <&gpc0 2 0x1>;
+
+		//sec-nfc,i2c_1p8 = "VDD_NFC_1.8V"; // not use A8
+		//sec-nfc,regulator_tvdd = "vdd_tx_2p8"; // not use A8
+		sec-nfc,regulator_tvdd = "VDD_NFC_1.8V"; // PVDD
+		pinctrl-names = "sec_nfc_active", "sec_nfc_suspend", "sec_nfc_lpm"; /*, "sec_nfc_uart_suspend", "sec_nfc_uart_active" */
+		pinctrl-0 = <&felica_nfc_pon &felica_nfc_int &sec_nfc_rfs &uart1_bus>;
+		pinctrl-1 = <&felica_nfc_pon &felica_nfc_int &uart1_bus>;
+		pinctrl-2 = <&felica_nfc_pon_lpm &felica_nfc_int &uart1_lpm &sec_nfc_rfs_lpm>;
+//		pinctrl-0 = <&felica_nfc_pon &felica_nfc_int &uart1_bus &sec_nfc_ldo>;
+//		pinctrl-1 = <&felica_nfc_pon &felica_nfc_int &uart1_suspend &sec_nfc_ldo>;
+//		pinctrl-2 = <&felica_nfc_pon_lpm &felica_nfc_int &uart1_lpm &sec_nfc_rfs_lpm &sec_nfc_ldo_lpm>;
+		/*
+		pinctrl-2 = <&felica_nfc_uart_suspend>;
+		pinctrl-3 = <&felica_nfc_uart_active>;
+		*/
+	};
+};
diff -duprN mm/arch/arm/boot/dts/exynos5433-a8hplte_jpn_battery_00.dtsi n/arch/arm/boot/dts/exynos5433-a8hplte_jpn_battery_00.dtsi
--- mm/arch/arm/boot/dts/exynos5433-a8hplte_jpn_battery_00.dtsi	1970-01-01 05:30:00.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5433-a8hplte_jpn_battery_00.dtsi	2017-03-31 10:41:26.000000000 +0530
@@ -0,0 +1,268 @@
+/*
+ * SAMSUNG UNIVERSAL5433 board device tree source
+ *
+ * Copyright (c) 2013 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+/ {
+	pinctrl@14CA0000 {
+		factory_discharging: factory_discharging {
+			samsung,pins = "gpj2-2";
+			samsung,pin-function = <1>;
+			samsung,pin-pud = <0>;
+		};
+	};
+
+	pinctrl@10580000 {
+		ovp_en: ovp_en {
+			samsung,pins = "gpa0-6";
+			samsung,pin-function = <0>;
+			samsung,pin-pud = <1>;
+			samsung,pin-drv = <3>;
+		};
+	};
+
+	pinctrl@10580000 {
+		fuel_irq: fuel-irq {
+			samsung,pins = "gpa1-5";
+			samsung,pin-function = <0>;
+			samsung,pin-pud = <0>;
+			samsung,pin-drv = <0>;
+		};
+	};
+
+	hsi2c@14E50000 {
+		status = "okay";
+		max77843@66 {
+			status = "okay";
+			compatible = "maxim,max77843";
+			reg = <0x66>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&fuel_irq &vibetonz_pwm &ovp_en>;
+			max77843,irq-gpio = <&gpa1 5 1>;
+			max77843,wakeup;
+
+			regulators {
+				safeout1: ESAFEOUT1 {
+					regulator-compatible = "safeout1";
+					regulator-name = "safeout1_range";
+					regulator-min-microvolt = <3300000>;
+					regulator-max-microvolt = <4900000>;
+					regulator-boot-on;
+				};
+
+				safeout2: ESAFEOUT2 {
+					regulator-compatible = "safeout2";
+					regulator-name = "safeout2_range";
+					regulator-min-microvolt = <3300000>;
+					regulator-max-microvolt = <4900000>;
+				};
+			};
+		};
+	};
+	battery {
+		status = "okay";
+
+		pinctrl-names = "default";
+		pinctrl-0 = <&factory_discharging>;
+
+		battery,factory_discharging = <&gpj2 2 0>;
+
+		compatible = "samsung,sec-battery";
+		battery,vendor = "SDI SDI";
+		battery,charger_name = "max77843-charger";
+		battery,fuelgauge_name = "max77843-fuelgauge";
+		battery,technology = <2>; /* POWER_SUPPLY_TECHNOLOGY_LION */
+		/* .temp_cohot = -1000; */
+		/* .temp_cocold = -4325; */
+
+		battery,chip_vendor = "LSI";
+		battery,temp_adc_type = <1>; /* SEC_BATTERY_ADC_TYPE_AP */
+
+		battery,polling_time = <10 30 30 30 3600>;
+		battery,chg_temp_check = <1>;
+
+		battery,temp_table_adc = <294 304 314 325 335 345 357 369 382 391
+				  406 420 434 449 463 477 494 511 527 544
+			554 573 591 610 628 646 670 693 717 740
+			763 788 813 838 863 888 918 948 977 1007
+			1036 1070 1103 1137 1170 1203 1241 1279 1316 1354
+			1391 1432 1473 1514 1555 1595 1640 1684 1729 1773
+			1817 1865 1912 1959 2006 2053 2098 2142 2186 2230
+			2274 2327 2379 2432 2484 2536 2582 2628 2673 2719
+			2764 2808 2851 2895 2938 2981 3024 3066 3109 3151
+			3193 3229 3264 3300 3335 3370 3401 3432 3463 3494
+			3524 3550 3576 3601 3627 3652 3673 3693 3714 3734 3754>;
+
+		battery,temp_table_data = <900 890 880 870 860 850 840 830 820 810
+			800 790 780 770 760 750 740 730 720 710
+			700 690 680 670 660 650 640 630 620 610
+			600 590 580 570 560 550 540 530 520 510
+			500 490 480 470 460 450 440 430 420 410
+			400 390 380 370 360 350 340 330 320 310
+			300 290 280 270 260 250 240 230 220 210
+			200 190 180 170 160 150 140 130 120 110
+			100 90 80 70 60 50 40 30 20 10
+			0 (-10) (-20) (-30) (-40) (-50) (-60) (-70) (-80) (-90)
+			(-100) (-110) (-120) (-130) (-140) (-150) (-160) (-170) (-180) (-190) (-200)>;
+
+		battery,chg_temp_table_adc = <294 304 314 325 335 345 357 369 382 391
+				  406 420 434 449 463 477 494 511 527 544
+			554 573 591 610 628 646 670 693 717 740
+			763 788 813 838 863 888 918 948 977 1007
+			1036 1070 1103 1137 1170 1203 1241 1279 1316 1354
+			1391 1432 1473 1514 1555 1595 1640 1684 1729 1773
+			1817 1865 1912 1959 2006 2053 2098 2142 2186 2230
+			2274 2327 2379 2432 2484 2536 2582 2628 2673 2719
+			2764 2808 2851 2895 2938 2981 3024 3066 3109 3151
+			3193 3229 3264 3300 3335 3370 3401 3432 3463 3494
+			3524 3550 3576 3601 3627 3652 3673 3693 3714 3734 3754>;
+
+		battery,chg_temp_table_data = <900 890 880 870 860 850 840 830 820 810
+			800 790 780 770 760 750 740 730 720 710
+			700 690 680 670 660 650 640 630 620 610
+			600 590 580 570 560 550 540 530 520 510
+			500 490 480 470 460 450 440 430 420 410
+			400 390 380 370 360 350 340 330 320 310
+			300 290 280 270 260 250 240 230 220 210
+			200 190 180 170 160 150 140 130 120 110
+			100 90 80 70 60 50 40 30 20 10
+			0 (-10) (-20) (-30) (-40) (-50) (-60) (-70) (-80) (-90)
+			(-100) (-110) (-120) (-130) (-140) (-150) (-160) (-170) (-180) (-190) (-200)>;
+
+		battery,inbat_voltage = <1>;
+		battery,inbat_voltage_table_adc = <2800 2789 2768 2737 2704 2678 2646 2619 2590 2556
+						2516 2499 2460 2440 2413 2381 2352 2310 2290 2267 2233>;
+		battery,inbat_voltage_table_data = <438 435 430 425 420 415 410 405 400 395
+						390 385 380 375 370 365 360 355 350 345 340>;
+
+		battery,input_current_limit = <1800 0 0 1800 460 900 1000 460 1000 0 820 1900 1800 0 0 400 700 1300 300 1000 1500 0 1667 1000 1667 80 1800>;
+		battery,fast_charging_current = <2100 0 0 2100 460 1200 1000 460 1200 0 1000 1600 2100 0 0 400 700 1300 300 1000 1500 0 2800 1000 2800 80 1800>;
+		battery,full_check_current_1st = <350 0 0 350 350 350 350 350 350 0 350 350 350 0 0 350 350 350 350 350 350 0 350 350 350 0 350>;
+		battery,full_check_current_2nd = <150 0 0 150 150 150 150 150 150 0 150 150 150 0 0 150 150 150 150 150 150 0 150 150 150 0 150>;
+
+		battery,adc_check_count = <5>;
+
+		battery,cable_check_type = <4>; /* SEC_BATTERY_CABLE_CHECK_PSY */
+		battery,cable_source_type = <1>; /* SEC_BATTERY_CABLE_SOURCE_EXTERNAL */
+		battery,event_waiting_time = <600>;
+		battery,polling_type = <1>; /* SEC_BATTERY_MONITOR_ALARM */
+		battery,monitor_initial_count = <0>;
+
+		battery,battery_check_type = <0>; /* SEC_BATTERY_CHECK_NONE */
+		battery,check_count = <0>;
+		battery,check_adc_max = <1440>;
+		battery,check_adc_min = <0>;
+
+		battery,ovp_uvlo_check_type = <3>; /* SEC_BATTERY_OVP_UVLO_CHGPOLLING */
+
+		battery,thermal_source = <2>; /* SEC_BATTERY_THERMAL_SOURCE_ADC */
+
+		battery,temp_check_type = <2>; /* _BATTERY_TEMP_CHECK_TEMP */
+		battery,temp_check_count = <1>;
+		battery,temp_highlimit_threshold_event = <800>;
+		battery,temp_highlimit_recovery_event = <750>;
+		battery,temp_high_threshold_event = <580>;
+		battery,temp_high_recovery_event = <530>;
+		battery,temp_low_threshold_event = <(-30)>;
+		battery,temp_low_recovery_event = <0>;
+		battery,temp_highlimit_threshold_normal = <800>;
+		battery,temp_highlimit_recovery_normal = <750>;
+		battery,temp_high_threshold_normal = <580>;
+		battery,temp_high_recovery_normal = <530>;
+		battery,temp_low_threshold_normal = <(-50)>;
+		battery,temp_low_recovery_normal = <0>;
+		battery,temp_highlimit_threshold_lpm = <800>;
+		battery,temp_highlimit_recovery_lpm = <750>;
+		battery,temp_high_threshold_lpm = <580>;
+		battery,temp_high_recovery_lpm = <530>;
+		battery,temp_low_threshold_lpm = <(-50)>;
+		battery,temp_low_recovery_lpm = <0>;
+		battery,full_check_type = <7>; /* SEC_BATTERY_FULLCHARGED_CHGPSY */
+		battery,full_check_type_2nd = <7>; /* SEC_BATTERY_FULLCHARGED_CHGPSY */
+		battery,full_check_count = <1>;
+		battery,chg_gpio_full_check = <0>;
+		battery,chg_polarity_full_check = <1>;
+
+		battery,chg_high_temp_1st = <440>;
+		battery,chg_high_temp_2nd = <200>;
+		battery,chg_high_temp_recovery = <200>;
+		battery,chg_charging_limit_current = <1467>;
+		battery,chg_charging_limit_current_2nd = <1467>;
+
+		/* SEC_BATTERY_FULL_CONDITION_SOC |
+		   SEC_BATTERY_FULL_CONDITION_NOTIMEFULL |
+		   SEC_BATTERY_FULL_CONDITION_VCELL */
+		battery,full_condition_type = <13>;
+		battery,full_condition_soc = <93>;
+		battery,full_condition_vcell = <4300>;
+
+		battery,recharge_check_count = <2>;
+		battery,recharge_condition_type = <4>; /* SEC_BATTERY_RECHARGE_CONDITION_VCELL */
+		battery,recharge_condition_soc = <98>;
+		battery,recharge_condition_vcell = <4350>;
+
+		battery,charging_total_time = <21600>;
+		battery,recharging_total_time = <5400>;
+		battery,charging_reset_time = <0>;
+
+		io-channels = <&exynos_adc 1>, <&exynos_adc 7>, <&exynos_adc 3>, <&exynos_adc 4>;
+		io-channel-names = "adc-temp", "in-bat-adc", "discharging-check-adc", "chg-adc-temp";
+		#io-channel-cells = <2>;
+		io-channel-ranges;
+
+		battery,chg_float_voltage = <4400>;
+
+		battery,self_discharging_en;
+		battery,force_discharging_limit = <650>;
+		battery,force_discharging_recov = <550>;
+		battery,self_discharging_voltage_limit = <4250>;
+		battery,discharging_adc_max = <2600>;
+		battery,discharging_adc_min = <1700>;
+		battery,discharging_ntc_limit = <2750>;
+		battery,swelling_high_temp_block = <500>;
+		battery,swelling_high_temp_recov = <450>;
+		battery,swelling_low_temp_block = <50>;
+		battery,swelling_low_temp_recov = <100>;
+		battery,swelling_chg_current = <1300>;
+		battery,swelling_drop_float_voltage = <4200>;
+		battery,swelling_high_rechg_voltage = <4150>;
+		battery,swelling_low_rechg_voltage = <4050>;
+		battery,swelling_block_time = <600>;
+	};
+
+	max77843-fuelgauge {
+		status = "disable";
+		fuelgauge,fuel_alert_soc = <1>;
+		fuelgauge,capacity_max = <990>;
+		fuelgauge,capacity_max_margin = <50>;
+		fuelgauge,capacity_min = <(-7)>;
+		fuelgauge,capacity_calculation_type = <28>;
+		fuelgauge,repeated_fuelalert;
+		fuelgauge,rcomp0 = <0x3e>;
+		fuelgauge,rcomp_charging = <0x3e>;
+		fuelgauge,qrtable20 = <0x1280>;
+		fuelgauge,qrtable30 = <0x0d80>;
+		fuelgauge,temp_cohot = <(-1000)>;
+		fuelgauge,temp_cocold = <(-4325)>;
+		fuelgauge,is_using_model_data;
+		fuelgauge,type_str = "SDI";
+		fuelgauge,capacity = <0x1658>;
+		fuelgauge,low_battery_comp_voltage = <3600>;
+		fuelgauge,low_battery_table = <(-5000) 0 0 (-1250) 0 3320 (-750) 97 3451 (-100) 96 3461 0 0 3456>;
+
+	};
+	max77843-charger {
+	        status = "disable";
+		battery,chg_gpio_en = <0>;
+		battery,chg_polarity_en = <0>;
+		battery,chg_gpio_status = <0>;
+		battery,chg_polarity_status = <0>;
+		battery,chg_float_voltage = <4400>;
+	};
+};
diff -duprN mm/arch/arm/boot/dts/exynos5433-a8hplte_jpn_gpio_00.dtsi n/arch/arm/boot/dts/exynos5433-a8hplte_jpn_gpio_00.dtsi
--- mm/arch/arm/boot/dts/exynos5433-a8hplte_jpn_gpio_00.dtsi	1970-01-01 05:30:00.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5433-a8hplte_jpn_gpio_00.dtsi	2017-03-31 10:41:26.000000000 +0530
@@ -0,0 +1,353 @@
+/*
+ * Copyright (c) 2014 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+
+// Support A8 VE JPN LTE HW REV00
+
+#include "exynos_gpio_config_macros.dtsi"
+
+&pinctrl_0 {
+	pinctrl-names = "default","sleep";
+	pinctrl-0 = <&initial0>;
+	pinctrl-1 = <&sleep0>;
+
+	initial0: initial-state {
+		PIN_IN(gpa0-0, NONE, LV1);	/* EAR_ANT_DET */
+		PIN_IN(gpa1-2, DOWN, LV1);	/* NC */
+		PIN_IN(gpa1-4, NONE, LV1);	/* 3_4_POLE_DET */
+
+		PIN_IN(gpf1-0, DOWN, LV1);	/* NC */
+
+		PIN_IN(gpf5-0, DOWN, LV1);	/* NC */
+	};
+	sleep0: sleep-state {
+		PIN_SLP(gpa0-0, INPUT, NONE);	/* EAR_ANT_DET */
+		PIN_SLP(gpa0-6, INPUT, DOWN);	/* OVP_EN */
+
+		PIN_SLP(gpa1-4, INPUT, NONE);	/* 3_4_POLE_DET */
+
+		PIN_SLP(gpf1-0, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpf1-1, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpf1-2, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpf1-3, INPUT, DOWN);	/* LCD_TE */
+		PIN_SLP(gpf1-5, PREV, NONE);	/* LCD_1.6V_EN */
+		PIN_SLP(gpf1-7, OUT0, DOWN);	/* ISDBT_RST */
+
+		PIN_SLP(gpf2-0, INPUT, DOWN);	/* BTP_CHECK */
+		PIN_SLP(gpf2-1, PREV, NONE);	/* CODEC_RESET_N */
+		PIN_SLP(gpf2-2, INPUT, DOWN);	/* AMP_RST */
+		PIN_SLP(gpf2-3, INPUT, DOWN);	/* NC */
+
+		PIN_SLP(gpf3-0, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpf3-1, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpf3-2, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpf3-3, INPUT, DOWN);	/* NC */
+
+		PIN_SLP(gpf4-0, PREV, DOWN);	/* BTP_LDO_EN */
+		PIN_SLP(gpf4-1, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpf4-2, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpf4-3, PREV, NONE);	/* AP_CP_STATUS */
+		PIN_SLP(gpf4-4, OUT0, NONE);	/* AP_CP_DUMP_NOTI_N */
+		PIN_SLP(gpf4-5, PREV, NONE);	/* AP_CP_PACKET_SEND */
+		PIN_SLP(gpf4-6, PREV, NONE);	/* AP_CP_WAKE */
+		PIN_SLP(gpf4-7, INPUT, DOWN);	/* AP_CP_GPIO_RSV - NC */
+
+		PIN_SLP(gpf5-0, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpf5-1, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpf5-2, PREV, DOWN);	/* BTP_RST_N */
+		PIN_SLP(gpf5-3, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpf5-4, OUT1, NONE);	/* WRSTB_IN */
+		PIN_SLP(gpf5-5, INPUT, DOWN);	/* EL_ON1_DET */
+		PIN_SLP(gpf5-6, OUT0, DOWN);	/* ISDBT_PWR_EN */
+		PIN_SLP(gpf5-7, INPUT, DOWN);	/* NC */
+	};
+};
+
+&pinctrl_1 {
+	pinctrl-names = "sleep";
+	pinctrl-0 = <&sleep1>;
+	sleep1: sleep-state {
+		PIN_SLP(gpz0-0, INPUT, DOWN);	/* MM_I2S_CLK */
+		PIN_SLP(gpz0-1, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpz0-2, INPUT, DOWN);	/* MM_I2S_SYNC */
+		PIN_SLP(gpz0-3, INPUT, DOWN);	/* MM_I2S_DI */
+		PIN_SLP(gpz0-4, INPUT, DOWN);	/* MM_I2S_DO */
+		PIN_SLP(gpz0-5, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpz0-6, INPUT, DOWN);	/* NC */
+
+		PIN_SLP(gpz1-0, OUT1, UP);	/* BT_UART_TXD */
+		PIN_SLP(gpz1-1, INPUT, UP);	/* BT_UART_RXD */
+		PIN_SLP(gpz1-2, INPUT, UP);	/* BT_UART_CTS */
+		PIN_SLP(gpz1-3, OUT1, UP);	/* BT_UART_RTS */
+	};
+};
+
+&pinctrl_2 {
+	pinctrl-names = "sleep";
+	pinctrl-0 = <&sleep2>;
+	sleep2: sleep-state {
+		PIN_SLP(gpv6-0, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpv6-1, INPUT, DOWN);	/* NC */
+	};
+};
+
+&pinctrl_3 {
+	pinctrl-names = "sleep";
+	pinctrl-0 = <&sleep3>;
+	sleep3: sleep-state {
+		PIN_SLP(gpj2-0, PREV, NONE);	/* WLAN_EN */
+		PIN_SLP(gpj2-1, OUT0, DOWN);	/* GPS_EN */
+		PIN_SLP(gpj2-2, INPUT, DOWN);	/* FACTORY_DISCHG */
+	};
+};
+
+&pinctrl_4 {
+	pinctrl-names = "sleep";
+	pinctrl-0 = <&sleep4>;
+	sleep4: sleep-state {
+		PIN_SLP(gpd5-0, OUT0, NONE);	/* BTP_SPI_CLK */
+		PIN_SLP(gpd5-1, OUT0, NONE);	/* BTP_SPI_CS_N */
+		PIN_SLP(gpd5-2, INPUT, DOWN);	/* BTP_SPI_MISO */
+		PIN_SLP(gpd5-3, OUT0, NONE);	/* BTP_SPI_MOSI */
+	};
+};
+
+&pinctrl_5 {
+	pinctrl-names = "default","sleep";
+	pinctrl-0 = <&initial5>;
+	pinctrl-1 = <&sleep5>;
+	initial5: initial-state {
+		PIN_IN(gph1-0, NONE, LV1);	/* VDD_1P8_AP 10K PU */
+		PIN_IN(gph1-1, DOWN, LV1);	/* NC */
+		PIN_IN(gph1-2, NONE, LV1);	/* VDD_1P8_AP 10K PU */
+		PIN_IN(gph1-3, DOWN, LV1);	/* NC */
+		PIN_IN(gph1-4, DOWN, LV1);	/* NC */
+		PIN_IN(gph1-5, DOWN, LV1);	/* NC */
+
+		PIN_IN(gpr3-5, DOWN, LV1);	/* NC */
+		PIN_IN(gpr3-6, DOWN, LV1);	/* NC */
+		PIN_IN(gpr3-7, DOWN, LV1);	/* NC */
+
+		PIN_IN(gpr4-2, DOWN, LV1);	/* NC */
+
+		PIN_IN(gpr0-3, DOWN, LV1);	/* NC */
+		PIN_IN(gpr0-4, DOWN, LV1);	/* NC */
+	};
+	sleep5: sleep-state {
+		PIN_SLP(gph1-0, INPUT, NONE);	/* VDD_1.8_AP P/U */
+		PIN_SLP(gph1-1, INPUT, DOWN);	/* NC */
+		PIN_SLP(gph1-2, INPUT, NONE);	/* VDD_1.8_AP P/U */
+		PIN_SLP(gph1-3, INPUT, DOWN);	/* NC */
+		PIN_SLP(gph1-4, INPUT, DOWN);	/* NC */
+		PIN_SLP(gph1-5, INPUT, DOWN);	/* NC */
+
+		PIN_SLP(gpr4-0, INPUT, DOWN);	/* T_FLASH_CLK */
+		PIN_SLP(gpr4-1, INPUT, DOWN);	/* T_FLASH_CMD */
+		PIN_SLP(gpr4-2, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpr4-3, INPUT, DOWN);	/* T_FLASH_D(0) */
+		PIN_SLP(gpr4-4, INPUT, DOWN);	/* T_FLASH_D(1) */
+		PIN_SLP(gpr4-5, INPUT, DOWN);	/* T_FLASH_D(2) */
+		PIN_SLP(gpr4-6, INPUT, DOWN);	/* T_FLASH_D(3) */
+
+		PIN_SLP(gpr0-0, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpr0-1, INPUT, NONE);	/* MEM_1P8 P/U */
+		PIN_SLP(gpr0-2, INPUT, DOWN);	/* PD GND */
+		PIN_SLP(gpr0-3, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpr0-4, INPUT, DOWN);	/* NC */
+
+		PIN_SLP(gpr1-0, INPUT, NONE);	/* MEM_VDD_1.8V */
+		PIN_SLP(gpr1-1, INPUT, NONE);	/* MEM_VDD_1.8V */
+		PIN_SLP(gpr1-2, INPUT, NONE);	/* MEM_VDD_1.8V */
+		PIN_SLP(gpr1-3, INPUT, NONE);	/* MEM_VDD_1.8V */
+		PIN_SLP(gpr1-4, INPUT, NONE);	/* MEM_VDD_1.8V */
+		PIN_SLP(gpr1-5, INPUT, NONE);	/* MEM_VDD_1.8V */
+		PIN_SLP(gpr1-6, INPUT, NONE);	/* MEM_VDD_1.8V */
+		PIN_SLP(gpr1-7, INPUT, NONE);	/* MEM_VDD_1.8V */
+
+		PIN_SLP(gpr2-0, OUT0, NONE);	/* WLAN_CLK */
+		PIN_SLP(gpr2-1, INPUT, NONE);	/* WLAN_CMD */
+
+		PIN_SLP(gpr3-0, INPUT, NONE);	/* WLAN_D(0) */
+		PIN_SLP(gpr3-1, INPUT, NONE);	/* WLAN_D(1) */
+		PIN_SLP(gpr3-2, INPUT, NONE);	/* WLAN_D(2) */
+		PIN_SLP(gpr3-3, INPUT, NONE);	/* WLAN_D(3) */
+		PIN_SLP(gpr3-4, PREV, NONE);	/* BUCK6_DVS */
+		PIN_SLP(gpr3-5, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpr3-6, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpr3-7, INPUT, DOWN);	/* NC */
+	};
+};
+
+&pinctrl_6 {
+	pinctrl-names = "default","sleep";
+	pinctrl-0 = <&initial6>;
+	pinctrl-1 = <&sleep6>;
+	initial6: initial-state {
+		PIN_IN(gpf0-0, DOWN, LV1);	/* NC */
+		PIN_IN(gpf0-2, DOWN, LV1);	/* NC */
+		PIN_IN(gpf0-3, DOWN, LV1);	/* NC */
+		PIN_IN(gpf0-4, DOWN, LV1);	/* NC */
+		PIN_IN(gpf0-5, DOWN, LV1);	/* NC */
+		PIN_IN(gpf0-6, DOWN, LV1);	/* NC */
+	};
+	sleep6: sleep-state {
+		PIN_SLP(gpf0-0, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpf0-1, OUT0, NONE);	/* BUCK6EN */
+		PIN_SLP(gpf0-2, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpf0-3, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpf0-4, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpf0-5, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpf0-6, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpf0-7, PREV, NONE);	/* LDO17_EN */
+	};
+};
+
+&pinctrl_7 {
+	pinctrl-names = "sleep";
+	pinctrl-0 = <&sleep7>;
+	sleep7: sleep-state {
+		PIN_SLP(gpj0-0, INPUT, NONE);	/* SENSOR2_I2C_SDA acc */
+		PIN_SLP(gpj0-1, INPUT, NONE);	/*  SENSOR2_I2C_SCL acc */
+		PIN_SLP(gpj0-2, INPUT, DOWN);	/* NC */
+	};
+};
+
+&pinctrl_8 {
+	pinctrl-names = "default","sleep";
+	pinctrl-0 = <&initial8>;
+	pinctrl-1 = <&sleep8>;
+	initial8: initial-state {
+		PIN_IN(gpd4-3, NONE, LV1);	/* ISDBT_FELICA_SDA */
+		PIN_IN(gpd4-4, NONE, LV1);	/* ISDBT_FELICA_SCL */
+
+		PIN_IN(gpd6-0, DOWN, LV1);	/* NC */
+		PIN_IN(gpd6-1, DOWN, LV1);	/* NC */
+
+		PIN_IN(gpd8-0, DOWN, LV1);	/* NC */
+		PIN_IN(gpd8-1, DOWN, LV1);	/* NC */
+
+		PIN_IN(gpg3-4, NONE, LV1);	/* HW_REV(0) */
+		PIN_IN(gpg3-5, NONE, LV1);	/* HW_REV(1) */
+		PIN_IN(gpg3-6, NONE, LV1);	/* HW_REV(2) */
+		PIN_IN(gpg3-7, NONE, LV1);	/* HW_REV(3) */
+
+		PIN_IN(gpv7-5, DOWN, LV1);	/* GND 10K PD */
+	};
+	sleep8: sleep-state {
+		PIN_SLP(gpv7-0, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpv7-1, INPUT, DOWN);	/* PCD_INT */
+		PIN_SLP(gpv7-2, PREV, NONE);	/* MLCD_RST */
+		PIN_SLP(gpv7-3, PREV, NONE);	/* CODEC_LDO_EN*/
+		PIN_SLP(gpv7-4, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpv7-5, INPUT, DOWN);	/* NC */
+
+		PIN_SLP(gpb0-0, INPUT, NONE);	/* SENSOR_SDA_1.8V */
+		PIN_SLP(gpb0-1, INPUT, NONE);	/* SENSOR_SCL_1.8V */
+		PIN_SLP(gpb0-2, INPUT, NONE);	/* TOUCH_SDA_1.8V */
+		PIN_SLP(gpb0-3, INPUT, NONE);	/* TOUCH_SCL_1.8V */
+		PIN_SLP(gpb0-4, INPUT, DOWN);	/* FG_ERR */
+
+		PIN_SLP(gpc0-0, INPUT, NONE);	/* MEM_SDA_1.8V */
+		PIN_SLP(gpc0-1, PREV, NONE);	/* FLASH_EN */
+		PIN_SLP(gpc0-2, INPUT, DOWN);	/* SIM_PWR_SEL */
+		PIN_SLP(gpc0-3, INPUT, DOWN);	/* VTCAM_RST_N */
+		PIN_SLP(gpc0-4, INPUT, DOWN);	/* CAM_RST */
+		PIN_SLP(gpc0-5, INPUT, DOWN);	/* CAM_LDO_EN */
+		PIN_SLP(gpc0-6, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpc0-7, INPUT, NONE);	/* MEM_SCL_1.8V */
+
+		PIN_SLP(gpc1-0, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpc1-1, INPUT, DOWN);	/* NC */
+
+		PIN_SLP(gpc2-0, INPUT, DOWN);	/* CAM_SDA_1.8V */
+		PIN_SLP(gpc2-1, INPUT, DOWN);	/* CAM_SCL_1.8V */
+		PIN_SLP(gpc2-2, INPUT, DOWN);	/* CAM_EEP_SDA_1.8V */
+		PIN_SLP(gpc2-3, INPUT, DOWN);	/* CAM_EEP_SDL_1.8V */
+		PIN_SLP(gpc2-4, INPUT, DOWN);	/* VTCAM_SDA_1.8V */
+		PIN_SLP(gpc2-5, INPUT, DOWN);	/* VTCAM_SCL_1.8V */
+
+		PIN_SLP(gpc3-0, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpc3-1, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpc3-2, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpc3-3, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpc3-4, INPUT, DOWN);	/* CP_SPI_CLK */
+		PIN_SLP(gpc3-5, OUT0, DOWN);	/* CP_SPI_CS_N */
+		PIN_SLP(gpc3-6, INPUT, DOWN);	/* CP_SPI_MISO */
+		PIN_SLP(gpc3-7, INPUT, DOWN);	/* CP_SPI_MOSI */
+
+		PIN_SLP(gpg0-0, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpg0-1, INPUT, DOWN);	/* NC */
+
+		PIN_SLP(gpd0-0, INPUT, UP);	/* GPS_UART_RXD */
+		PIN_SLP(gpd0-1, INPUT, UP);	/* GPS_UART_TXD */
+		PIN_SLP(gpd0-2, INPUT, DOWN);	/* GPS_UART_CTS */
+		PIN_SLP(gpd0-3, OUT1, NONE);	/* GPS_UART_RTS */
+
+		PIN_SLP(gpd1-4, INPUT, DOWN);	/* AP_UART_RXD */
+		PIN_SLP(gpd1-5, INPUT, DOWN);	/* AP_UART_TXD */
+
+		PIN_SLP(gpd2-0, INPUT, NONE);	/* AP_PMIC_SDA */
+		PIN_SLP(gpd2-1, INPUT, NONE);	/* AP_PMIC_SCL */
+		PIN_SLP(gpd2-2, INPUT, NONE);	/* IF_PMIC_SDA_1.8V */
+		PIN_SLP(gpd2-3, INPUT, NONE);	/* IF_PMIC_SDL_1.8V */
+		PIN_SLP(gpd2-4, OUT0, DOWN);	/* MOTOR_PWM */
+		PIN_SLP(gpd2-5, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpd2-6, INPUT, NONE);	/* CODEC_SDA_1.8V */
+		PIN_SLP(gpd2-7, INPUT, NONE);	/* CODEC_SDA_1.8V */
+
+		PIN_SLP(gpd4-0, PREV, NONE);	/* MOTOR_EN */
+		PIN_SLP(gpd4-1, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpd4-2, INPUT, DOWN);	/* IFC_SENSE_INT_AP */
+		PIN_SLP(gpd4-3, INPUT, NONE);	/* ISDBT_FELICA_SDA */
+		PIN_SLP(gpd4-4, INPUT, NONE);	/* ISDBT_FELICA_SCL */
+
+		PIN_SLP(gpd6-0, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpd6-1, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpd6-2, OUT0, DOWN);	/* ISDBT_SPI_CLK */
+		PIN_SLP(gpd6-3, OUT1, UP);	/* ISDBT_SPI_CS_N */
+		PIN_SLP(gpd6-4, OUT0, DOWN);	/* ISDBT_SPI_MISO */
+		PIN_SLP(gpd6-5, OUT0, DOWN);	/* ISDBT_SPI_MOSI */
+		PIN_SLP(gpd6-6, PREV, NONE);	/* BOOT_LDO */
+
+		PIN_SLP(gpd7-0, INPUT, DOWN);	/* CAM_MCLK */
+		PIN_SLP(gpd7-1, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpd7-2, INPUT, DOWN);	/* VTCAM_MCLK */
+
+		PIN_SLP(gpd8-0, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpd8-1, INPUT, DOWN);	/* NC */
+
+		PIN_SLP(gpg1-0, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpg1-1, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpg1-2, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpg1-3, INPUT, DOWN);	/* NC */
+		PIN_SLP(gpg1-4, PREV, DOWN);	/* BT_EN */
+
+		PIN_SLP(gpg2-0, PREV, NONE);	/* CP_PMIC_PWR_EN */
+		PIN_SLP(gpg2-1, PREV, NONE);	/* PDA_ACTIVE */
+
+		PIN_SLP(gpg3-0, INPUT, NONE);	/* CAM_EEP_SDA_1.8V */
+		PIN_SLP(gpg3-1, INPUT, NONE);	/* CAM_EEP_SCL_1.8V */
+		PIN_SLP(gpg3-2, INPUT, NONE);	/* SPK_AMP_SDA_1.8V */
+		PIN_SLP(gpg3-3, INPUT, NONE);	/* SPK_AMP_SDL_1.8V  */
+		PIN_SLP(gpg3-4, INPUT, NONE);	/* HW_REV0 */
+		PIN_SLP(gpg3-5, INPUT, NONE);	/* HW_REV1 */
+		PIN_SLP(gpg3-6, INPUT, NONE);	/* HW_REV2 */
+		PIN_SLP(gpg3-7, INPUT, NONE);	/* HW_REV3 */
+	};
+};
+
+&pinctrl_9 {
+	pinctrl-names = "sleep";
+	pinctrl-0 = <&sleep9>;
+	sleep9: sleep-state {
+		PIN_SLP(gpj1-0, INPUT, DOWN);	/* TSP_SDA_1.8V */
+		PIN_SLP(gpj1-1, INPUT, DOWN);	/* TSP_SCL_1.8V */
+		PIN_SLP(gpj1-2, INPUT, DOWN);	/* NC */
+	};
+};
+
diff -duprN mm/arch/arm/boot/dts/exynos5433-a8hplte_jpn_kdi_00.dts n/arch/arm/boot/dts/exynos5433-a8hplte_jpn_kdi_00.dts
--- mm/arch/arm/boot/dts/exynos5433-a8hplte_jpn_kdi_00.dts	1970-01-01 05:30:00.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5433-a8hplte_jpn_kdi_00.dts	2017-03-31 10:41:26.000000000 +0530
@@ -0,0 +1,381 @@
+/*
+ * SAMSUNG UNIVERSAL5433 board device tree source
+ *
+ * Copyright (c) 2013 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+/dts-v1/;
+#include "exynos5433-a8hplte_common.dtsi"
+#include "exynos5433-a8hplte_jpn_gpio_00.dtsi"
+#include "exynos5433-a8hplte_fingerprint-sensor_00.dtsi"
+#include "exynos5433-a8hplte-modem-ss333-ds.dtsi"
+#include "exynos5433-a8hplte_jpn_battery_00.dtsi"
+#include "exynos5433-a8hplte_jpn-secnfc-tuner-r00.dtsi"
+#include "exynos5433-a8hplte_jpn-isdbt-00.dtsi"
+
+/ {
+	model = "Samsung A8 VE LTE JPN EVT1 revision 00 board based on EXYNOS5433";
+	model_info-chip = <5433>;
+	model_info-platform = "a8hplte";
+	model_info-subtype = "a8hplte_jpn_kdi";
+	model_info-hw_rev = <0>;
+	model_info-hw_rev_end = <0>;
+	compatible = "samsung,A8 VE LTE EVT1 JPN,r00", "samsung,exynos5433";
+
+	det_zones: det_zones {
+		#list-det-cells = <4>;
+	};
+
+	but_zones: but_zones {
+		#list-but-cells = <3>;
+	};
+
+	earjack {
+		compatible = "sec_jack";
+		earjack-detect-gpio = <&gpa3 0 0>;
+		earjack-sendend-gpio = <&gpa1 3 0>;
+		earjack-ant-det-gpio = <&gpa0 0 0>;
+	/*	earjack-micbias-gpio = <&gpv7 3 0>; */
+		earjack-rfeardet-gpio = <&gpf4 5 0>;
+
+		det-zones-list = <&det_zones 0 10 10 0>,
+				 <&det_zones 2150 10 10 0>,
+				 <&det_zones 2151 10 10 1>,
+				 <&det_zones 9997 10 10 1>,
+				 <&det_zones 9998 10 10 2>,
+				 <&det_zones 9999 10 10 2>;
+		fac-det-zones-list = <&det_zones 0 10 10 0>,
+				 <&det_zones 2150 10 10 0>,
+				 <&det_zones 2151 10 10 1>,
+				 <&det_zones 9997 10 10 1>,
+				 <&det_zones 9998 10 10 2>,
+				 <&det_zones 9999 10 10 2>;
+		but-zones-list = <&but_zones 0 0 415>,
+				 <&but_zones 1 416 790>,
+				 <&but_zones 2 791 1500>;
+		pinctrl-names = "earjack_gpio_active","earjack_gpio_suspend";
+		pinctrl-0 = <&earjack_det_act &earjack_switch_act>;
+		pinctrl-1 = <&earjack_det_sus &earjack_switch_sus>;
+
+		io-channels = <&exynos_adc 2>;
+		io-channel-names = "adc-earjack";
+
+		use-codec-micbias;
+	};
+
+	pinctrl@10580000 {
+		/* 3.5 pi Earjack */
+		earjack_det_act: earjack_det_act {
+			samsung,pins = "gpa3-0";
+			samsung,pin-function = <0x0>;		/* IN */
+			samsung,pin-pud = <0>;			/* No PULL */
+			samsung,pin-drv = <0>;
+		};
+		earjack_det_sus: earjack_det_sus {
+			samsung,pins = "gpa3-0";
+			samsung,pin-function = <0>;		/* IN */
+			samsung,pin-pud = <0>;			/* No PULL */
+			samsung,pin-drv = <0>;
+		};
+	};
+
+	pinctrl@10580000 {
+		/* EAR_SEND_END */
+		earjack_switch_act: earjack_switch_act {
+			samsung,pins = "gpa1-3";
+			samsung,pin-function = <0x0>;		/* IN */
+			samsung,pin-pud = <0>;			/* No PULL */
+			samsung,pin-drv = <0>;
+		};
+		earjack_switch_sus: earjack_switch_sus {
+			samsung,pins = "gpa1-3";
+			samsung,pin-function = <0>;		/* IN */
+			samsung,pin-pud = <0>;			/* No PULL */
+			samsung,pin-drv = <0>;
+		};
+	};	
+
+	pinctrl@114B0000 {
+		uart_aud_rts: uart-aud-rts {
+			samsung,pins = "gpz1-3";
+			samsung,pin-function = <2>;
+			samsung,pin-pud = <0>;
+			samsung,pin-con-pdn = <1>;
+			samsung,pin-pud-pdn = <0>;
+		};
+
+		uart_aud_cts: uart-aud-cts {
+			samsung,pins = "gpz1-2";
+			samsung,pin-function = <2>;
+			samsung,pin-pud = <0>;
+			samsung,pin-con-pdn = <2>;
+			samsung,pin-pud-pdn = <0>;
+		};
+
+		uart_aud_rx: uart-aud-rx {
+			samsung,pins = "gpz1-1";
+			samsung,pin-function = <2>;
+			samsung,pin-pud = <0>;
+			samsung,pin-con-pdn = <2>;
+			samsung,pin-pud-pdn = <0>;
+		};
+
+		uart_aud_tx: uart-aud-tx {
+			samsung,pins = "gpz1-0";
+			samsung,pin-function = <2>;
+			samsung,pin-pud = <0>;
+			samsung,pin-con-pdn = <1>;
+			samsung,pin-pud-pdn = <0>;
+		};
+	};
+
+	serial@11460000 {
+		pinctrl-0 = <&uart_aud_rts &uart_aud_cts &uart_aud_rx &uart_aud_tx>;
+		pinctrl-1 = <&uart_aud_rx &uart_aud_tx &uart_aud_bus_idle>;
+	};
+
+	pinctrl@14CC0000 {
+		cfg_en: cfg-en {
+			samsung,pins ="gpg1-4";
+			samsung,pin-function = <1>;
+			samsung,pin-pud = <1>;
+			samsung,pin-con-pdn = <3>;
+			samsung,pin-pud-pdn = <1>;
+		};
+	};
+
+	pinctrl@10580000{
+		cfg_hostwake: cfg-hostwake {
+			samsung,pins = "gpa2-2";
+			samsung,pin-function = <0>;
+			samsung,pin-pud = <0>;
+		};
+
+		cfg_btwake: cfg-btwake {
+			samsung,pins = "gpa3-2";
+			samsung,pin-function = <1>;
+			samsung,pin-pud = <1>;
+		};
+	};
+	bluetooth {
+		compatible = "broadcom,bcm43455";
+
+		gpios = <&gpg1 4 1	/*BT_EN*/
+				&gpa3 2 1	/*BT_WAKE*/
+				&gpa2 2 0xF	/*BT_HOST_WAKE*/ >;
+
+		pinctrl-names = "default";
+		pinctrl-0=<&cfg_hostwake &cfg_btwake &cfg_en>;
+		status = "okay";
+	};
+
+	i2c@25 {
+		status = "disable";
+		muic-universal@25 {
+			status = "disable";
+		};
+	};
+
+	muic {
+		status = "okay";
+		muic,support-list = "MHL","OTG","Charging Cable","Jig USB On","Jig UART Off",
+				    "Jig UART Off + VB","Jig UART On",
+				    "TA","USB","CDP","Undefined Charging",
+				    "Unofficial ID","Unofficial ID + TA","Unofficial ID + ANY TA",
+				    "Unofficial ID + USB","Unofficial ID + CDP",
+				    "Deskdock","Deskdock + VB",
+				    "Fuelgauge test","HMT";
+		muic,afcmode-tx = /bits/ 8 <0x46>;
+		muic,qc-hv = /bits/ 8 <0x9>;
+	};
+
+	chosen {
+		bootargs = "console=ttySAC2,115200 vmalloc=256M";
+	};
+
+	/* UART Pin configs */
+	pinctrl@14CC0000 {
+		uart2_bus: uart2-bus {
+			samsung,pins = "gpd1-4", "gpd1-5";
+			samsung,pin-function = <2>;
+			samsung,pin-pud = <0>;
+		};
+	};
+
+	pinctrl@14CD0000 {
+		sensor2_i2c: sensor2_i2c {
+			samsung,pins = "gpj0-1", "gpj0-0";
+			samsung,pin-function = <4>;
+			samsung,pin-pud = <0>;
+			samsung,pin-drv = <0>;
+		};
+	};
+
+	pinctrl@14CC0000 {
+		sensor_i2c: sensor_i2c {
+			samsung,pins = "gpb0-1", "gpb0-0";
+			samsung,pin-function = <4>;
+			samsung,pin-pud = <0>;
+			samsung,pin-drv = <0>;
+		};
+	};
+
+	pinctrl@10580000 {
+		prox_irq: prox_irq {
+			samsung,pins = "gpa3-3";
+			samsung,pin-function = <0>;
+			samsung,pin-pud = <0>;
+			samsung,pin-drv = <0>;
+		};
+		acc_int: acc_int {
+			samsung,pins = "gpa3-4";
+			samsung,pin-function = <0>;
+			samsung,pin-pud = <1>;
+			samsung,pin-drv = <0>;
+		};
+	};
+
+	hsi2c@14D90000 {
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&sensor_i2c>;
+
+		tmd3782@39 {
+			compatible = "taos,tmd3782";
+			reg = <0x39>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&prox_irq>;
+			interrupts = <3 0 0>;
+			interrupt-parent = <&gpa3>;
+			taos,irq_gpio = <&gpa3 3 0>;
+			reg_vdd-supply = <&ldo35_reg>;
+			taos,prox_rawdata_trim = <170>;
+			taos,prox_thresh_hi = <480>;
+			taos,prox_thresh_low = <340>;
+			taos,als_time = <0xEB>;
+			taos,intr_filter = <0x33>;
+			taos,prox_pulsecnt = <0x06>;
+			taos,als_gain = <0x22>;
+			taos,coef_atime = <50>;
+			taos,ga = <97>;
+			taos,coef_a = <1000>;
+			taos,coef_b = <1880>;
+			taos,coef_c = <642>;
+			taos,coef_d = <1140>;
+		};
+	};
+
+	hsi2c@14EC0000 {
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&sensor2_i2c>;
+
+		bma_acc@10 {
+			compatible = "bma2x2";
+			reg = <0x10>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&acc_int>;
+			interrupts = <4 0 0>;
+			interrupt-parent = <&gpa3>;
+			bma2x2,gpio_int1 = <&gpa3 4 0x00>;
+			bma2x2,vio-supply = <&ldo39_reg>;
+			bma2x2,fs_range = <0x00>;
+			bma2x2,poll_interval = <100>;
+			bma2x2,min_interval = <2>;
+			bma2x2,supply_type = <1>;
+			bma2x2,accel_place = <0>;
+		};
+		bmm_mag@12 {
+			compatible = "bmm050";
+			reg = <0x12>;
+			status = "okay";
+			bmm050,vio-supply = <&ldo39_reg>;
+			bmm050,poll_interval = <100>;
+			bmm050,min_interval = <13>;
+			bmm050,fs_range = <0x60>;
+			bmm050,magnetic_place = <0>;
+		};
+	};
+
+	/* Motor */
+	haptic {
+		status = "okay";
+		compatible = "isa1000a-vibrator";
+		pinctrl-names = "default";
+		pinctrl-0 = <&motor_en &vibetonz_pwm>;
+		haptic,max_timeout = <10000>;
+		haptic,duty = <31900>; /* ratio = 83.7% */
+		haptic,period = <38110>; /* freq = 205 * 128 = 26240hz */
+		haptic,pwm_id = <0>;
+		haptic,en = <&gpd4 0 0>;
+	};
+
+	pinctrl@14CC0000 {
+		vibetonz_pwm: vibetonz-pwm {
+			samsung,pins = "gpd2-4";
+			samsung,pin-function = <2>;
+		      samsung,pin-pud = <0>;
+		      samsung,pin-drv = <0>;
+	      };
+		motor_en: motor_en {
+			samsung,pins = "gpd4-0";
+			samsung,pin-function = <1>;
+			samsung,pin-pud = <0>;
+			samsung,pin-drv = <0>;
+		};
+	};
+
+	hsi2c@14E40000 {
+		s2mps13_pmic@66 {
+			regulators {
+				ldo34_reg: LDO34 {
+					regulator-name = "VDD_NFC_1.8V";
+					regulator-min-microvolt = <1800000>;
+					regulator-max-microvolt = <1800000>;
+				};
+
+				ldo38_reg: LDO38 {
+					regulator-name = "VDD_MOTOR_3.0V";
+					regulator-min-microvolt = <3000000>;
+					regulator-max-microvolt = <3000000>;
+				};
+			};
+		};
+	};
+
+	/* Camera Flash */
+	fimc_is_sensor0: fimc_is_sensor@12100000 {
+		flash_id = <5>;
+	};
+
+	leds_ktd2692 {
+		compatible = "ktd2692";
+		flash_control = <&gpc0 1 0x1>;
+		status = "okay";
+		movie_current = <3>; /*level 4 in 16*/
+		pinctrl-names ="default","host","is";
+		pinctrl-0 = <&fimc_is_flash_is>;
+		pinctrl-1 = <&fimc_is_flash_host>;
+		pinctrl-2 = <&fimc_is_flash_is>;
+	};
+
+	pinctrl@14CC0000 {
+		fimc_is_flash_host: fimc-is-flash-host {
+			samsung,pins = "gpc0-1";
+			samsung,pin-function = <1>;
+			samsung,pin-pud = <1>;
+			samsung,pin-drv = <0>;
+		};
+
+		fimc_is_flash_is: fimc-is-flash-is {
+			samsung,pins = "gpc0-1";
+			samsung,pin-function = <2>;
+			samsung,pin-pud = <1>;
+			samsung,pin-drv = <0>;
+		};
+	};
+};
diff -duprN mm/arch/arm/boot/dts/exynos5433-a8hplte_jpn_kdi_01.dts n/arch/arm/boot/dts/exynos5433-a8hplte_jpn_kdi_01.dts
--- mm/arch/arm/boot/dts/exynos5433-a8hplte_jpn_kdi_01.dts	1970-01-01 05:30:00.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5433-a8hplte_jpn_kdi_01.dts	2017-03-31 10:41:26.000000000 +0530
@@ -0,0 +1,381 @@
+/*
+ * SAMSUNG UNIVERSAL5433 board device tree source
+ *
+ * Copyright (c) 2013 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+*/
+/dts-v1/;
+#include "exynos5433-a8hplte_common.dtsi"
+#include "exynos5433-a8hplte_jpn_gpio_00.dtsi"
+#include "exynos5433-a8hplte_fingerprint-sensor_00.dtsi"
+#include "exynos5433-a8hplte-modem-ss333-ds.dtsi"
+#include "exynos5433-a8hplte_jpn_battery_00.dtsi"
+#include "exynos5433-a8hplte_jpn-secnfc-tuner-r00.dtsi"
+#include "exynos5433-a8hplte_jpn-isdbt-00.dtsi"
+
+/ {
+	model = "Samsung A8 VE LTE JPN EVT1 revision 01 board based on EXYNOS5433";
+	model_info-chip = <5433>;
+	model_info-platform = "a8hplte";
+	model_info-subtype = "a8hplte_jpn_kdi";
+	model_info-hw_rev = <1>;
+	model_info-hw_rev_end = <255>;
+	compatible = "samsung,A8 VE LTE EVT1 JPN,r01", "samsung,exynos5433";
+
+	det_zones: det_zones {
+		#list-det-cells = <4>;
+	};
+
+	but_zones: but_zones {
+		#list-but-cells = <3>;
+	};
+
+	earjack {
+		compatible = "sec_jack";
+		earjack-detect-gpio = <&gpa3 0 0>;
+		earjack-sendend-gpio = <&gpa1 3 0>;
+		earjack-ant-det-gpio = <&gpa0 0 0>;
+	/*	earjack-micbias-gpio = <&gpv7 3 0>; */
+		earjack-rfeardet-gpio = <&gpf4 5 0>;
+
+		det-zones-list = <&det_zones 0 10 10 0>,
+				 <&det_zones 1584 10 10 0>,
+				 <&det_zones 1585 10 10 1>,
+				 <&det_zones 3662 10 10 1>,
+				 <&det_zones 3663 10 10 2>,
+				 <&det_zones 9999 10 10 2>;
+		fac-det-zones-list = <&det_zones 0 10 10 0>,
+				 <&det_zones 1584 10 10 0>,
+				 <&det_zones 1585 10 10 1>,
+				 <&det_zones 9997 10 10 1>,
+				 <&det_zones 9998 10 10 2>,
+				 <&det_zones 9999 10 10 2>;
+		but-zones-list = <&but_zones 0 0 565>,
+				 <&but_zones 1 566 780>,
+				 <&but_zones 2 781 1500>;
+		pinctrl-names = "earjack_gpio_active","earjack_gpio_suspend";
+		pinctrl-0 = <&earjack_det_act &earjack_switch_act>;
+		pinctrl-1 = <&earjack_det_sus &earjack_switch_sus>;
+
+		io-channels = <&exynos_adc 2>;
+		io-channel-names = "adc-earjack";
+
+		use-codec-micbias;
+	};
+
+	pinctrl@10580000 {
+		/* 3.5 pi Earjack */
+		earjack_det_act: earjack_det_act {
+			samsung,pins = "gpa3-0";
+			samsung,pin-function = <0x0>;		/* IN */
+			samsung,pin-pud = <0>;			/* No PULL */
+			samsung,pin-drv = <0>;
+		};
+		earjack_det_sus: earjack_det_sus {
+			samsung,pins = "gpa3-0";
+			samsung,pin-function = <0>;		/* IN */
+			samsung,pin-pud = <0>;			/* No PULL */
+			samsung,pin-drv = <0>;
+		};
+	};
+
+	pinctrl@10580000 {
+		/* EAR_SEND_END */
+		earjack_switch_act: earjack_switch_act {
+			samsung,pins = "gpa1-3";
+			samsung,pin-function = <0x0>;		/* IN */
+			samsung,pin-pud = <0>;			/* No PULL */
+			samsung,pin-drv = <0>;
+		};
+		earjack_switch_sus: earjack_switch_sus {
+			samsung,pins = "gpa1-3";
+			samsung,pin-function = <0>;		/* IN */
+			samsung,pin-pud = <0>;			/* No PULL */
+			samsung,pin-drv = <0>;
+		};
+	};	
+
+	pinctrl@114B0000 {
+		uart_aud_rts: uart-aud-rts {
+			samsung,pins = "gpz1-3";
+			samsung,pin-function = <2>;
+			samsung,pin-pud = <0>;
+			samsung,pin-con-pdn = <1>;
+			samsung,pin-pud-pdn = <0>;
+		};
+
+		uart_aud_cts: uart-aud-cts {
+			samsung,pins = "gpz1-2";
+			samsung,pin-function = <2>;
+			samsung,pin-pud = <0>;
+			samsung,pin-con-pdn = <2>;
+			samsung,pin-pud-pdn = <0>;
+		};
+
+		uart_aud_rx: uart-aud-rx {
+			samsung,pins = "gpz1-1";
+			samsung,pin-function = <2>;
+			samsung,pin-pud = <0>;
+			samsung,pin-con-pdn = <2>;
+			samsung,pin-pud-pdn = <0>;
+		};
+
+		uart_aud_tx: uart-aud-tx {
+			samsung,pins = "gpz1-0";
+			samsung,pin-function = <2>;
+			samsung,pin-pud = <0>;
+			samsung,pin-con-pdn = <1>;
+			samsung,pin-pud-pdn = <0>;
+		};
+	};
+
+	serial@11460000 {
+		pinctrl-0 = <&uart_aud_rts &uart_aud_cts &uart_aud_rx &uart_aud_tx>;
+		pinctrl-1 = <&uart_aud_rx &uart_aud_tx &uart_aud_bus_idle>;
+	};
+
+	pinctrl@14CC0000 {
+		cfg_en: cfg-en {
+			samsung,pins ="gpg1-4";
+			samsung,pin-function = <1>;
+			samsung,pin-pud = <1>;
+			samsung,pin-con-pdn = <3>;
+			samsung,pin-pud-pdn = <1>;
+		};
+	};
+
+	pinctrl@10580000{
+		cfg_hostwake: cfg-hostwake {
+			samsung,pins = "gpa2-2";
+			samsung,pin-function = <0>;
+			samsung,pin-pud = <0>;
+		};
+
+		cfg_btwake: cfg-btwake {
+			samsung,pins = "gpa3-2";
+			samsung,pin-function = <1>;
+			samsung,pin-pud = <1>;
+		};
+	};
+	bluetooth {
+		compatible = "broadcom,bcm43455";
+
+		gpios = <&gpg1 4 1	/*BT_EN*/
+				&gpa3 2 1	/*BT_WAKE*/
+				&gpa2 2 0xF	/*BT_HOST_WAKE*/ >;
+
+		pinctrl-names = "default";
+		pinctrl-0=<&cfg_hostwake &cfg_btwake &cfg_en>;
+		status = "okay";
+	};
+
+	i2c@25 {
+		status = "disable";
+		muic-universal@25 {
+			status = "disable";
+		};
+	};
+
+	muic {
+		status = "okay";
+		muic,support-list = "MHL","OTG","Charging Cable","Jig USB On","Jig UART Off",
+				    "Jig UART Off + VB","Jig UART On",
+				    "TA","USB","CDP","Undefined Charging",
+				    "Unofficial ID","Unofficial ID + TA","Unofficial ID + ANY TA",
+				    "Unofficial ID + USB","Unofficial ID + CDP",
+				    "Deskdock","Deskdock + VB",
+				    "Fuelgauge test","HMT";
+		muic,afcmode-tx = /bits/ 8 <0x46>;
+		muic,qc-hv = /bits/ 8 <0x9>;
+	};
+
+	/* UART Pin configs */
+	pinctrl@14CC0000 {
+		uart2_bus: uart2-bus {
+			samsung,pins = "gpd1-4", "gpd1-5";
+			samsung,pin-function = <2>;
+			samsung,pin-pud = <0>;
+		};
+	};
+
+	chosen {
+		bootargs = "console=ttySAC2,115200 vmalloc=256M";
+	};
+
+	pinctrl@14CD0000 {
+		sensor2_i2c: sensor2_i2c {
+			samsung,pins = "gpj0-1", "gpj0-0";
+			samsung,pin-function = <4>;
+			samsung,pin-pud = <0>;
+			samsung,pin-drv = <0>;
+		};
+	};
+
+	pinctrl@14CC0000 {
+		sensor_i2c: sensor_i2c {
+			samsung,pins = "gpb0-1", "gpb0-0";
+			samsung,pin-function = <4>;
+			samsung,pin-pud = <0>;
+			samsung,pin-drv = <0>;
+		};
+	};
+
+	pinctrl@10580000 {
+		prox_irq: prox_irq {
+			samsung,pins = "gpa3-3";
+			samsung,pin-function = <0>;
+			samsung,pin-pud = <0>;
+			samsung,pin-drv = <0>;
+		};
+		acc_int: acc_int {
+			samsung,pins = "gpa3-4";
+			samsung,pin-function = <0>;
+			samsung,pin-pud = <1>;
+			samsung,pin-drv = <0>;
+		};
+	};
+
+	hsi2c@14D90000 {
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&sensor_i2c>;
+
+		tmd3782@39 {
+			compatible = "taos,tmd3782";
+			reg = <0x39>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&prox_irq>;
+			interrupts = <3 0 0>;
+			interrupt-parent = <&gpa3>;
+			taos,irq_gpio = <&gpa3 3 0>;
+			reg_vdd-supply = <&ldo35_reg>;
+			taos,prox_rawdata_trim = <170>;
+			taos,prox_thresh_hi = <480>;
+			taos,prox_thresh_low = <340>;
+			taos,als_time = <0xEB>;
+			taos,intr_filter = <0x33>;
+			taos,prox_pulsecnt = <0x06>;
+			taos,als_gain = <0x22>;
+			taos,coef_atime = <50>;
+			taos,ga = <97>;
+			taos,coef_a = <1000>;
+			taos,coef_b = <1880>;
+			taos,coef_c = <642>;
+			taos,coef_d = <1140>;
+		};
+	};
+
+	hsi2c@14EC0000 {
+		status = "okay";
+		pinctrl-names = "default";
+		pinctrl-0 = <&sensor2_i2c>;
+
+		bma_acc@10 {
+			compatible = "bma2x2";
+			reg = <0x10>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&acc_int>;
+			interrupts = <4 0 0>;
+			interrupt-parent = <&gpa3>;
+			bma2x2,gpio_int1 = <&gpa3 4 0x00>;
+			bma2x2,vio-supply = <&ldo39_reg>;
+			bma2x2,fs_range = <0x00>;
+			bma2x2,poll_interval = <100>;
+			bma2x2,min_interval = <2>;
+			bma2x2,supply_type = <1>;
+			bma2x2,accel_place = <0>;
+		};
+		bmm_mag@12 {
+			compatible = "bmm050";
+			reg = <0x12>;
+			status = "okay";
+			bmm050,vio-supply = <&ldo39_reg>;
+			bmm050,poll_interval = <100>;
+			bmm050,min_interval = <13>;
+			bmm050,fs_range = <0x60>;
+			bmm050,magnetic_place = <0>;
+		};
+	};
+
+	/* Motor */
+	haptic {
+		status = "okay";
+		compatible = "isa1000a-vibrator";
+		pinctrl-names = "default";
+		pinctrl-0 = <&motor_en &vibetonz_pwm>;
+		haptic,max_timeout = <10000>;
+		haptic,duty = <31900>; /* ratio = 83.7% */
+		haptic,period = <38110>; /* freq = 205 * 128 = 26240hz */
+		haptic,pwm_id = <0>;
+		haptic,en = <&gpd4 0 0>;
+	};
+
+	pinctrl@14CC0000 {
+		vibetonz_pwm: vibetonz-pwm {
+			samsung,pins = "gpd2-4";
+			samsung,pin-function = <2>;
+		      samsung,pin-pud = <0>;
+		      samsung,pin-drv = <0>;
+	      };
+		motor_en: motor_en {
+			samsung,pins = "gpd4-0";
+			samsung,pin-function = <1>;
+			samsung,pin-pud = <0>;
+			samsung,pin-drv = <0>;
+		};
+	};
+
+	hsi2c@14E40000 {
+		s2mps13_pmic@66 {
+			regulators {
+				ldo34_reg: LDO34 {
+					regulator-name = "VDD_NFC_1.8V";
+					regulator-min-microvolt = <1800000>;
+					regulator-max-microvolt = <1800000>;
+				};
+
+				ldo38_reg: LDO38 {
+					regulator-name = "VDD_MOTOR_3.0V";
+					regulator-min-microvolt = <3000000>;
+					regulator-max-microvolt = <3000000>;
+				};
+			};
+		};
+	};
+
+	/* Camera Flash */
+	fimc_is_sensor0: fimc_is_sensor@12100000 {
+		flash_id = <5>;
+	};
+
+	leds_ktd2692 {
+		compatible = "ktd2692";
+		flash_control = <&gpc0 1 0x1>;
+		status = "okay";
+		movie_current = <3>; /*level 4 in 16*/
+		pinctrl-names ="default","host","is";
+		pinctrl-0 = <&fimc_is_flash_is>;
+		pinctrl-1 = <&fimc_is_flash_host>;
+		pinctrl-2 = <&fimc_is_flash_is>;
+	};
+
+	pinctrl@14CC0000 {
+		fimc_is_flash_host: fimc-is-flash-host {
+			samsung,pins = "gpc0-1";
+			samsung,pin-function = <1>;
+			samsung,pin-pud = <1>;
+			samsung,pin-drv = <0>;
+		};
+
+		fimc_is_flash_is: fimc-is-flash-is {
+			samsung,pins = "gpc0-1";
+			samsung,pin-function = <2>;
+			samsung,pin-pud = <1>;
+			samsung,pin-drv = <0>;
+		};
+	};
+};
diff -duprN mm/arch/arm/boot/dts/exynos5433-a8hplte_sea_open_00.dts n/arch/arm/boot/dts/exynos5433-a8hplte_sea_open_00.dts
--- mm/arch/arm/boot/dts/exynos5433-a8hplte_sea_open_00.dts	2016-09-20 17:29:28.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5433-a8hplte_sea_open_00.dts	2017-03-31 10:41:26.000000000 +0530
@@ -206,8 +206,6 @@
 
 	hsi2c@14E70000 {
 		status = "okay";
-		pinctrl-names = "default";
-		pinctrl-0 = <&sensor_i2c>;
 
 		tmd3782@39 {
 			compatible = "taos,tmd3782";
@@ -236,8 +234,6 @@
 
 	hsi2c@14EC0000 {
 		status = "okay";
-		pinctrl-names = "default";
-		pinctrl-0 = <&sensor2_i2c>;
 
 		bma_acc@10 {
 			compatible = "bma2x2";
diff -duprN mm/arch/arm/boot/dts/exynos5433-a8hplte_sea_open_01.dts n/arch/arm/boot/dts/exynos5433-a8hplte_sea_open_01.dts
--- mm/arch/arm/boot/dts/exynos5433-a8hplte_sea_open_01.dts	2016-09-20 17:29:28.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5433-a8hplte_sea_open_01.dts	2017-03-31 10:41:26.000000000 +0530
@@ -206,8 +206,6 @@
 
 	hsi2c@14E70000 {
 		status = "okay";
-		pinctrl-names = "default";
-		pinctrl-0 = <&sensor_i2c>;
 
 		tmd3782@39 {
 			compatible = "taos,tmd3782";
@@ -236,8 +234,6 @@
 
 	hsi2c@14EC0000 {
 		status = "okay";
-		pinctrl-names = "default";
-		pinctrl-0 = <&sensor2_i2c>;
 
 		bma_acc@10 {
 			compatible = "bma2x2";
diff -duprN mm/arch/arm/boot/dts/exynos5433-chagallhlte_battery.dtsi n/arch/arm/boot/dts/exynos5433-chagallhlte_battery.dtsi
--- mm/arch/arm/boot/dts/exynos5433-chagallhlte_battery.dtsi	2016-09-20 17:29:26.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5433-chagallhlte_battery.dtsi	2017-03-31 10:41:26.000000000 +0530
@@ -27,11 +27,11 @@
 
 			fuelgauge,fuel_alert_soc = <1>;
 			fuelgauge,capacity_max = <995>;
-			fuelgauge,capacity_max_margin = <50>;
+			fuelgauge,capacity_max_margin = <70>;
 			fuelgauge,capacity_min = <0>;
 			fuelgauge,capacity_calculation_type = <7>;
 			fuelgauge,type_str = "SDI";
-			fuelgauge,capacity = <0x3B88>;
+			fuelgauge,capacity = <0x3A98>;
 			fuelgauge,low_battery_comp_voltage = <3600>;
 			fuelgauge,low_battery_table = <(-5000) 0 0 (-1250) 0 3320 (-750) 97 3451 (-100) 96 3461 0 0 3456>;
 		};
@@ -68,8 +68,8 @@
 
 		battery,input_current_limit = <1800 0 0 1800 475 1000 1000 475 0 1800 650 0 1800 0 1000 400 700 1300 300 1000 1500 0 1667 1000 1667 80 1800 1667 1500 450>;
 		battery,fast_charging_current = <2200 0 0 2200 480 1000 1000 480 0 2200 720 0 2200 0 1000 400 700 1300 300 1000 1500 0 3150 1000 3150 80 1800 1000 1500 450>;
-		battery,full_check_current_1st = <250 0 0 250 250 250 250 250 0 0 250 0 250 0 250 250 250 250 250 250 250 0 250 250 250 0 250 250 250 250>;
-		battery,full_check_current_2nd = <2400 0 0 2400 2400 2400 2400 2400 0 0 2400 0 2400 0 2400 2400 2400 2400 2400 2400 2400 0 2400 2400 2400 2400 2400 2400 2400 2400>;
+		battery,full_check_current_1st = <400 0 0 400 400 400 400 400 0 0 400 0 400 0 400 400 400 400 400 400 400 0 400 400 400 400 400 400 400 400>;
+		battery,full_check_current_2nd = <250 0 0 250 250 250 250 250 0 0 250 0 250 0 250 250 250 250 250 250 250 0 250 250 250 250 250 250 250 250>;
 
 		battery,adc_check_count = <5>;
 
@@ -93,23 +93,23 @@
 		battery,temp_highlimit_threshold_event = <800>;
 		battery,temp_highlimit_recovery_event = <750>;
 		battery,temp_high_threshold_event = <550>;
-		battery,temp_high_recovery_event = <480>;
+		battery,temp_high_recovery_event = <500>;
 		battery,temp_low_threshold_event = <(-50)>;
 		battery,temp_low_recovery_event = <20>;
 		battery,temp_highlimit_threshold_normal = <800>;
 		battery,temp_highlimit_recovery_normal = <750>;
 		battery,temp_high_threshold_normal = <550>;
-		battery,temp_high_recovery_normal = <480>;
+		battery,temp_high_recovery_normal = <500>;
 		battery,temp_low_threshold_normal = <(-50)>;
 		battery,temp_low_recovery_normal = <20>;
 		battery,temp_highlimit_threshold_lpm = <800>;
 		battery,temp_highlimit_recovery_lpm = <750>;
 		battery,temp_high_threshold_lpm = <550>;
-		battery,temp_high_recovery_lpm = <480>;
+		battery,temp_high_recovery_lpm = <500>;
 		battery,temp_low_threshold_lpm = <(-50)>;
 		battery,temp_low_recovery_lpm = <20>;
 		battery,full_check_type = <7>; /* SEC_BATTERY_FULLCHARGED_CHGPSY */
-		battery,full_check_type_2nd = <3>; /* SEC_BATTERY_FULLCHARGED_TIME */
+		battery,full_check_type_2nd = <0>; /* SEC_BATTERY_FULLCHARGED_NONE */
 		battery,full_check_count = <1>;
 		battery,chg_gpio_full_check = <0>;
 		battery,chg_polarity_full_check = <1>;
@@ -118,7 +118,7 @@
 		   SEC_BATTERY_FULL_CONDITION_NOTIMEFULL |
 		   SEC_BATTERY_FULL_CONDITION_VCELL */
 		battery,full_condition_type = <13>;
-		battery,full_condition_soc = <97>;
+		battery,full_condition_soc = <93>;
 		battery,full_condition_vcell = <4300>;
 
 		battery,recharge_check_count = <2>;
@@ -131,6 +131,18 @@
 		battery,recharging_total_time = <5400>;
 		battery,charging_reset_time = <0>;
 
+		battery,chg_float_voltage = <4350>;
+		battery,swelling_high_temp_block = <450>;
+		battery,swelling_high_temp_recov = <400>;
+		battery,swelling_low_temp_block = <100>;
+		battery,swelling_low_temp_recov = <150>;
+		battery,swelling_chg_current = <0>;
+		battery,swelling_topoff_current = <400>;
+		battery,swelling_drop_float_voltage = <4200>;
+		battery,swelling_high_rechg_voltage = <4150>;
+		battery,swelling_low_rechg_voltage = <4050>;
+		/* battery,swelling_block_time = <600>; */
+
 		io-channels = <&exynos_adc 1>, <&exynos_adc 2>;
 		io-channel-names = "adc-temp", "inbat-adc-voltage";
 		#io-channel-cells = <2>;
diff -duprN mm/arch/arm/boot/dts/exynos5433-chagallhlte_kor_gpio_06.dtsi n/arch/arm/boot/dts/exynos5433-chagallhlte_kor_gpio_06.dtsi
--- mm/arch/arm/boot/dts/exynos5433-chagallhlte_kor_gpio_06.dtsi	2016-09-20 17:29:28.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5433-chagallhlte_kor_gpio_06.dtsi	2017-03-31 10:41:26.000000000 +0530
@@ -198,6 +198,7 @@
 	sleep7: sleep-state {
 		PIN_SLP(gpj0-0, INPUT, NONE);	/* SENSOR_I2C_SDA */
 		PIN_SLP(gpj0-1, INPUT, NONE);	/* SENSOR_I2C_SCL */
+		PIN_SLP(gpj0-2, INPUT, DOWN);	/* NC */
 	};
 };
 
diff -duprN mm/arch/arm/boot/dts/exynos5433-gts210_battery_02.dtsi n/arch/arm/boot/dts/exynos5433-gts210_battery_02.dtsi
--- mm/arch/arm/boot/dts/exynos5433-gts210_battery_02.dtsi	2016-09-20 17:29:29.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5433-gts210_battery_02.dtsi	2017-03-31 10:46:10.000000000 +0530
@@ -118,7 +118,7 @@
 
 		battery,adc_check_count = <5>;
 
-		battery,cable_check_type = <5>; /* SEC_BATTERY_CABLE_CHECK_NOUSBCHARGE | SEC_BATTERY_CABLE_CHECK_PSY */
+		battery,cable_check_type = <4>; /* SEC_BATTERY_CABLE_CHECK_NOUSBCHARGE | SEC_BATTERY_CABLE_CHECK_PSY */
 		battery,cable_source_type = <1>; /* SEC_BATTERY_CABLE_SOURCE_EXTERNAL */
 		battery,event_waiting_time = <600>;
 		battery,polling_type = <1>; /* SEC_BATTERY_MONITOR_ALARM */
diff -duprN mm/arch/arm/boot/dts/exynos5433-gts210wifi_battery.dtsi n/arch/arm/boot/dts/exynos5433-gts210wifi_battery.dtsi
--- mm/arch/arm/boot/dts/exynos5433-gts210wifi_battery.dtsi	2016-09-20 17:29:29.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5433-gts210wifi_battery.dtsi	2017-03-31 10:46:10.000000000 +0530
@@ -116,7 +116,7 @@
 
 		battery,adc_check_count = <5>;
 
-		battery,cable_check_type = <5>; /* SEC_BATTERY_CABLE_CHECK_NOUSBCHARGE | SEC_BATTERY_CABLE_CHECK_PSY */
+		battery,cable_check_type = <4>; /* SEC_BATTERY_CABLE_CHECK_NOUSBCHARGE | SEC_BATTERY_CABLE_CHECK_PSY */
 		battery,cable_source_type = <1>; /* SEC_BATTERY_CABLE_SOURCE_EXTERNAL */
 		battery,event_waiting_time = <600>;
 		battery,polling_type = <1>; /* SEC_BATTERY_MONITOR_ALARM */
@@ -200,36 +200,6 @@
 		battery,swelling_high_rechg_voltage = <4150>;
 		battery,swelling_low_rechg_voltage = <4050>;
 		battery,swelling_block_time = <600>;
-
-		/***********************************************************/
-		/* VE_SW for Battery Self Discharging(to prevent swelling) */
-		/* Enable TYPE : sdchg_ic, sdchg_ap, sdchg_cs, sdchg_ldo, ... */
-		/* The following line, "sdchg_type", is annotaed to support the dualization for Zero and GTS2 project.
-		     In case of other projects, "sdchg_type" should be designated to decide the way of self-discharging.
-		     In general cases, the default type is "sdchg_ic",which means self-discharging IC on PCB,
-		     unless "sdchg_type" is not designated.*/
-		/*
-		sdchg_type = "sdchg_ap";
-		*/
-		sdchg_ap {
-			compatible = "samsung,sdchg_ap";
-			sdchg,temperature_start = <600>;
-			sdchg,temperature_end = <550>;
-			sdchg,soc_start = <96>;
-			sdchg,soc_end = <92>;
-			sdchg,voltage_start = <4250>;	/* 4250 - 0(Volt. Comp. factor) = 4250 */
-			/* sdchg,voltage_end = <4200>;	-> from  battery,swelling_drop_float_voltage */
-		};
-		sdchg_cs {
-			compatible = "samsung,sdchg_cs";
-			sdchg,temperature_start = <600>;
-			sdchg,temperature_end = <550>;
-			sdchg,soc_start = <96>;
-			sdchg,soc_end = <92>;
-			sdchg,voltage_start = <4250>;	/* 4250 - 0(Volt. Comp. factor) = 4250 */
-			/* sdchg,voltage_end = <4200>;	-> from battery,swelling_drop_float_voltage */
-		};
-		/***********************************************************/
 	};
 
 	hsi2c@14D90000 {
diff -duprN mm/arch/arm/boot/dts/exynos5433-gts28_battery_03.dtsi n/arch/arm/boot/dts/exynos5433-gts28_battery_03.dtsi
--- mm/arch/arm/boot/dts/exynos5433-gts28_battery_03.dtsi	2016-09-20 17:29:29.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5433-gts28_battery_03.dtsi	2017-03-31 10:46:10.000000000 +0530
@@ -94,12 +94,14 @@
 
 		battery,polling_time = <10 30 30 30 3600>;
 
-		battery,temp_table_adc = <92 106 110 113 117 121 124 128 133 138 141 145
+		battery,temp_table_adc = <58 60 62 63 64 66 68 70 73 75 77 79 82
+						85 87 89 92 106 110 113 117 121 124 128 133 138 141 145
 						152 159 162 166 170 177 183 189 195 200 204 208
 						213 219 228 276 326 386 456 541 645 765 779 810 865 866 907
 						928 961 998 1034 1068 1103 1134 1158 1210 1259 1472>;
 
-		battery,temp_table_data = <690 640 630 620 610 600 590 580 570 560 550 540
+		battery,temp_table_data = <850 840 830 820 810 800 790 780 770 760 750 740 730 
+						720 710 700 690 640 630 620 610 600 590 580 570 560 550 540
 						530 520 510 500 490 480 470 460 450 440 430 420
 						410 400 390 340 290 240 190 150 100 50 40 30 20 10 0
 						(-10) (-20) (-30) (-40) (-50) (-60) (-70) (-80) (-90) (-100) (-150)>;
@@ -117,7 +119,7 @@
 
 		battery,adc_check_count = <5>;
 
-		battery,cable_check_type = <5>; /* SEC_BATTERY_CABLE_CHECK_NOUSBCHARGE | SEC_BATTERY_CABLE_CHECK_PSY */
+		battery,cable_check_type = <4>; /* SEC_BATTERY_CABLE_CHECK_NOUSBCHARGE | SEC_BATTERY_CABLE_CHECK_PSY */
 		battery,cable_source_type = <1>; /* SEC_BATTERY_CABLE_SOURCE_EXTERNAL */
 		battery,event_waiting_time = <600>;
 		battery,polling_type = <1>; /* SEC_BATTERY_MONITOR_ALARM */
@@ -168,7 +170,7 @@
 		battery,recharge_check_count = <1>;
 		battery,recharge_condition_type = <4>; /* SEC_BATTERY_RECHARGE_CONDITION_VCELL */
 		battery,recharge_condition_soc = <98>;
-		battery,recharge_condition_vcell = <4350>;
+		battery,recharge_condition_vcell = <4340>;
 
 		battery,charging_total_time = <21600>;
 		battery,recharging_total_time = <5400>;
@@ -181,7 +183,7 @@
 		#io-channel-cells = <1>;
 		io-channel-ranges;
 
-		battery,chg_float_voltage = <4400>;
+		battery,chg_float_voltage = <4390>;
 
 		battery,self_discharging_en;
 		battery,force_discharging_limit = <650>;
@@ -225,7 +227,7 @@
 		battery,chg_polarity_en = <0>;
 		battery,chg_gpio_status = <0>;
 		battery,chg_polarity_status = <0>;
-		battery,chg_float_voltage = <4400>;
+		battery,chg_float_voltage = <4390>;
 		chg_autostop = <1>;
 		chg_autoset = <1>;
 		chg_aiclen = <1>;
diff -duprN mm/arch/arm/boot/dts/exynos5433-gts28_battery_04.dtsi n/arch/arm/boot/dts/exynos5433-gts28_battery_04.dtsi
--- mm/arch/arm/boot/dts/exynos5433-gts28_battery_04.dtsi	2016-09-20 17:29:29.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5433-gts28_battery_04.dtsi	2017-03-31 10:46:10.000000000 +0530
@@ -94,12 +94,14 @@
 
 		battery,polling_time = <10 30 30 30 3600>;
 
-		battery,temp_table_adc = <92 106 110 113 117 121 124 128 133 138 141 145
+		battery,temp_table_adc = <58 60 62 63 64 66 68 70 73 75 77 79 82
+						85 87 89 92 106 110 113 117 121 124 128 133 138 141 145
 						152 159 162 166 170 177 183 189 195 200 204 208
 						213 219 228 276 326 386 456 541 645 765 779 810 865 866 907
 						928 961 998 1034 1068 1103 1134 1158 1210 1259 1472>;
 
-		battery,temp_table_data = <690 640 630 620 610 600 590 580 570 560 550 540
+		battery,temp_table_data = <850 840 830 820 810 800 790 780 770 760 750 740 730 
+						720 710 700 690 640 630 620 610 600 590 580 570 560 550 540
 						530 520 510 500 490 480 470 460 450 440 430 420
 						410 400 390 340 290 240 190 150 100 50 40 30 20 10 0
 						(-10) (-20) (-30) (-40) (-50) (-60) (-70) (-80) (-90) (-100) (-150)>;
@@ -117,7 +119,7 @@
 
 		battery,adc_check_count = <5>;
 
-		battery,cable_check_type = <5>; /* SEC_BATTERY_CABLE_CHECK_NOUSBCHARGE | SEC_BATTERY_CABLE_CHECK_PSY */
+		battery,cable_check_type = <4>; /* SEC_BATTERY_CABLE_CHECK_NOUSBCHARGE | SEC_BATTERY_CABLE_CHECK_PSY */
 		battery,cable_source_type = <1>; /* SEC_BATTERY_CABLE_SOURCE_EXTERNAL */
 		battery,event_waiting_time = <600>;
 		battery,polling_type = <1>; /* SEC_BATTERY_MONITOR_ALARM */
@@ -168,7 +170,7 @@
 		battery,recharge_check_count = <1>;
 		battery,recharge_condition_type = <4>; /* SEC_BATTERY_RECHARGE_CONDITION_VCELL */
 		battery,recharge_condition_soc = <98>;
-		battery,recharge_condition_vcell = <4350>;
+		battery,recharge_condition_vcell = <4340>;
 
 		battery,charging_total_time = <21600>;
 		battery,recharging_total_time = <5400>;
@@ -181,7 +183,7 @@
 		#io-channel-cells = <1>;
 		io-channel-ranges;
 
-		battery,chg_float_voltage = <4400>;
+		battery,chg_float_voltage = <4390>;
 
 		battery,self_discharging_en;
 		battery,force_discharging_limit = <650>;
@@ -225,7 +227,7 @@
 		battery,chg_polarity_en = <0>;
 		battery,chg_gpio_status = <0>;
 		battery,chg_polarity_status = <0>;
-		battery,chg_float_voltage = <4400>;
+		battery,chg_float_voltage = <4390>;
 		chg_autostop = <1>;
 		chg_autoset = <1>;
 		chg_aiclen = <1>;
diff -duprN mm/arch/arm/boot/dts/exynos5433-gts28_eur_open_03.dts n/arch/arm/boot/dts/exynos5433-gts28_eur_open_03.dts
--- mm/arch/arm/boot/dts/exynos5433-gts28_eur_open_03.dts	2016-09-20 17:29:27.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5433-gts28_eur_open_03.dts	2017-03-31 10:41:27.000000000 +0530
@@ -64,7 +64,7 @@
 			wlf,micd-force-micbias;
 			wlf,hpdet-moisture-imp = <2000>;
 			wlf,hpdet-channel = <1>;
-			wlf,hpdet-ext-res = <59>;
+			wlf,hpdet-ext-res = <11>;
 			wlf,hpdet-short-circuit-imp = <3>;
 			wlf,micd-ranges = <
 				116 226
diff -duprN mm/arch/arm/boot/dts/exynos5433-gts28_eur_open_04.dts n/arch/arm/boot/dts/exynos5433-gts28_eur_open_04.dts
--- mm/arch/arm/boot/dts/exynos5433-gts28_eur_open_04.dts	2016-09-20 17:29:27.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5433-gts28_eur_open_04.dts	2017-03-31 10:41:27.000000000 +0530
@@ -64,7 +64,7 @@
 			wlf,micd-force-micbias;
 			wlf,hpdet-moisture-imp = <2000>;
 			wlf,hpdet-channel = <1>;
-			wlf,hpdet-ext-res = <59>;
+			wlf,hpdet-ext-res = <11>;
 			wlf,hpdet-short-circuit-imp = <3>;
 			wlf,micd-ranges = <
 				116 226
diff -duprN mm/arch/arm/boot/dts/exynos5433-gts28_eur_open_05.dts n/arch/arm/boot/dts/exynos5433-gts28_eur_open_05.dts
--- mm/arch/arm/boot/dts/exynos5433-gts28_eur_open_05.dts	2016-09-20 17:29:27.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5433-gts28_eur_open_05.dts	2017-03-31 10:41:27.000000000 +0530
@@ -65,7 +65,7 @@
 			wlf,hpdet-moisture-imp = <2000>;
 			wlf,moisture-det-channel = <1>;
 			wlf,hpdet-channel = <0>;
-			wlf,hpdet-ext-res = <59>;
+			wlf,hpdet-ext-res = <11>;
 			wlf,hpdet-short-circuit-imp = <3>;
 			wlf,micd-ranges = <
 				116 226
diff -duprN mm/arch/arm/boot/dts/exynos5433-gts28_eur_open_06.dts n/arch/arm/boot/dts/exynos5433-gts28_eur_open_06.dts
--- mm/arch/arm/boot/dts/exynos5433-gts28_eur_open_06.dts	2016-09-20 17:29:27.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5433-gts28_eur_open_06.dts	2017-03-31 10:41:27.000000000 +0530
@@ -65,7 +65,7 @@
 			wlf,hpdet-moisture-imp = <2000>;
 			wlf,moisture-det-channel = <1>;
 			wlf,hpdet-channel = <0>;
-			wlf,hpdet-ext-res = <59>;
+			wlf,hpdet-ext-res = <11>;
 			wlf,hpdet-short-circuit-imp = <3>;
 			wlf,micd-ranges = <
 				116 226
diff -duprN mm/arch/arm/boot/dts/exynos5433-gts28_eur_open_09.dts n/arch/arm/boot/dts/exynos5433-gts28_eur_open_09.dts
--- mm/arch/arm/boot/dts/exynos5433-gts28_eur_open_09.dts	2016-09-20 17:29:29.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5433-gts28_eur_open_09.dts	2017-03-31 10:41:27.000000000 +0530
@@ -69,7 +69,7 @@
 			wlf,hpdet-moisture-imp = <2000>;
 			wlf,moisture-det-channel = <1>;
 			wlf,hpdet-channel = <0>;
-			wlf,hpdet-ext-res = <59>;
+			wlf,hpdet-ext-res = <11>;
 			wlf,hpdet-short-circuit-imp = <3>;
 			wlf,hs-mic = <3>;
 			wlf,micd-ranges = <
diff -duprN mm/arch/arm/boot/dts/exynos5433-gts28_ww_open_05.dts n/arch/arm/boot/dts/exynos5433-gts28_ww_open_05.dts
--- mm/arch/arm/boot/dts/exynos5433-gts28_ww_open_05.dts	2016-09-20 17:29:27.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5433-gts28_ww_open_05.dts	2017-03-31 10:41:27.000000000 +0530
@@ -65,7 +65,7 @@
 			wlf,hpdet-moisture-imp = <2000>;
 			wlf,moisture-det-channel = <1>;
 			wlf,hpdet-channel = <0>;
-			wlf,hpdet-ext-res = <59>;
+			wlf,hpdet-ext-res = <11>;
 			wlf,hpdet-short-circuit-imp = <3>;
 			wlf,micd-ranges = <
 				116 226
diff -duprN mm/arch/arm/boot/dts/exynos5433-gts28_ww_open_06.dts n/arch/arm/boot/dts/exynos5433-gts28_ww_open_06.dts
--- mm/arch/arm/boot/dts/exynos5433-gts28_ww_open_06.dts	2016-09-20 17:29:27.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5433-gts28_ww_open_06.dts	2017-03-31 10:41:27.000000000 +0530
@@ -65,7 +65,7 @@
 			wlf,hpdet-moisture-imp = <2000>;
 			wlf,moisture-det-channel = <1>;
 			wlf,hpdet-channel = <0>;
-			wlf,hpdet-ext-res = <59>;
+			wlf,hpdet-ext-res = <11>;
 			wlf,hpdet-short-circuit-imp = <3>;
 			wlf,micd-ranges = <
 				116 226
diff -duprN mm/arch/arm/boot/dts/exynos5433-gts28_ww_open_09.dts n/arch/arm/boot/dts/exynos5433-gts28_ww_open_09.dts
--- mm/arch/arm/boot/dts/exynos5433-gts28_ww_open_09.dts	2016-09-20 17:29:27.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5433-gts28_ww_open_09.dts	2017-03-31 10:41:27.000000000 +0530
@@ -33,6 +33,10 @@
 		};
 	};
 
+	sound {
+		mixer-paths = "mixer_paths_rev09.xml";
+	};
+
 	hsi2c@14E70000 {
 		status = "okay";
 		pinctrl-names = "default";
@@ -65,8 +69,9 @@
 			wlf,hpdet-moisture-imp = <2000>;
 			wlf,moisture-det-channel = <1>;
 			wlf,hpdet-channel = <0>;
-			wlf,hpdet-ext-res = <59>;
+			wlf,hpdet-ext-res = <11>;
 			wlf,hpdet-short-circuit-imp = <3>;
+			wlf,hs-mic = <3>;
 			wlf,micd-ranges = <
 				116 226
 				173 582
@@ -101,7 +106,7 @@
 			/* 0:MICVDD 1:MICBIAS1 2:MICBIAS2 3:MICBIAS3 */
 			wlf,dmic-ref = <2 1 3 0>;
 			/* 1st cell:IN1 2rd cell:IN2 3nd cell:IN3 4th cell:IN4 */
-			wlf,inmode = <0 1 0 0>;
+			wlf,inmode = <0 0 0 0>;
 			/* 1st cell:OUT1 2nd cell:OUT2 3rd cell:OUT3... 6th cell:OUT6 */
 			wlf,out-mono = <0 1 1 0 0 0>;
 
diff -duprN mm/arch/arm/boot/dts/exynos5433-gts28wifi_battery.dtsi n/arch/arm/boot/dts/exynos5433-gts28wifi_battery.dtsi
--- mm/arch/arm/boot/dts/exynos5433-gts28wifi_battery.dtsi	2016-09-20 17:29:29.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5433-gts28wifi_battery.dtsi	2017-03-31 10:46:10.000000000 +0530
@@ -94,12 +94,14 @@
 
 		battery,polling_time = <10 30 30 30 3600>;
 
-		battery,temp_table_adc = <92 106 110 113 117 121 124 128 133 138 141 145
+		battery,temp_table_adc = <58 60 62 63 64 66 68 70 73 75 77 79 82
+						85 87 89 92 106 110 113 117 121 124 128 133 138 141 145
 						152 159 162 166 170 177 183 189 195 200 204 208
 						213 219 228 276 326 386 456 541 645 765 779 810 865 866 907
 						928 961 998 1034 1068 1103 1134 1158 1210 1259 1472>;
 
-		battery,temp_table_data = <690 640 630 620 610 600 590 580 570 560 550 540
+		battery,temp_table_data = <850 840 830 820 810 800 790 780 770 760 750 740 730 
+						720 710 700 690 640 630 620 610 600 590 580 570 560 550 540
 						530 520 510 500 490 480 470 460 450 440 430 420
 						410 400 390 340 290 240 190 150 100 50 40 30 20 10 0
 						(-10) (-20) (-30) (-40) (-50) (-60) (-70) (-80) (-90) (-100) (-150)>;
@@ -117,7 +119,7 @@
 
 		battery,adc_check_count = <5>;
 
-		battery,cable_check_type = <5>; /* SEC_BATTERY_CABLE_CHECK_NOUSBCHARGE | SEC_BATTERY_CABLE_CHECK_PSY */
+		battery,cable_check_type = <4>; /* SEC_BATTERY_CABLE_CHECK_NOUSBCHARGE | SEC_BATTERY_CABLE_CHECK_PSY */
 		battery,cable_source_type = <1>; /* SEC_BATTERY_CABLE_SOURCE_EXTERNAL */
 		battery,event_waiting_time = <600>;
 		battery,polling_type = <1>; /* SEC_BATTERY_MONITOR_ALARM */
@@ -168,7 +170,7 @@
 		battery,recharge_check_count = <1>;
 		battery,recharge_condition_type = <4>; /* SEC_BATTERY_RECHARGE_CONDITION_VCELL */
 		battery,recharge_condition_soc = <98>;
-		battery,recharge_condition_vcell = <4350>;
+		battery,recharge_condition_vcell = <4340>;
 
 		battery,charging_total_time = <21600>;
 		battery,recharging_total_time = <5400>;
@@ -181,7 +183,7 @@
 		#io-channel-cells = <1>;
 		io-channel-ranges;
 
-		battery,chg_float_voltage = <4400>;
+		battery,chg_float_voltage = <4390>;
 
 		battery,self_discharging_en;
 		battery,force_discharging_limit = <650>;
@@ -201,36 +203,6 @@
 		battery,swelling_high_rechg_voltage = <4150>;
 		battery,swelling_low_rechg_voltage = <4050>;
 		battery,swelling_block_time = <600>;
-
-		/***********************************************************/
-		/* VE_SW for Battery Self Discharging(to prevent swelling) */
-		/* Enable TYPE : sdchg_ic, sdchg_ap, sdchg_cs, sdchg_ldo, ... */
-		/* The following line, "sdchg_type", is annotaed to support the dualization for Zero and GTS2 project.
-		     In case of other projects, "sdchg_type" should be designated to decide the way of self-discharging.
-		     In general cases, the default type is "sdchg_ic",which means self-discharging IC on PCB,
-		     unless "sdchg_type" is not designated.*/
-		/*
-		sdchg_type = "sdchg_ap";
-		*/
-		sdchg_ap {
-			compatible = "samsung,sdchg_ap";
-			sdchg,temperature_start = <600>;
-			sdchg,temperature_end = <550>;
-			sdchg,soc_start = <96>;
-			sdchg,soc_end = <92>;
-			sdchg,voltage_start = <4250>;	/* 4250 - 0(Volt. Comp. factor) = 4250 */
-			/* sdchg,voltage_end = <4200>;	-> from  battery,swelling_drop_float_voltage */
-		};
-		sdchg_cs {
-			compatible = "samsung,sdchg_cs";
-			sdchg,temperature_start = <600>;
-			sdchg,temperature_end = <550>;
-			sdchg,soc_start = <96>;
-			sdchg,soc_end = <92>;
-			sdchg,voltage_start = <4250>;	/* 4250 - 0(Volt. Comp. factor) = 4250 */
-			/* sdchg,voltage_end = <4200>;	-> from battery,swelling_drop_float_voltage */
-		};
-		/***********************************************************/
 	};
 
 	hsi2c@14D90000 {
@@ -255,7 +227,7 @@
 		battery,chg_polarity_en = <0>;
 		battery,chg_gpio_status = <0>;
 		battery,chg_polarity_status = <0>;
-		battery,chg_float_voltage = <4400>;
+		battery,chg_float_voltage = <4390>;
 		chg_autostop = <1>;
 		chg_autoset = <1>;
 		chg_aiclen = <1>;
diff -duprN mm/arch/arm/boot/dts/exynos5433-gts28wifi_eur_open_05.dts n/arch/arm/boot/dts/exynos5433-gts28wifi_eur_open_05.dts
--- mm/arch/arm/boot/dts/exynos5433-gts28wifi_eur_open_05.dts	2016-09-20 17:29:27.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5433-gts28wifi_eur_open_05.dts	2017-03-31 10:41:27.000000000 +0530
@@ -71,7 +71,7 @@
 			wlf,hpdet-moisture-imp = <2000>;
 			wlf,moisture-det-channel = <1>;
 			wlf,hpdet-channel = <0>;
-			wlf,hpdet-ext-res = <59>;
+			wlf,hpdet-ext-res = <11>;
 			wlf,hpdet-short-circuit-imp = <3>;
 			wlf,micd-ranges = <
 				116 226
diff -duprN mm/arch/arm/boot/dts/exynos5433-gts28wifi_eur_open_06.dts n/arch/arm/boot/dts/exynos5433-gts28wifi_eur_open_06.dts
--- mm/arch/arm/boot/dts/exynos5433-gts28wifi_eur_open_06.dts	2016-09-20 17:29:27.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5433-gts28wifi_eur_open_06.dts	2017-03-31 10:41:27.000000000 +0530
@@ -70,7 +70,7 @@
 			wlf,hpdet-moisture-imp = <2000>;
 			wlf,moisture-det-channel = <1>;
 			wlf,hpdet-channel = <0>;
-			wlf,hpdet-ext-res = <59>;
+			wlf,hpdet-ext-res = <11>;
 			wlf,hpdet-short-circuit-imp = <3>;
 			wlf,micd-ranges = <
 				116 226
diff -duprN mm/arch/arm/boot/dts/exynos5433-gts28wifi_ww_open_05.dts n/arch/arm/boot/dts/exynos5433-gts28wifi_ww_open_05.dts
--- mm/arch/arm/boot/dts/exynos5433-gts28wifi_ww_open_05.dts	2016-09-20 17:29:27.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5433-gts28wifi_ww_open_05.dts	2017-03-31 10:41:27.000000000 +0530
@@ -71,7 +71,7 @@
 			wlf,hpdet-moisture-imp = <2000>;
 			wlf,moisture-det-channel = <1>;
 			wlf,hpdet-channel = <0>;
-			wlf,hpdet-ext-res = <59>;
+			wlf,hpdet-ext-res = <11>;
 			wlf,hpdet-short-circuit-imp = <3>;
 			wlf,micd-ranges = <
 				116 226
diff -duprN mm/arch/arm/boot/dts/exynos5433-gts28wifi_ww_open_06.dts n/arch/arm/boot/dts/exynos5433-gts28wifi_ww_open_06.dts
--- mm/arch/arm/boot/dts/exynos5433-gts28wifi_ww_open_06.dts	2016-09-20 17:29:27.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5433-gts28wifi_ww_open_06.dts	2017-03-31 10:41:27.000000000 +0530
@@ -70,7 +70,7 @@
 			wlf,hpdet-moisture-imp = <2000>;
 			wlf,moisture-det-channel = <1>;
 			wlf,hpdet-channel = <0>;
-			wlf,hpdet-ext-res = <59>;
+			wlf,hpdet-ext-res = <11>;
 			wlf,hpdet-short-circuit-imp = <3>;
 			wlf,micd-ranges = <
 				116 226
diff -duprN mm/arch/arm/boot/dts/exynos5433-gts2_common.dtsi n/arch/arm/boot/dts/exynos5433-gts2_common.dtsi
--- mm/arch/arm/boot/dts/exynos5433-gts2_common.dtsi	2016-09-20 17:29:29.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5433-gts2_common.dtsi	2017-03-31 10:41:27.000000000 +0530
@@ -124,6 +124,7 @@
 		bypass-smu;
 		supports-highspeed;
 		supports-sdr104-mode;
+		only_once_tune;
 		clock-gate;
 		enable-cclk-on-suspend;
 		fix-fmp-size-mismatch;
@@ -1527,16 +1528,6 @@
 			net_boost,table= <64 0 0 1300000 0 825000 400000 0 0 0>;
 		};
 		boot_device@3 {
-			net_boost,label="WIFI";
-			net_boost,node="wlan0";
-			net_boost,table_size = <4>;
-			/*		 <Throughput ARM_min ARM_max KFC_min KFC_max MIF INT Task Irq HMPBoost> */
-			net_boost,table= <60 1000000 0 800000 0 0 200000 0 0 0
-					  100 1200000 0 1000000 0 0 200000 0 0 1
-					  120 1500000 0 1000000 0 0 200000 0 0 1
-					  180 1900000 0 1300000 0 543000 267000 1 1 1>;
-		};
-		boot_device@4 {
 			net_boost,label="P2P";
 			net_boost,node="p2p-wlan0-0";
 			net_boost,table_size = <3>;
@@ -1545,7 +1536,7 @@
 					  50 1200000 0 1000000 0 0 200000 0 0 0
 					  90 1700000 0 1100000 0 543000 267000 0 0 1>;
 		};
-		boot_device@5 {
+		boot_device@4 {
 			net_boost,label="CLAT";
 			net_boost,node="clat clat4";
 			net_boost,table_size = <3>;
@@ -1554,6 +1545,32 @@
 					  130 1500000 0 0 0 825000 0 0 0 0
 					  150 1600000 0 0 0 825000 0 0 0 0>;
 		};
+		boot_device@5 {
+			net_boost,label="WIFI";
+			net_boost,node="wlan0";
+			net_boost,table_size = <4>;
+			net_boost,table= <50 0 0 0 0 0 0 0 0 0
+					  100 0 0 0 0 0 0 0 0 0
+					  180 0 0 0 0 0 0 1 1 1
+					  300 0 0 0 0 0 0 1 1 1>;
+		};
+		boot_device@6 {
+			net_boost,label="WIFI TX";
+			net_boost,node="wlan0";
+			net_boost,table_size = <3>;
+			net_boost,table= <60 1200000 0 1000000 0 0 0 0 0 0
+					  100 1500000 0 1200000 0 0 200000 0 0 1
+					  180 1800000 0 1300000 0 543000 267000 1 1 1>;
+		};
+		boot_device@7 {
+			net_boost,label="WIFI RX";
+			net_boost,node="wlan0";
+			net_boost,table_size = <4>;
+			net_boost,table= <60 1000000 0 800000 0 0 200000 0 0 0
+					  100 1200000 0 1000000 0 0 200000 0 0 1
+					  120 1500000 0 1000000 0 0 200000 0 0 1
+					  180 1900000 0 1300000 0 543000 267000 1 1 1>;
+		};
 	};
 
 	input_booster {
diff -duprN mm/arch/arm/boot/dts/exynos5433.dtsi n/arch/arm/boot/dts/exynos5433.dtsi
--- mm/arch/arm/boot/dts/exynos5433.dtsi	2016-09-20 17:29:28.000000000 +0530
+++ n/arch/arm/boot/dts/exynos5433.dtsi	2017-03-31 10:41:27.000000000 +0530
@@ -101,7 +101,14 @@
 
 	arm-pmu {
 			compatible = "arm,cortex-a15-pmu", "arm,cortex-a7-pmu";
-			interrupts = <0 17 4>, <0 18 4>;
+			interrupts = <0 52 4>,
+				     <0 53 4>,
+				     <0 54 4>,
+				     <0 55 4>,
+				     <0 32 4>,
+				     <0 33 4>,
+				     <0 34 4>,
+				     <0 35 4>;
 	};
 
 	coresight {
diff -duprN mm/arch/arm/configs/gts210wifi_02_defconfig n/arch/arm/configs/gts210wifi_02_defconfig
--- mm/arch/arm/configs/gts210wifi_02_defconfig	2016-05-16 17:19:38.000000000 +0530
+++ n/arch/arm/configs/gts210wifi_02_defconfig	2017-03-31 10:56:43.000000000 +0530
@@ -112,6 +112,7 @@ CONFIG_CGROUP_FREEZER=y
 CONFIG_CGROUP_CPUACCT=y
 CONFIG_RESOURCE_COUNTERS=y
 # CONFIG_MEMCG is not set
+# CONFIG_CGROUP_PERF is not set
 CONFIG_CGROUP_SCHED=y
 CONFIG_FAIR_GROUP_SCHED=y
 # CONFIG_CFS_BANDWIDTH is not set
@@ -166,7 +167,8 @@ CONFIG_PERF_USE_VMALLOC=y
 #
 # Kernel Performance Events And Counters
 #
-# CONFIG_PERF_EVENTS is not set
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
 CONFIG_VM_EVENT_COUNTERS=y
 # CONFIG_SLUB_DEBUG is not set
 # CONFIG_PTRACK_DEBUG is not set
@@ -193,6 +195,7 @@ CONFIG_GENERIC_IDLE_POLL_SETUP=y
 CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
 CONFIG_HAVE_CLK=y
 CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
 CONFIG_HAVE_ARCH_JUMP_LABEL=y
 CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
 CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
@@ -200,6 +203,10 @@ CONFIG_SECCOMP_FILTER=y
 CONFIG_HAVE_CONTEXT_TRACKING=y
 CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
 CONFIG_MODULES_USE_ELF_REL=y
+CONFIG_HAVE_ARCH_MMAP_RND_BITS=y
+CONFIG_ARCH_MMAP_RND_BITS_MIN=8
+CONFIG_ARCH_MMAP_RND_BITS_MAX=16
+CONFIG_ARCH_MMAP_RND_BITS=8
 CONFIG_CLONE_BACKWARDS=y
 CONFIG_OLD_SIGSUSPEND3=y
 CONFIG_OLD_SIGACTION=y
@@ -359,6 +366,11 @@ CONFIG_CAL_SYS_PWRDOWN=y
 CONFIG_SOC_EXYNOS5433_REV_0=y
 # CONFIG_SOC_EXYNOS5433_REV_1 is not set
 # CONFIG_24MHZ_XTALCLK_DRV_STRENGTH_X4 is not set
+
+#
+# Exynos5433 Type
+#
+# CONFIG_SOC_EXYNOS5433_L is not set
 CONFIG_EXYNOS5433_BTS=y
 # CONFIG_SOC_EXYNOS5440 is not set
 CONFIG_EXYNOS_CORESIGHT=y
@@ -387,15 +399,9 @@ CONFIG_TARGET_LOCALE_EUR=y
 # CONFIG_MACH_A7LTE is not set
 CONFIG_TIMA=y
 CONFIG_TIMA_LKMAUTH=y
-CONFIG_TIMA_RKP=y
-CONFIG_RKP_DBLMAP_PROT=y
-CONFIG_HYP_RKP=y
-CONFIG_TIMA_RKP_30=y
+# CONFIG_TIMA_RKP is not set
 CONFIG_KNOX_KAP=y
-CONFIG_TIMA_RKP_L1_TABLES=y
-# CONFIG_TIMA_RKP_L2_TABLES is not set
-# CONFIG_TIMA_RKP_DEBUG is not set
-CONFIG_TIMA_LKMAUTH_CODE_PROT=y
+# CONFIG_TIMA_LKMAUTH_CODE_PROT is not set
 # CONFIG_TIMA_TEST_INFRA is not set
 # CONFIG_MSM_HSIC_SYSMON is not set
 # CONFIG_SEC_SMART_MGR_RUNQUEUE_AVG is not set
@@ -440,7 +446,7 @@ CONFIG_KUSER_HELPERS=y
 CONFIG_ARM_L1_CACHE_SHIFT_6=y
 CONFIG_ARM_L1_CACHE_SHIFT=6
 CONFIG_ARM_DMA_MEM_BUFFERABLE=y
-CONFIG_STRICT_MEMORY_RWX=y
+# CONFIG_STRICT_MEMORY_RWX is not set
 CONFIG_ARM_NR_BANKS=16
 CONFIG_MULTI_IRQ_HANDLER=y
 # CONFIG_ARM_ERRATA_430973 is not set
@@ -534,6 +540,7 @@ CONFIG_AEABI=y
 CONFIG_HAVE_ARCH_PFN_VALID=y
 CONFIG_HIGHMEM=y
 # CONFIG_HIGHPTE is not set
+CONFIG_HW_PERF_EVENTS=y
 CONFIG_FLATMEM=y
 CONFIG_FLAT_NODE_MEM_MAP=y
 CONFIG_HAVE_MEMBLOCK=y
@@ -567,7 +574,7 @@ CONFIG_ACCURATE_FREE_PAGES_CHECK=y
 CONFIG_OOM_SCAN_WA_PREVENT_WRONG_SEARCH=y
 CONFIG_SDP_CACHE_CLEANUP=y
 CONFIG_MIN_DIRTY_THRESH_PAGES=7680
-CONFIG_MMAP_READAROUND_LIMIT=0
+CONFIG_MMAP_READAROUND_LIMIT=16
 CONFIG_FORCE_MAX_ZONEORDER=11
 CONFIG_ALIGNMENT_TRAP=y
 # CONFIG_UACCESS_WITH_MEMCPY is not set
@@ -923,7 +930,6 @@ CONFIG_IP_NF_MATCH_ECN=y
 CONFIG_IP_NF_MATCH_TTL=y
 CONFIG_IP_NF_FILTER=y
 CONFIG_IP_NF_TARGET_REJECT=y
-CONFIG_IP_NF_TARGET_REJECT_SKERR=y
 # CONFIG_IP_NF_TARGET_ULOG is not set
 CONFIG_NF_NAT_IPV4=y
 CONFIG_IP_NF_TARGET_MASQUERADE=y
@@ -960,7 +966,6 @@ CONFIG_IP6_NF_IPTABLES=y
 # CONFIG_IP6_NF_TARGET_HL is not set
 CONFIG_IP6_NF_FILTER=y
 CONFIG_IP6_NF_TARGET_REJECT=y
-CONFIG_IP6_NF_TARGET_REJECT_SKERR=y
 CONFIG_IP6_NF_MANGLE=y
 CONFIG_IP6_NF_RAW=y
 # CONFIG_IP6_NF_SECURITY is not set
@@ -990,7 +995,7 @@ CONFIG_NET_SCHED=y
 # CONFIG_NET_SCH_CBQ is not set
 CONFIG_NET_SCH_HTB=y
 # CONFIG_NET_SCH_HFSC is not set
-# CONFIG_NET_SCH_PRIO is not set
+CONFIG_NET_SCH_PRIO=y
 # CONFIG_NET_SCH_MULTIQ is not set
 # CONFIG_NET_SCH_RED is not set
 # CONFIG_NET_SCH_SFB is not set
@@ -1006,14 +1011,14 @@ CONFIG_NET_SCH_HTB=y
 # CONFIG_NET_SCH_QFQ is not set
 # CONFIG_NET_SCH_CODEL is not set
 # CONFIG_NET_SCH_FQ_CODEL is not set
-# CONFIG_NET_SCH_INGRESS is not set
+CONFIG_NET_SCH_INGRESS=y
 # CONFIG_NET_SCH_PLUG is not set
 
 #
 # Classification
 #
 CONFIG_NET_CLS=y
-# CONFIG_NET_CLS_BASIC is not set
+CONFIG_NET_CLS_BASIC=y
 # CONFIG_NET_CLS_TCINDEX is not set
 # CONFIG_NET_CLS_ROUTE4 is not set
 # CONFIG_NET_CLS_FW is not set
@@ -1138,6 +1143,9 @@ CONFIG_SEC_NFC_IF_I2C=y
 CONFIG_SEC_NFC_CLK_REQ=y
 # CONFIG_SEC_NFC_MARGINTIME is not set
 # CONFIG_SEC_NFC_LDO_CONTROL is not set
+# CONFIG_SEC_NFC_SENN3AB is not set
+# CONFIG_NFC_DEBUG is not set
+# CONFIG_NFC_EDC_TUNING is not set
 # CONFIG_IPC_ROUTER is not set
 CONFIG_HAVE_BPF_JIT=y
 
@@ -1261,9 +1269,12 @@ CONFIG_BLK_DEV_RAM_SIZE=8192
 CONFIG_UID_CPUTIME=y
 # CONFIG_SRAM is not set
 # CONFIG_SEC_DEV_JACK is not set
+# CONFIG_RF_EAR_DET is not set
+# CONFIG_SEC_DEV_JACK_ANT is not set
 CONFIG_TIMA_LOG=y
 # CONFIG_LED_COVER is not set
 # CONFIG_JACK_ADC_MORE_CTIME is not set
+# CONFIG_CHECK_SIMSLOT_COUNT is not set
 # CONFIG_C2PORT is not set
 
 #
@@ -1327,6 +1338,11 @@ CONFIG_UMTS_MODEM_SS333=y
 # CONFIG_SIM_DETECT is not set
 
 #
+# NOTIFIER configs
+#
+CONFIG_VBUS_NOTIFIER=y
+
+#
 # MUIC configs
 #
 CONFIG_USE_MUIC=y
@@ -1733,9 +1749,10 @@ CONFIG_WLAN_REGION_CODE=100
 CONFIG_WLAIBSS=y
 # CONFIG_WL_NAN is not set
 CONFIG_BCMDHD_PCIE=y
-CONFIG_WIFI_BROADCOM_COB=y
 # CONFIG_BCMDHD_DEBUG_PAGEALLOC is not set
 # CONFIG_BCMDHD_PREALLOC_MEMDUMP is not set
+CONFIG_WIFI_BROADCOM_COB=y
+# CONFIG_SPLIT_ARGOS_SET is not set
 # CONFIG_BCM43455 is not set
 # CONFIG_BCM4334W is not set
 # CONFIG_BCM43454 is not set
@@ -2011,7 +2028,7 @@ CONFIG_HW_RANDOM=y
 CONFIG_HW_RANDOM_EXYNOS_SWD=y
 CONFIG_EXYRNG_FIPS_COMPLIANCE=y
 # CONFIG_EXYRNG_FAIL_POLICY_DISABLE is not set
-# CONFIG_EXYRNG_FAIL_POLICY_RESET is not set
+CONFIG_EXYRNG_FAIL_POLICY_RESET=y
 CONFIG_HW_RANDOM_TPM=y
 # CONFIG_R3964 is not set
 # CONFIG_APPLICOM is not set
@@ -2690,6 +2707,8 @@ CONFIG_MEDIA_SUBDRV_AUTOSELECT=y
 #
 # CONFIG_DVB_DUMMY_FE is not set
 # CONFIG_TDMB is not set
+# CONFIG_ISDBT is not set
+# CONFIG_ISDBT_F_TYPE_ANTENNA is not set
 
 #
 # Graphics support
@@ -2705,7 +2724,7 @@ CONFIG_ION_EXYNOS_OF=y
 #
 # ARM GPU Configuration
 #
-# CONFIG_MALI_T6XX is not set
+# CONFIG_MALI_MIDGARD is not set
 CONFIG_MALI_EXYNOS_TRACE=y
 CONFIG_MALI_EXPERT=y
 # CONFIG_MALI_DEBUG_SHADER_SPLIT_FS is not set
@@ -2716,23 +2735,20 @@ CONFIG_MALI_PLATFORM_THIRDPARTY_NAME="54
 # CONFIG_MALI_NO_MALI is not set
 # CONFIG_MALI_TRACE_TIMELINE is not set
 # CONFIG_MALI_SYSTEM_TRACE is not set
-# CONFIG_MALI_GPU_TRACEPOINTS is not set
-# CONFIG_MALI_MIDGARD is not set
 # CONFIG_MALI_MIDGARD_WK04 is not set
-# CONFIG_MALI400 is not set
+CONFIG_DDK_VERSION_OS="n"
+CONFIG_MALI_T7XX=y
+# CONFIG_MALI_R5P0 is not set
+# CONFIG_MALI_R7P0 is not set
+CONFIG_MALI_R12P0=y
 CONFIG_MALI_DVFS=y
-# CONFIG_MALI_T6XX_R7P0 is not set
-CONFIG_MALI_SYSTRACE_SUPPORT=y
-# CONFIG_MALI_DVFS_USER is not set
 CONFIG_MALI_RT_PM=y
-# CONFIG_MALI_MIDGARD_ENABLE_TRACE is not set
 CONFIG_MALI_DEBUG_SYS=y
 # CONFIG_MALI_DEVFREQ is not set
+CONFIG_MALI_SYSTRACE_SUPPORT=y
+# CONFIG_MALI_MIDGARD_ENABLE_TRACE is not set
 CONFIG_MALI_SEC_HWCNT=y
-CONFIG_MALI_T7XX=y
-# CONFIG_MALI_R5P0 is not set
-CONFIG_MALI_R7P0=y
-# CONFIG_MALI_SEC_LEGACY_SUPPORT is not set
+CONFIG_MALI_SEC_LEGACY_SUPPORT=y
 # CONFIG_VGASTATE is not set
 # CONFIG_VIDEO_OUTPUT_CONTROL is not set
 CONFIG_FB=y
@@ -2795,8 +2811,6 @@ CONFIG_DECON_MIPI_DSI=y
 CONFIG_DECON_MIPI_DSI_PKTGO=y
 CONFIG_FB_EXYNOS_FIMD_MC=y
 CONFIG_DECON_LCD=y
-# CONFIG_DECON_LCD_S6E8AA0 is not set
-# CONFIG_DECON_LCD_S6E3FA0 is not set
 # CONFIG_DECON_LCD_S6E3FA2 is not set
 # CONFIG_DECON_LCD_S6TNMR7 is not set
 # CONFIG_DECON_LCD_S6E3HA1 is not set
@@ -2839,10 +2853,8 @@ CONFIG_FB_WINDOW_UPDATE=y
 # CONFIG_FB_DSU is not set
 # CONFIG_ESD_FG is not set
 # CONFIG_LCD_ELON1_DET is not set
-# CONFIG_DECON_LCD_S6E3HA0K is not set
 # CONFIG_DECON_LCD_S6E3FA2_A7 is not set
 # CONFIG_DECON_LCD_S6E3FA3X01 is not set
-# CONFIG_DECON_LCD_S6E3HA0 is not set
 # CONFIG_DECON_LCD_EA8064G is not set
 # CONFIG_DECON_LCD_S6E3HA2 is not set
 # CONFIG_DECON_LCD_S6E3HF2 is not set
@@ -3164,7 +3176,7 @@ CONFIG_USB_XHCI_PLATFORM=y
 #
 # USB Device Class drivers
 #
-# CONFIG_USB_ACM is not set
+CONFIG_USB_ACM=y
 CONFIG_USB_PRINTER=y
 # CONFIG_USB_WDM is not set
 # CONFIG_USB_TMC is not set
@@ -3392,12 +3404,13 @@ CONFIG_MMC_CLKGATE=y
 CONFIG_MMC_BLOCK=y
 CONFIG_MMC_BLOCK_MINORS=8
 CONFIG_MMC_BLOCK_BOUNCE=y
-# CONFIG_MMC_BLOCK_DEFERRED_RESUME is not set
+CONFIG_MMC_BLOCK_DEFERRED_RESUME=y
 # CONFIG_SDIO_UART is not set
 # CONFIG_MMC_TEST is not set
 CONFIG_MMC_SUPPORT_BKOPS_MODE=y
 CONFIG_MMC_BKOPS_NODE_UID=1000
 CONFIG_MMC_BKOPS_NODE_GID=1001
+# CONFIG_MMC_CPRM is not set
 
 #
 # MMC/SD/SDIO Host Controller Drivers
@@ -3730,7 +3743,6 @@ CONFIG_STAGING=y
 CONFIG_ANDROID=y
 CONFIG_ANDROID_BINDER_IPC=y
 CONFIG_ASHMEM=y
-CONFIG_ANDROID_LOGGER=y
 CONFIG_ANDROID_TIMED_OUTPUT=y
 # CONFIG_ANDROID_TIMED_GPIO is not set
 CONFIG_ANDROID_LOW_MEMORY_KILLER=y
@@ -3795,6 +3807,7 @@ CONFIG_SEC_KEEP_SBOOT=y
 CONFIG_SEC_LOG=y
 CONFIG_SEC_LOG_NONCACHED=y
 CONFIG_SEC_LOG_LAST_KMSG=y
+CONFIG_SEC_LOG_PMSG=y
 CONFIG_SEC_AVC_LOG=y
 CONFIG_SEC_DEBUG_TSP_LOG=y
 CONFIG_SEC_DEBUG_TIMA_LOG=y
@@ -4005,7 +4018,7 @@ CONFIG_BATTERY_SAMSUNG=y
 # CONFIG_CHARGING_VZWCONCEPT is not set
 CONFIG_BATTERY_SWELLING=y
 CONFIG_BATTERY_SWELLING_SELF_DISCHARGING=y
-CONFIG_BATTERY_SWELLING_SELF_DISCHARGING_GTS2_ONLY=y
+# CONFIG_BATTERY_ADC_CHANNEL_SEPERATION is not set
 # CONFIG_INBATTERY is not set
 # CONFIG_FUELGAUGE_RT5033 is not set
 # CONFIG_FUELGAUGE_DUMMY is not set
@@ -4110,8 +4123,7 @@ CONFIG_MOBICORE_DRIVER=y
 # CONFIG_MOBICORE_DEBUG is not set
 CONFIG_MOBICORE_API=y
 CONFIG_SECURE_OS_CONTROL=y
-CONFIG_TRUSTONIC_TRUSTED_UI=y
-CONFIG_TRUSTONIC_TRUSTED_UI_FB_BLANK=y
+# CONFIG_TRUSTONIC_TRUSTED_UI is not set
 CONFIG_SECURE_OS_BOOSTER_API=y
 
 #
@@ -4129,6 +4141,7 @@ CONFIG_SECURE_OS_BOOSTER_API=y
 # File systems
 #
 CONFIG_DCACHE_WORD_ACCESS=y
+CONFIG_INTERRUPTIBLE_SYNC=y
 CONFIG_LOW_ORDER_SEQ_MALLOC=y
 CONFIG_EXT2_FS=y
 CONFIG_EXT2_FS_XATTR=y
@@ -4194,6 +4207,20 @@ CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
 CONFIG_FAT_VIRTUAL_XATTR=y
 CONFIG_FAT_VIRTUAL_XATTR_SELINUX_LABEL="u:object_r:sdcard_external:s0"
 CONFIG_FAT_SUPPORT_STLOG=y
+CONFIG_SDFAT_FS=y
+CONFIG_SDFAT_DELAYED_META_DIRTY=y
+# CONFIG_SDFAT_SUPPORT_DIR_SYNC is not set
+CONFIG_SDFAT_DEFAULT_CODEPAGE=437
+CONFIG_SDFAT_DEFAULT_IOCHARSET="utf8"
+# CONFIG_SDFAT_CHECK_RO_ATTR is not set
+CONFIG_SDFAT_ALIGNED_MPAGE_WRITE=y
+CONFIG_SDFAT_VIRTUAL_XATTR=y
+CONFIG_SDFAT_VIRTUAL_XATTR_SELINUX_LABEL="u:object_r:sdcard_external:s0"
+CONFIG_SDFAT_SUPPORT_STLOG=y
+CONFIG_SDFAT_DEBUG=y
+# CONFIG_SDFAT_DBG_IOCTL is not set
+CONFIG_SDFAT_DBG_MSG=y
+# CONFIG_SDFAT_DBG_BUGON is not set
 CONFIG_EXFAT_FS=y
 CONFIG_EXFAT_VIRTUAL_XATTR=y
 CONFIG_EXFAT_VIRTUAL_XATTR_SELINUX_LABEL="u:object_r:sdcard_external:s0"
@@ -4245,7 +4272,10 @@ CONFIG_CRAMFS=y
 CONFIG_ROMFS_FS=y
 CONFIG_ROMFS_BACKED_BY_BLOCK=y
 CONFIG_ROMFS_ON_BLOCK=y
-# CONFIG_PSTORE is not set
+CONFIG_PSTORE=y
+# CONFIG_PSTORE_CONSOLE is not set
+CONFIG_PSTORE_PMSG=y
+CONFIG_PSTORE_RAM=y
 # CONFIG_SYSV_FS is not set
 # CONFIG_UFS_FS is not set
 # CONFIG_F2FS_FS is not set
@@ -4320,6 +4350,7 @@ CONFIG_ENABLE_WARN_DEPRECATED=y
 CONFIG_ENABLE_MUST_CHECK=y
 CONFIG_FRAME_WARN=1024
 CONFIG_MAGIC_SYSRQ=y
+CONFIG_SKIP_BACKTRACE_ALLCPUS_SYSRQ=y
 # CONFIG_STRIP_ASM_SYMS is not set
 # CONFIG_READABLE_ASM is not set
 # CONFIG_UNUSED_SYMBOLS is not set
@@ -4462,6 +4493,7 @@ CONFIG_KEYS=y
 # CONFIG_ENCRYPTED_KEYS is not set
 CONFIG_KEYS_DEBUG_PROC_KEYS=y
 # CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY_PERF_EVENTS_RESTRICT is not set
 CONFIG_SECURITY=y
 CONFIG_SECURITYFS=y
 CONFIG_SECURITY_NETWORK=y
@@ -4482,6 +4514,8 @@ CONFIG_SEC_SELINUX=y
 # CONFIG_SECURITY_YAMA is not set
 # CONFIG_IMA is not set
 # CONFIG_EVM is not set
+# CONFIG_TZ_ICCC_MOS_SUPPORT is not set
+CONFIG_TZ_ICCC_NOS_SUPPORT=y
 CONFIG_TZ_ICCC=y
 CONFIG_DEFAULT_SECURITY_SELINUX=y
 # CONFIG_DEFAULT_SECURITY_DAC is not set
@@ -4646,6 +4680,9 @@ CONFIG_DECOMPRESS_LZMA=y
 CONFIG_DECOMPRESS_XZ=y
 CONFIG_DECOMPRESS_LZO=y
 CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_REED_SOLOMON=y
+CONFIG_REED_SOLOMON_ENC8=y
+CONFIG_REED_SOLOMON_DEC8=y
 CONFIG_TEXTSEARCH=y
 CONFIG_TEXTSEARCH_KMP=y
 CONFIG_TEXTSEARCH_BM=y
diff -duprN mm/arch/arm/include/asm/thread_info.h n/arch/arm/include/asm/thread_info.h
--- mm/arch/arm/include/asm/thread_info.h	2016-09-20 17:29:33.000000000 +0530
+++ n/arch/arm/include/asm/thread_info.h	2017-03-31 10:41:28.000000000 +0530
@@ -58,7 +58,7 @@ struct thread_info {
 	struct cpu_context_save	cpu_context;	/* cpu context */
 	__u32			syscall;	/* syscall number */
 	__u8			used_cp[16];	/* thread used copro */
-	unsigned long		tp_value;
+	unsigned long		tp_value[2];	/* TLS registers */
 #ifdef CONFIG_CRUNCH
 	struct crunch_state	crunchstate;
 #endif
diff -duprN mm/arch/arm/include/asm/tls.h n/arch/arm/include/asm/tls.h
--- mm/arch/arm/include/asm/tls.h	2016-09-20 17:29:31.000000000 +0530
+++ n/arch/arm/include/asm/tls.h	2017-03-31 10:41:28.000000000 +0530
@@ -2,27 +2,30 @@
 #define __ASMARM_TLS_H
 
 #ifdef __ASSEMBLY__
-	.macro set_tls_none, tp, tmp1, tmp2
+#include <asm/asm-offsets.h>
+	.macro switch_tls_none, base, tp, tpuser, tmp1, tmp2
 	.endm
 
-	.macro set_tls_v6k, tp, tmp1, tmp2
+	.macro switch_tls_v6k, base, tp, tpuser, tmp1, tmp2
+	mrc	p15, 0, \tmp2, c13, c0, 2	@ get the user r/w register
 	mcr	p15, 0, \tp, c13, c0, 3		@ set TLS register
-	mov	\tmp1, #0
-	mcr	p15, 0, \tmp1, c13, c0, 2	@ clear user r/w TLS register
+	mcr	p15, 0, \tpuser, c13, c0, 2	@ and the user r/w register
+	str	\tmp2, [\base, #TI_TP_VALUE + 4] @ save it
 	.endm
 
-	.macro set_tls_v6, tp, tmp1, tmp2
+	.macro switch_tls_v6, base, tp, tpuser, tmp1, tmp2
 	ldr	\tmp1, =elf_hwcap
 	ldr	\tmp1, [\tmp1, #0]
 	mov	\tmp2, #0xffff0fff
 	tst	\tmp1, #HWCAP_TLS		@ hardware TLS available?
-	mcrne	p15, 0, \tp, c13, c0, 3		@ yes, set TLS register
-	movne	\tmp1, #0
-	mcrne	p15, 0, \tmp1, c13, c0, 2	@ clear user r/w TLS register
 	streq	\tp, [\tmp2, #-15]		@ set TLS value at 0xffff0ff0
+	mrcne	p15, 0, \tmp2, c13, c0, 2	@ get the user r/w register
+	mcrne	p15, 0, \tp, c13, c0, 3		@ yes, set TLS register
+	mcrne	p15, 0, \tpuser, c13, c0, 2	@ set user r/w register
+	strne	\tmp2, [\base, #TI_TP_VALUE + 4] @ save it
 	.endm
 
-	.macro set_tls_software, tp, tmp1, tmp2
+	.macro switch_tls_software, base, tp, tpuser, tmp1, tmp2
 	mov	\tmp1, #0xffff0fff
 	str	\tp, [\tmp1, #-15]		@ set TLS value at 0xffff0ff0
 	.endm
@@ -31,19 +34,30 @@
 #ifdef CONFIG_TLS_REG_EMUL
 #define tls_emu		1
 #define has_tls_reg		1
-#define set_tls		set_tls_none
+#define switch_tls	switch_tls_none
 #elif defined(CONFIG_CPU_V6)
 #define tls_emu		0
 #define has_tls_reg		(elf_hwcap & HWCAP_TLS)
-#define set_tls		set_tls_v6
+#define switch_tls	switch_tls_v6
 #elif defined(CONFIG_CPU_32v6K)
 #define tls_emu		0
 #define has_tls_reg		1
-#define set_tls		set_tls_v6k
+#define switch_tls	switch_tls_v6k
 #else
 #define tls_emu		0
 #define has_tls_reg		0
-#define set_tls		set_tls_software
+#define switch_tls	switch_tls_software
 #endif
 
+#ifndef __ASSEMBLY__
+static inline unsigned long get_tpuser(void)
+{
+	unsigned long reg = 0;
+
+	if (has_tls_reg && !tls_emu)
+		__asm__("mrc p15, 0, %0, c13, c0, 2" : "=r" (reg));
+
+	return reg;
+}
+#endif
 #endif	/* __ASMARM_TLS_H */
diff -duprN mm/arch/arm/kernel/entry-armv.S n/arch/arm/kernel/entry-armv.S
--- mm/arch/arm/kernel/entry-armv.S	2016-09-20 17:29:34.000000000 +0530
+++ n/arch/arm/kernel/entry-armv.S	2017-03-31 10:41:28.000000000 +0530
@@ -688,15 +688,16 @@ ENTRY(__switch_to)
  UNWIND(.fnstart	)
  UNWIND(.cantunwind	)
 	add	ip, r1, #TI_CPU_SAVE
-	ldr	r3, [r2, #TI_TP_VALUE]
  ARM(	stmia	ip!, {r4 - sl, fp, sp, lr} )	@ Store most regs on stack
  THUMB(	stmia	ip!, {r4 - sl, fp}	   )	@ Store most regs on stack
  THUMB(	str	sp, [ip], #4		   )
  THUMB(	str	lr, [ip], #4		   )
+	ldr	r4, [r2, #TI_TP_VALUE]
+	ldr	r5, [r2, #TI_TP_VALUE + 4]
 #ifdef CONFIG_CPU_USE_DOMAINS
 	ldr	r6, [r2, #TI_CPU_DOMAIN]
 #endif
-	set_tls	r3, r4, r5
+	switch_tls r1, r4, r5, r3, r7
 #if defined(CONFIG_CC_STACKPROTECTOR) && !defined(CONFIG_SMP)
 	ldr	r7, [r2, #TI_TASK]
 	ldr	r8, =__stack_chk_guard
diff -duprN mm/arch/arm/kernel/hw_breakpoint.c n/arch/arm/kernel/hw_breakpoint.c
--- mm/arch/arm/kernel/hw_breakpoint.c	2016-09-20 17:29:31.000000000 +0530
+++ n/arch/arm/kernel/hw_breakpoint.c	2017-03-31 10:41:28.000000000 +0530
@@ -955,6 +955,14 @@ static void reset_ctrl_regs(void *unused
 		goto out_mdbgen;
 	case ARM_DEBUG_ARCH_V7_ECP14:
 		/*
+		 * Unconditionally clear the OS lock by writing a value
+		 * other than CS_LAR_KEY to the access register.
+		*/
+
+		ARM_DBG_WRITE(c1, c0, 4, CS_LAR_KEY);
+		isb();
+		
+		/*
 		 * Ensure sticky power-down is clear (i.e. debug logic is
 		 * powered up).
 		 */
@@ -967,6 +975,14 @@ static void reset_ctrl_regs(void *unused
 		break;
 	case ARM_DEBUG_ARCH_V7_1:
 		/*
+		 * Unconditionally clear the OS lock by writing a value
+		 * other than CS_LAR_KEY to the access register.
+		*/
+
+		ARM_DBG_WRITE(c1, c0, 4, CS_LAR_KEY);
+		isb();
+		
+		/*
 		 * Ensure the OS double lock is clear.
 		 */
 		ARM_DBG_READ(c1, c3, 4, val);
@@ -982,13 +998,6 @@ static void reset_ctrl_regs(void *unused
 	}
 
 	/*
-	 * Unconditionally clear the OS lock by writing a value
-	 * other than CS_LAR_KEY to the access register.
-	 */
-	ARM_DBG_WRITE(c1, c0, 4, ~CS_LAR_KEY);
-	isb();
-
-	/*
 	 * Clear any configured vector-catch events before
 	 * enabling monitor mode.
 	 */
diff -duprN mm/arch/arm/kernel/irq.c n/arch/arm/kernel/irq.c
--- mm/arch/arm/kernel/irq.c	2016-09-20 17:29:34.000000000 +0530
+++ n/arch/arm/kernel/irq.c	2017-03-31 10:41:28.000000000 +0530
@@ -163,6 +163,8 @@ static bool migrate_one_irq(struct irq_d
 	if (cpumask_any_and(affinity, cpu_online_mask) >= nr_cpu_ids) {
 		affinity = cpu_online_mask;
 		ret = true;
+	} else if (unlikely(d->state_use_accessors & IRQD_GIC_MULTI_TARGET)) {
+		return false;
 	}
 
 	c = irq_data_get_irq_chip(d);
diff -duprN mm/arch/arm/kernel/process.c n/arch/arm/kernel/process.c
--- mm/arch/arm/kernel/process.c	2016-09-20 17:29:34.000000000 +0530
+++ n/arch/arm/kernel/process.c	2017-03-31 10:41:28.000000000 +0530
@@ -40,6 +40,7 @@
 #include <asm/thread_notify.h>
 #include <asm/stacktrace.h>
 #include <asm/mach/time.h>
+#include <asm/tls.h>
 
 #include <mach/exynos-ss.h>
 
@@ -553,7 +554,8 @@ copy_thread(unsigned long clone_flags, u
 	clear_ptrace_hw_breakpoint(p);
 
 	if (clone_flags & CLONE_SETTLS)
-		thread->tp_value = childregs->ARM_r3;
+		thread->tp_value[0] = childregs->ARM_r3;
+	thread->tp_value[1] = get_tpuser();
 
 	thread_notify(THREAD_NOTIFY_COPY, thread);
 
diff -duprN mm/arch/arm/kernel/ptrace.c n/arch/arm/kernel/ptrace.c
--- mm/arch/arm/kernel/ptrace.c	2016-09-20 17:29:34.000000000 +0530
+++ n/arch/arm/kernel/ptrace.c	2017-03-31 10:41:28.000000000 +0530
@@ -849,7 +849,7 @@ long arch_ptrace(struct task_struct *chi
 #endif
 
 		case PTRACE_GET_THREAD_AREA:
-			ret = put_user(task_thread_info(child)->tp_value,
+			ret = put_user(task_thread_info(child)->tp_value[0],
 				       datap);
 			break;
 
diff -duprN mm/arch/arm/kernel/sys_oabi-compat.c n/arch/arm/kernel/sys_oabi-compat.c
--- mm/arch/arm/kernel/sys_oabi-compat.c	2016-09-20 17:29:34.000000000 +0530
+++ n/arch/arm/kernel/sys_oabi-compat.c	2017-03-31 10:41:28.000000000 +0530
@@ -193,52 +193,53 @@ struct oabi_flock64 {
 	pid_t	l_pid;
 } __attribute__ ((packed,aligned(4)));
 
-asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
+static long do_locks(unsigned int fd, unsigned int cmd,
 				 unsigned long arg)
 {
-	struct oabi_flock64 user;
 	struct flock64 kernel;
-	mm_segment_t fs = USER_DS; /* initialized to kill a warning */
-	unsigned long local_arg = arg;
-	int ret;
+	struct oabi_flock64 user;
+	mm_segment_t fs;
+	long ret;
 
-	switch (cmd) {
-	case F_GETLK64:
-	case F_SETLK64:
-	case F_SETLKW64:
-		if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
-				   sizeof(user)))
-			return -EFAULT;
-		kernel.l_type	= user.l_type;
-		kernel.l_whence	= user.l_whence;
-		kernel.l_start	= user.l_start;
-		kernel.l_len	= user.l_len;
-		kernel.l_pid	= user.l_pid;
-		local_arg = (unsigned long)&kernel;
-		fs = get_fs();
-		set_fs(KERNEL_DS);
-	}
+	if (copy_from_user(&user, (struct oabi_flock64 __user *)arg,
+			   sizeof(user)))
+		return -EFAULT;
+	kernel.l_type	= user.l_type;
+	kernel.l_whence	= user.l_whence;
+	kernel.l_start	= user.l_start;
+	kernel.l_len	= user.l_len;
+	kernel.l_pid	= user.l_pid;
 
-	ret = sys_fcntl64(fd, cmd, local_arg);
+	fs = get_fs();
+	set_fs(KERNEL_DS);
+	ret = sys_fcntl64(fd, cmd, (unsigned long)&kernel);
+	set_fs(fs);
+
+	if (!ret && (cmd == F_GETLK64 || cmd == F_OFD_GETLK)) {
+		user.l_type	= kernel.l_type;
+		user.l_whence	= kernel.l_whence;
+		user.l_start	= kernel.l_start;
+		user.l_len	= kernel.l_len;
+		user.l_pid	= kernel.l_pid;
+		if (copy_to_user((struct oabi_flock64 __user *)arg,
+				 &user, sizeof(user)))
+			ret = -EFAULT;
+	}
+	return ret;
+}
 
+asmlinkage long sys_oabi_fcntl64(unsigned int fd, unsigned int cmd,
+				 unsigned long arg)
+{
 	switch (cmd) {
 	case F_GETLK64:
-		if (!ret) {
-			user.l_type	= kernel.l_type;
-			user.l_whence	= kernel.l_whence;
-			user.l_start	= kernel.l_start;
-			user.l_len	= kernel.l_len;
-			user.l_pid	= kernel.l_pid;
-			if (copy_to_user((struct oabi_flock64 __user *)arg,
-					 &user, sizeof(user)))
-				ret = -EFAULT;
-		}
 	case F_SETLK64:
 	case F_SETLKW64:
-		set_fs(fs);
-	}
+		return do_locks(fd, cmd, arg);
 
-	return ret;
+	default:
+		return sys_fcntl64(fd, cmd, arg);
+	}
 }
 
 struct oabi_epoll_event {
diff -duprN mm/arch/arm/kernel/traps.c n/arch/arm/kernel/traps.c
--- mm/arch/arm/kernel/traps.c	2016-09-20 17:29:34.000000000 +0530
+++ n/arch/arm/kernel/traps.c	2017-03-31 10:41:28.000000000 +0530
@@ -608,7 +608,7 @@ asmlinkage int arm_syscall(int no, struc
 		return regs->ARM_r0;
 
 	case NR(set_tls):
-		thread->tp_value = regs->ARM_r0;
+		thread->tp_value[0] = regs->ARM_r0;
 		if (tls_emu)
 			return 0;
 		if (has_tls_reg) {
@@ -726,7 +726,7 @@ static int get_tp_trap(struct pt_regs *r
 	int reg = (instr >> 12) & 15;
 	if (reg == 15)
 		return 1;
-	regs->uregs[reg] = current_thread_info()->tp_value;
+	regs->uregs[reg] = current_thread_info()->tp_value[0];
 	regs->ARM_pc += 4;
 	return 0;
 }
diff -duprN mm/arch/arm/mach-exynos/Kconfig n/arch/arm/mach-exynos/Kconfig
--- mm/arch/arm/mach-exynos/Kconfig	2016-09-20 17:29:40.000000000 +0530
+++ n/arch/arm/mach-exynos/Kconfig	2017-03-31 10:41:29.000000000 +0530
@@ -156,6 +156,7 @@ config SOC_EXYNOS5433
 	select EXYNOS_SPI_RESET_DURING_DSTOP if CPU_IDLE
 	select EXYNOS_PWM_RESET_DURING_DSTOP if CPU_IDLE
 	select CAL_SYS_PWRDOWN
+	select SECCOMP
 	help
 	  Enable EXYNOS5433 SoC support
 
@@ -228,6 +229,15 @@ config 24MHZ_XTALCLK_DRV_STRENGTH_X4
 	bool "24MHZ_XTALCLK_DRV_STRENGTH_X4"
   default n
 
+menu "Exynos5433 Type"
+	depends on SOC_EXYNOS5433
+
+config SOC_EXYNOS5433_L
+	bool "Exynos5433 L version"
+	help
+	  This option enable exynos5433 lite version
+endmenu
+
 config EXYNOS5430_BTS
 	bool "Bus traffic shaper support"
 	default y
@@ -346,6 +356,14 @@ config EXYNOS_SNAPSHOT_HOOK_LOGGER
 	depends on EXYNOS_SNAPSHOT
 	default y
 
+config EXYNOS_SNAPSHOT_PSTORE
+	bool "Enable supporting ramoops driver for pstore filesystem"
+	depends on EXYNOS_SNAPSHOT
+	select PSTORE
+	select PSTORE_RAM
+	select PSTORE_PMSG
+	default y
+
 config EXYNOS_SNAPSHOT_PANIC_REBOOT
 	bool "Enable forced reboot after panic for ramdump"
 	depends on EXYNOS_SNAPSHOT
diff -duprN mm/arch/arm/mach-exynos/cpuidle-exynos5433.c n/arch/arm/mach-exynos/cpuidle-exynos5433.c
--- mm/arch/arm/mach-exynos/cpuidle-exynos5433.c	2016-09-20 17:29:35.000000000 +0530
+++ n/arch/arm/mach-exynos/cpuidle-exynos5433.c	2017-03-31 10:41:29.000000000 +0530
@@ -182,6 +182,7 @@ static struct check_reg_lpa exynos5_lpc_
 
 static struct check_reg_lpa exynos5_clock_gating[] = {
 	{.check_reg = EXYNOS5430_ENABLE_IP_PERIC0,	.check_bit = 0xF00FFF},
+	{.check_reg = EXYNOS5430_ENABLE_IP_PERIC2,	.check_bit = 0x3FF},
 };
 
 #ifdef CONFIG_EXYNOS_MIPI_LLI
diff -duprN mm/arch/arm/mach-exynos/exynos-ss.c n/arch/arm/mach-exynos/exynos-ss.c
--- mm/arch/arm/mach-exynos/exynos-ss.c	2016-09-20 17:29:41.000000000 +0530
+++ n/arch/arm/mach-exynos/exynos-ss.c	2017-03-31 10:41:29.000000000 +0530
@@ -23,6 +23,8 @@
 #include <linux/delay.h>
 #include <linux/module.h>
 #include <linux/memblock.h>
+#include <linux/platform_device.h>
+#include <linux/pstore_ram.h>
 
 #include <asm/mach/map.h>
 #include <asm/cacheflush.h>
@@ -250,8 +252,14 @@ static struct exynos_ss_item ess_items[]
 	{"log_kevents",	{SZ_8M,		0, 0, true}, NULL ,NULL},
 	{"log_kernel",	{SZ_2M,		0, 0, true}, NULL ,NULL},
 #ifdef CONFIG_EXYNOS_SNAPSHOT_HOOK_LOGGER
-	{"log_main",	{SZ_2M + SZ_1M,	0, 0, true}, NULL ,NULL},
-	{"log_system",	{SZ_1M,		0, 0, true}, NULL ,NULL},
+#ifndef CONFIG_EXYNOS_SNAPSHOT_MINIMIZED_MODE
+	{"log_platform",{SZ_4M,		0, 0, true}, NULL ,NULL},
+#else
+	{"log_platform",{SZ_2M,		0, 0, true}, NULL ,NULL},
+#endif
+#ifdef CONFIG_EXYNOS_SNAPSHOT_PSTORE
+	{"log_pstore",	{SZ_2M,		0, 0, true}, NULL ,NULL},
+#endif
 #endif
 };
 
@@ -575,6 +583,30 @@ static void exynos_ss_scratch_reg(unsign
 	__raw_writel(val, S5P_VA_SS_SCRATCH);
 }
 
+unsigned int exynos_ss_get_item_size(char* name)
+{
+	unsigned long i;
+
+	for (i = 0; i < ARRAY_SIZE(ess_items); i++) {
+		if (!strncmp(ess_items[i].name, name, strlen(name)))
+			return ess_items[i].entry.size;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(exynos_ss_get_item_size);
+
+unsigned int exynos_ss_get_item_paddr(char* name)
+{
+	unsigned long i;
+
+	for (i = 0; i < ARRAY_SIZE(ess_items); i++) {
+		if (!strncmp(ess_items[i].name, name, strlen(name)))
+			return ess_items[i].entry.paddr;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(exynos_ss_get_item_paddr);
+
 #if defined(CONFIG_EXYNOS_SNAPSHOT_FORCE_DUMP_MODE) || defined(CONFIG_EXYNOS_SNAPSHOT_PANIC_REBOOT)
 static void exynos_ss_report_cause_emerg(enum ess_cause_emerg_events event)
 {
@@ -1365,6 +1397,217 @@ void exynos_ss_printkl(size_t msg, size_
 #endif
 }
 
+/* This defines are for PSTORE */
+#define ESS_LOGGER_LEVEL_HEADER 	(1)
+#define ESS_LOGGER_LEVEL_PREFIX 	(2)
+#define ESS_LOGGER_LEVEL_TEXT		(3)
+#define ESS_LOGGER_LEVEL_MAX		(4)
+#define ESS_LOGGER_SKIP_COUNT		(4)
+#define ESS_LOGGER_STRING_PAD		(1)
+#define ESS_LOGGER_HEADER_SIZE		(68)
+
+#define ESS_LOG_ID_MAIN 		(0)
+#define ESS_LOG_ID_RADIO		(1)
+#define ESS_LOG_ID_EVENTS		(2)
+#define ESS_LOG_ID_SYSTEM		(3)
+#define ESS_LOG_ID_CRASH		(4)
+#define ESS_LOG_ID_KERNEL		(5)
+
+typedef struct __attribute__((__packed__)) {
+    uint8_t magic;
+    uint16_t len;
+    uint16_t uid;
+    uint16_t pid;
+} ess_pmsg_log_header_t;
+
+typedef struct __attribute__((__packed__)) {
+	unsigned char id;
+	uint16_t tid;
+	int32_t tv_sec;
+	int32_t tv_nsec;
+} ess_android_log_header_t;
+
+typedef struct ess_logger {
+	uint16_t	len;
+	uint16_t	id;
+	uint16_t	pid;
+	uint16_t	tid;
+	uint16_t	uid;
+	uint16_t	level;
+	int32_t		tv_sec;
+	int32_t		tv_nsec;
+	char		msg[0];
+	char*		buffer;
+	void		(*func_hook_logger)(const char*, const char*, size_t);
+} __attribute__((__packed__)) ess_logger;
+
+static ess_logger logger;
+
+void register_hook_logger(void (*func)(const char *name, const char *buf, size_t size))
+{
+	logger.func_hook_logger = func;
+	logger.buffer = vmalloc(PAGE_SIZE * 3);
+
+	if (logger.buffer)
+		pr_info("exynos-snapshot: logger buffer alloc address: 0x%p\n", logger.buffer);
+}
+EXPORT_SYMBOL(register_hook_logger);
+
+static int exynos_ss_combine_pmsg(char *buffer, size_t count, unsigned int level)
+{
+	char *logbuf = logger.buffer;
+	if (!logbuf)
+		return -ENOMEM;
+
+	switch(level) {
+	case ESS_LOGGER_LEVEL_HEADER:
+		{
+			struct tm tmBuf;
+			u64 tv_kernel;
+			unsigned int logbuf_len;
+			unsigned long rem_nsec;
+
+			if (logger.id == ESS_LOG_ID_EVENTS)
+				break;
+
+			tv_kernel = local_clock();
+			rem_nsec = do_div(tv_kernel, 1000000000);
+			time_to_tm(logger.tv_sec, 0, &tmBuf);
+
+			logbuf_len = snprintf(logbuf, ESS_LOGGER_HEADER_SIZE,
+					"\n[%5lu.%06lu][%d:%16s] %02d-%02d %02d:%02d:%02d.%03d %5d %5d  ",
+					(unsigned long)tv_kernel, rem_nsec / 1000,
+					raw_smp_processor_id(), current->comm,
+					tmBuf.tm_mon + 1, tmBuf.tm_mday,
+					tmBuf.tm_hour, tmBuf.tm_min, tmBuf.tm_sec,
+					logger.tv_nsec / 1000000, logger.pid, logger.tid);
+
+			logger.func_hook_logger("log_platform", logbuf, logbuf_len - 1);
+		}
+		break;
+	case ESS_LOGGER_LEVEL_PREFIX:
+		{
+			static const char* kPrioChars = "!.VDIWEFS";
+			unsigned char prio = logger.msg[0];
+
+			if (logger.id == ESS_LOG_ID_EVENTS)
+				break;
+
+			logbuf[0] = prio < strlen(kPrioChars) ? kPrioChars[prio] : '?';
+			logbuf[1] = ' ';
+
+			logger.func_hook_logger("log_platform", logbuf, ESS_LOGGER_LEVEL_PREFIX);
+		}
+		break;
+	case ESS_LOGGER_LEVEL_TEXT:
+		{
+			char *eatnl = buffer + count - ESS_LOGGER_STRING_PAD;
+
+			if (logger.id == ESS_LOG_ID_EVENTS)
+				break;
+			if (count == ESS_LOGGER_SKIP_COUNT && *eatnl != '\0')
+				break;
+
+			logger.func_hook_logger("log_platform", buffer, count - 1);
+		}
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+int exynos_ss_hook_pmsg(char *buffer, size_t count)
+{
+	ess_android_log_header_t header;
+	ess_pmsg_log_header_t pmsg_header;
+
+	if (!logger.buffer)
+		return -ENOMEM;
+
+	switch(count) {
+	case sizeof(pmsg_header):
+		memcpy((void *)&pmsg_header, buffer, count);
+		if (pmsg_header.magic != 'l') {
+			exynos_ss_combine_pmsg(buffer, count, ESS_LOGGER_LEVEL_TEXT);
+		} else {
+			/* save logger data */
+			logger.pid = pmsg_header.pid;
+			logger.uid = pmsg_header.uid;
+			logger.len = pmsg_header.len;
+		}
+		break;
+	case sizeof(header):
+		/* save logger data */
+		memcpy((void *)&header, buffer, count);
+		logger.id = header.id;
+		logger.tid = header.tid;
+		logger.tv_sec = header.tv_sec;
+		logger.tv_nsec  = header.tv_nsec;
+		if (logger.id < 0 || logger.id > 7) {
+			/* write string */
+			exynos_ss_combine_pmsg(buffer, count, ESS_LOGGER_LEVEL_TEXT);
+		} else {
+			/* write header */
+			exynos_ss_combine_pmsg(buffer, count, ESS_LOGGER_LEVEL_HEADER);
+		}
+		break;
+	case sizeof(unsigned char):
+		logger.msg[0] = buffer[0];
+		/* write char for prefix */
+		exynos_ss_combine_pmsg(buffer, count, ESS_LOGGER_LEVEL_PREFIX);
+		break;
+	default:
+		/* write string */
+		exynos_ss_combine_pmsg(buffer, count, ESS_LOGGER_LEVEL_TEXT);
+		break;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(exynos_ss_hook_pmsg);
+
+/*
+ *  To support pstore/pmsg/pstore_ram, following is implementation for exynos-snapshot
+ *  ess_ramoops platform_device is used by pstore fs.
+ */
+
+#ifdef CONFIG_EXYNOS_SNAPSHOT_PSTORE
+static struct ramoops_platform_data ess_ramoops_data = {
+	.record_size	= SZ_512K,
+	.console_size	= SZ_512K,
+	.ftrace_size	= SZ_512K,
+	.pmsg_size	= SZ_512K,
+	.dump_oops	= 1,
+};
+
+static struct platform_device ess_ramoops = {
+	.name = "ramoops",
+	.dev = {
+		.platform_data = &ess_ramoops_data,
+	},
+};
+
+static int __init ess_pstore_init(void)
+{
+	if (exynos_ss_get_enable("log_pstore")) {
+		ess_ramoops_data.mem_size = exynos_ss_get_item_size("log_pstore");
+		ess_ramoops_data.mem_address = exynos_ss_get_item_paddr("log_pstore");
+	}
+	return platform_device_register(&ess_ramoops);
+}
+
+static void __exit ess_pstore_exit(void)
+{
+	platform_device_unregister(&ess_ramoops);
+}
+module_init(ess_pstore_init);
+module_exit(ess_pstore_exit);
+
+MODULE_DESCRIPTION("Exynos Snapshot pstore module");
+MODULE_LICENSE("GPL");
+#endif
+
 /*
  *  sysfs implementation for exynos-snapshot
  *  you can access the sysfs of exynos-snapshot to /sys/devices/system/exynos-ss
diff -duprN mm/arch/arm/mach-exynos/include/mach/exynos-ss.h n/arch/arm/mach-exynos/include/mach/exynos-ss.h
--- mm/arch/arm/mach-exynos/include/mach/exynos-ss.h	2016-09-20 17:29:41.000000000 +0530
+++ n/arch/arm/mach-exynos/include/mach/exynos-ss.h	2017-03-31 10:41:29.000000000 +0530
@@ -58,6 +58,8 @@ extern int exynos_ss_get_enable(const ch
 extern int exynos_ss_save_context(struct pt_regs *);
 extern int exynos_ss_save_reg(struct pt_regs *);
 extern int exynos_ss_early_dump(void);
+extern unsigned int exynos_ss_get_item_size(char*);
+extern unsigned int exynos_ss_get_item_paddr(char*);
 
 #ifdef CONFIG_EXYNOS_SNAPSHOT_IRQ_DISABLED
 extern void arch_local_irq_restore(unsigned long flags);
@@ -129,6 +131,12 @@ static inline void exynos_ss_softirq(uns
 #endif
 }
 
+#ifdef CONFIG_EXYNOS_SNAPSHOT_PSTORE
+extern int exynos_ss_hook_pmsg(char *buffer, size_t count);
+#else
+#define exynos_ss_hook_pmsg(a,b)	do { } while(0)
+#endif
+
 #else
 #define exynos_ss_task(a,b)		do { } while(0)
 #define exynos_ss_work(a,b,c,d)		do { } while(0)
@@ -145,6 +153,8 @@ static inline void exynos_ss_softirq(uns
 #define exynos_ss_save_context(a)	do { } while(0)
 #define exynos_ss_set_enable(a,b)	do { } while(0)
 #define exynos_ss_early_dump()		do { } while(0)
+#define exynos_ss_get_item_size(a) 	do { } while(0)
+#define exynos_ss_get_item_paddr(a) 	do { } while(0)
 #endif /* CONFIG_EXYNOS_SNAPSHOT */
 
 #endif
diff -duprN mm/arch/arm/mach-exynos/pm-exynos5430.c n/arch/arm/mach-exynos/pm-exynos5430.c
--- mm/arch/arm/mach-exynos/pm-exynos5430.c	2016-09-20 17:29:42.000000000 +0530
+++ n/arch/arm/mach-exynos/pm-exynos5430.c	2017-03-31 10:41:29.000000000 +0530
@@ -22,6 +22,8 @@
 #include <linux/clk.h>
 #include <linux/interrupt.h>
 #include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/wakeup_reason.h>
 
 #include <asm/cacheflush.h>
 #include <asm/smp_scu.h>
@@ -93,12 +95,13 @@ static struct sleep_save exynos_enable_x
 	{ .reg = EXYNOS5_XXTI_SYS_PWR_REG,		.val = 0x1, },
 };
 
-
 extern void exynos5430_secondary_up(unsigned int cpu_id);
 extern void exynos5430_cpu_down(unsigned int cpu_id);
 extern unsigned int exynos5430_cpu_state(unsigned int cpu_id);
 
-#if 0
+static void __iomem *exynos_eint_base;
+extern u32 exynos_eint_to_pin_num(int eint);
+
 static void exynos_show_wakeup_reason_eint(void)
 {
 	int bit;
@@ -106,28 +109,26 @@ static void exynos_show_wakeup_reason_ei
 	long unsigned int ext_int_pend;
 	unsigned long eint_wakeup_mask;
 	bool found = 0;
-	extern void __iomem *exynos_eint_base;
 
 	eint_wakeup_mask = __raw_readl(EXYNOS5430_EINT_WAKEUP_MASK);
 
 	for (reg_eintstart = 0; reg_eintstart <= 31; reg_eintstart += 8) {
 		ext_int_pend =
-			__raw_readl(EINT_PEND(exynos_eint_base,
-					      IRQ_EINT(reg_eintstart)));
+			__raw_readl(EXYNOS543x_EINT_PEND(exynos_eint_base,
+						reg_eintstart));
 
 		for_each_set_bit(bit, &ext_int_pend, 8) {
-			int irq = IRQ_EINT(reg_eintstart) + bit;
-			struct irq_desc *desc = irq_to_desc(irq);
+			u32 gpio;
+			int irq;
 
 			if (eint_wakeup_mask & (1 << (reg_eintstart + bit)))
 				continue;
 
-			if (desc && desc->action && desc->action->name)
-				pr_info("Resume caused by IRQ %d, %s\n", irq,
-					desc->action->name);
-			else
-				pr_info("Resume caused by IRQ %d\n", irq);
+			gpio = exynos_eint_to_pin_num(reg_eintstart + bit);
+			irq = gpio_to_irq(gpio);
 
+			log_wakeup_reason(irq);
+			update_wakeup_reason_stats(irq, reg_eintstart + bit);
 			found = 1;
 		}
 	}
@@ -135,28 +136,56 @@ static void exynos_show_wakeup_reason_ei
 	if (!found)
 		pr_info("Resume caused by unknown EINT\n");
 }
+
+#ifdef CONFIG_SEC_PM_DEBUG
+static void exynos_show_wakeup_registers(unsigned long wakeup_stat)
+{
+	pr_info("WAKEUP_STAT: 0x%08lx\n", wakeup_stat);
+	pr_info("EINT_PEND: 0x%08x, 0x%08x 0x%08x, 0x%08x\n",
+			__raw_readl(EXYNOS543x_EINT_PEND(exynos_eint_base, 0)),
+			__raw_readl(EXYNOS543x_EINT_PEND(exynos_eint_base, 8)),
+			__raw_readl(EXYNOS543x_EINT_PEND(exynos_eint_base, 16)),
+			__raw_readl(EXYNOS543x_EINT_PEND(exynos_eint_base, 24)));
+}
+#else
+static void exynos_show_wakeup_registers(unsigned long wakeup_stat) {}
 #endif
+
 static void exynos_show_wakeup_reason(void)
 {
 	unsigned long wakeup_stat;
 
 	wakeup_stat = __raw_readl(EXYNOS5430_WAKEUP_STAT);
 
+	exynos_show_wakeup_registers(wakeup_stat);
+
 	if (wakeup_stat & EXYNOS_WAKEUP_STAT_RTC_ALARM)
 		pr_info("Resume caused by RTC alarm\n");
-	//else if (wakeup_stat & EXYNOS_WAKEUP_STAT_EINT)
-		//exynos_show_wakeup_reason_eint();
+	else if (wakeup_stat & EXYNOS_WAKEUP_STAT_EINT)
+		exynos_show_wakeup_reason_eint();
 	else
 		pr_info("Resume caused by wakeup_stat=0x%08lx\n",
 			wakeup_stat);
 }
 
+#ifdef CONFIG_SEC_GPIO_DVS
+extern void gpio_dvs_check_sleepgpio(void);
+#endif
+
 static int exynos_cpu_suspend(unsigned long arg)
 {
 	unsigned int loops;
 	unsigned int addr;
 	int i;
 
+#ifdef CONFIG_SEC_GPIO_DVS
+	/************************ Caution !!! ****************************/
+	/* This function must be located in appropriate SLEEP position
+	 * in accordance with the specification of each BB vendor.
+	 */
+	/************************ Caution !!! ****************************/
+	gpio_dvs_check_sleepgpio();
+#endif
 	flush_cache_all();
 
 	/* W/A for kfc */
@@ -316,6 +345,14 @@ arch_initcall(exynos_pm_drvinit);
 
 static __init int exynos_pm_syscore_init(void)
 {
+	exynos_eint_base = ioremap(EXYNOS543x_PA_GPIO_ALIVE, SZ_4K);
+
+	if (exynos_eint_base == NULL) {
+		pr_err("%s: unable to ioremap for EINT base address\n",
+				__func__);
+		BUG();
+	}
+
 	register_syscore_ops(&exynos_pm_syscore_ops);
 	return 0;
 }
diff -duprN mm/arch/arm/mm/dma-mapping.c n/arch/arm/mm/dma-mapping.c
--- mm/arch/arm/mm/dma-mapping.c	2016-09-20 17:30:01.000000000 +0530
+++ n/arch/arm/mm/dma-mapping.c	2017-03-31 10:41:33.000000000 +0530
@@ -781,7 +781,7 @@ static void *__dma_alloc(struct device *
 void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
 		    gfp_t gfp, struct dma_attrs *attrs)
 {
-	pgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);
+	pgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);
 	void *memory;
 
 	if (dma_alloc_from_coherent(dev, size, handle, &memory))
diff -duprN mm/arch/arm/mm/mmap.c n/arch/arm/mm/mmap.c
--- mm/arch/arm/mm/mmap.c	2016-09-20 17:30:01.000000000 +0530
+++ n/arch/arm/mm/mmap.c	2017-03-31 10:41:33.000000000 +0530
@@ -173,10 +173,9 @@ void arch_pick_mmap_layout(struct mm_str
 {
 	unsigned long random_factor = 0UL;
 
-	/* 8 bits of randomness in 20 address space bits */
 	if ((current->flags & PF_RANDOMIZE) &&
 	    !(current->personality & ADDR_NO_RANDOMIZE))
-		random_factor = (get_random_int() % (1 << 8)) << PAGE_SHIFT;
+		random_factor = (get_random_long() & ((1UL << mmap_rnd_bits) - 1)) << PAGE_SHIFT;
 
 	if (mmap_is_legacy()) {
 		mm->mmap_base = TASK_UNMAPPED_BASE + random_factor;
diff -duprN mm/arch/arm/plat-samsung/dma-ops.c n/arch/arm/plat-samsung/dma-ops.c
--- mm/arch/arm/plat-samsung/dma-ops.c	2016-09-20 17:30:00.000000000 +0530
+++ n/arch/arm/plat-samsung/dma-ops.c	2017-03-31 10:41:33.000000000 +0530
@@ -52,14 +52,20 @@ static int samsung_dmadev_config(unsigne
 		slave_config.direction = param->direction;
 		slave_config.src_addr = param->fifo;
 		slave_config.src_addr_width = param->width;
-		slave_config.src_maxburst = 1;
+		if (param->maxburst)
+			slave_config.src_maxburst = param->maxburst;
+		else
+			slave_config.src_maxburst = 1;
 		dmaengine_slave_config(chan, &slave_config);
 	} else if (param->direction == DMA_MEM_TO_DEV) {
 		memset(&slave_config, 0, sizeof(struct dma_slave_config));
 		slave_config.direction = param->direction;
 		slave_config.dst_addr = param->fifo;
 		slave_config.dst_addr_width = param->width;
-		slave_config.dst_maxburst = 1;
+		if (param->maxburst)
+			slave_config.dst_maxburst = param->maxburst;
+		else
+			slave_config.dst_maxburst = 1;
 		dmaengine_slave_config(chan, &slave_config);
 	} else {
 		pr_warn("unsupported direction\n");
diff -duprN mm/arch/arm/plat-samsung/include/plat/dma-ops.h n/arch/arm/plat-samsung/include/plat/dma-ops.h
--- mm/arch/arm/plat-samsung/include/plat/dma-ops.h	2016-09-20 17:30:00.000000000 +0530
+++ n/arch/arm/plat-samsung/include/plat/dma-ops.h	2017-03-31 10:41:33.000000000 +0530
@@ -35,6 +35,7 @@ struct samsung_dma_prep {
 struct samsung_dma_config {
 	enum dma_transfer_direction direction;
 	enum dma_slave_buswidth width;
+	u32 maxburst;
 	dma_addr_t fifo;
 };
 
diff -duprN mm/arch/arm64/Kconfig n/arch/arm64/Kconfig
--- mm/arch/arm64/Kconfig	2016-09-20 17:30:03.000000000 +0530
+++ n/arch/arm64/Kconfig	2017-03-31 10:41:33.000000000 +0530
@@ -7,15 +7,22 @@ config ARM64
 	select ARM_AMBA
 	select ARM_ARCH_TIMER
 	select ARM_GIC
+	select AUDIT_ARCH_COMPAT_GENERIC
 	select CLONE_BACKWARDS
 	select COMMON_CLK
 	select GENERIC_CLOCKEVENTS
+	select GENERIC_CLOCKEVENTS_BROADCAST if SMP
+	select GENERIC_CPU_AUTOPROBE
 	select GENERIC_IOMAP
 	select GENERIC_IRQ_PROBE
 	select GENERIC_IRQ_SHOW
 	select GENERIC_SMP_IDLE_THREAD
 	select GENERIC_TIME_VSYSCALL
 	select HARDIRQS_SW_RESEND
+	select HAVE_ARCH_AUDITSYSCALL
+	select HAVE_ARCH_MMAP_RND_BITS
+	select HAVE_ARCH_MMAP_RND_COMPAT_BITS if COMPAT
+	select HAVE_ARCH_SECCOMP_FILTER
 	select HAVE_ARCH_TRACEHOOK
 	select HAVE_DEBUG_BUGVERBOSE
 	select HAVE_DEBUG_KMEMLEAK
@@ -52,6 +59,27 @@ config MMU
 config NO_IOPORT
 	def_bool y
 
+config ARCH_MMAP_RND_BITS_MIN
+       default 14 if ARM64_64K_PAGES
+       default 18
+
+# max bits determined by the following formula:
+#  VA_BITS - PAGE_SHIFT - 3
+#  VA_BITS is always 39
+config ARCH_MMAP_RND_BITS_MAX
+       default 20 if ARM64_64K_PAGES
+       default 24
+
+config ARCH_MMAP_RND_COMPAT_BITS_MIN
+       default 11
+
+config ARCH_MMAP_RND_COMPAT_BITS_MAX
+       default 16
+
+config ILLEGAL_POINTER_VALUE
+	hex
+	default 0xdead000000000000
+
 config STACKTRACE_SUPPORT
 	def_bool y
 
@@ -182,6 +210,20 @@ config HW_PERF_EVENTS
 
 source "mm/Kconfig"
 
+config SECCOMP
+	bool "Enable seccomp to safely compute untrusted bytecode"
+	---help---
+	  This kernel feature is useful for number crunching applications
+	  that may need to compute untrusted bytecode during their
+	  execution. By using pipes or other transports made available to
+	  the process as file descriptors supporting the read/write
+	  syscalls, it's possible to isolate those applications in
+	  their own address space using seccomp. Once seccomp is
+	  enabled via prctl(PR_SET_SECCOMP), it cannot be disabled
+	  and the task is only allowed to execute a few safe syscalls
+	  defined by each seccomp mode.
+
+
 endmenu
 
 menu "Boot options"
diff -duprN mm/arch/arm64/include/asm/cpufeature.h n/arch/arm64/include/asm/cpufeature.h
--- mm/arch/arm64/include/asm/cpufeature.h	1970-01-01 05:30:00.000000000 +0530
+++ n/arch/arm64/include/asm/cpufeature.h	2017-03-31 10:41:33.000000000 +0530
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2014 Linaro Ltd. <ard.biesheuvel@linaro.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_CPUFEATURE_H
+#define __ASM_CPUFEATURE_H
+
+#include <asm/hwcap.h>
+
+/*
+ * In the arm64 world (as in the ARM world), elf_hwcap is used both internally
+ * in the kernel and for user space to keep track of which optional features
+ * are supported by the current system. So let's map feature 'x' to HWCAP_x.
+ * Note that HWCAP_x constants are bit fields so we need to take the log.
+ */
+
+#define MAX_CPU_FEATURES	(8 * sizeof(elf_hwcap))
+#define cpu_feature(x)		ilog2(HWCAP_ ## x)
+
+static inline bool cpu_have_feature(unsigned int num)
+{
+	return elf_hwcap & (1UL << num);
+}
+
+#endif
diff -duprN mm/arch/arm64/include/asm/debug-monitors.h n/arch/arm64/include/asm/debug-monitors.h
--- mm/arch/arm64/include/asm/debug-monitors.h	2016-09-20 17:30:00.000000000 +0530
+++ n/arch/arm64/include/asm/debug-monitors.h	2017-03-31 10:41:33.000000000 +0530
@@ -83,6 +83,15 @@ static inline int reinstall_suspended_bp
 }
 #endif
 
+#ifdef CONFIG_COMPAT
+int aarch32_break_handler(struct pt_regs *regs);
+#else
+static int aarch32_break_handler(struct pt_regs *regs)
+{
+	return -EFAULT;
+}
+#endif
+
 #endif	/* __ASSEMBLY */
 #endif	/* __KERNEL__ */
 #endif	/* __ASM_DEBUG_MONITORS_H */
diff -duprN mm/arch/arm64/include/asm/ptrace.h n/arch/arm64/include/asm/ptrace.h
--- mm/arch/arm64/include/asm/ptrace.h	2016-09-20 17:30:03.000000000 +0530
+++ n/arch/arm64/include/asm/ptrace.h	2017-03-31 10:41:33.000000000 +0530
@@ -60,6 +60,15 @@
 #define COMPAT_PT_TEXT_ADDR		0x10000
 #define COMPAT_PT_DATA_ADDR		0x10004
 #define COMPAT_PT_TEXT_END_ADDR		0x10008
+
+/*
+ * used to skip a system call when tracer changes its number to -1
+ * with ptrace(PTRACE_SET_SYSCALL)
+ */
+#define RET_SKIP_SYSCALL	-1
+#define RET_SKIP_SYSCALL_TRACE	-2
+#define IS_SKIP_SYSCALL(no)	((int)(no & 0xffffffff) == -1)
+
 #ifndef __ASSEMBLY__
 
 /* sizeof(struct user) for AArch32 */
@@ -171,7 +180,5 @@ extern unsigned long profile_pc(struct p
 #define profile_pc(regs) instruction_pointer(regs)
 #endif
 
-extern int aarch32_break_trap(struct pt_regs *regs);
-
 #endif /* __ASSEMBLY__ */
 #endif
diff -duprN mm/arch/arm64/include/asm/seccomp.h n/arch/arm64/include/asm/seccomp.h
--- mm/arch/arm64/include/asm/seccomp.h	1970-01-01 05:30:00.000000000 +0530
+++ n/arch/arm64/include/asm/seccomp.h	2017-03-31 10:41:33.000000000 +0530
@@ -0,0 +1,25 @@
+/*
+ * arch/arm64/include/asm/seccomp.h
+ *
+ * Copyright (C) 2014 Linaro Limited
+ * Author: AKASHI Takahiro <takahiro.akashi <at> linaro.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _ASM_SECCOMP_H
+#define _ASM_SECCOMP_H
+
+#include <asm/unistd.h>
+
+#ifdef CONFIG_COMPAT
+#define __NR_seccomp_read_32		__NR_compat_read
+#define __NR_seccomp_write_32		__NR_compat_write
+#define __NR_seccomp_exit_32		__NR_compat_exit
+#define __NR_seccomp_sigreturn_32	__NR_compat_rt_sigreturn
+#endif /* CONFIG_COMPAT */
+
+#include <asm-generic/seccomp.h>
+
+#endif /* _ASM_SECCOMP_H */
diff -duprN mm/arch/arm64/include/asm/syscall.h n/arch/arm64/include/asm/syscall.h
--- mm/arch/arm64/include/asm/syscall.h	2016-09-20 17:30:00.000000000 +0530
+++ n/arch/arm64/include/asm/syscall.h	2017-03-31 10:41:33.000000000 +0530
@@ -16,6 +16,8 @@
 #ifndef __ASM_SYSCALL_H
 #define __ASM_SYSCALL_H
 
+#include <uapi/linux/audit.h>
+#include <linux/compat.h>
 #include <linux/err.h>
 
 
@@ -98,4 +100,16 @@ static inline void syscall_set_arguments
 	memcpy(&regs->regs[i], args, n * sizeof(args[0]));
 }
 
+/*
+ * We don't care about endianness (__AUDIT_ARCH_LE bit) here because
+ * AArch64 has the same system calls both on little- and big- endian.
+ */
+static inline int syscall_get_arch(void)
+{
+	if (is_compat_task())
+		return AUDIT_ARCH_ARM;
+
+	return AUDIT_ARCH_AARCH64;
+}
+
 #endif	/* __ASM_SYSCALL_H */
diff -duprN mm/arch/arm64/include/asm/unistd.h n/arch/arm64/include/asm/unistd.h
--- mm/arch/arm64/include/asm/unistd.h	2016-09-20 17:30:01.000000000 +0530
+++ n/arch/arm64/include/asm/unistd.h	2017-03-31 10:41:33.000000000 +0530
@@ -25,6 +25,26 @@
 #define __ARCH_WANT_COMPAT_SYS_SENDFILE
 #define __ARCH_WANT_SYS_FORK
 #define __ARCH_WANT_SYS_VFORK
+
+/*
+ * Compat syscall numbers used by the AArch64 kernel.
+ */
+#define __NR_compat_restart_syscall	0
+#define __NR_compat_exit		1
+#define __NR_compat_read		3
+#define __NR_compat_write		4
+#define __NR_compat_sigreturn		119
+#define __NR_compat_rt_sigreturn	173
+
+/*
+ * The following SVCs are ARM private.
+ */
+#define __ARM_NR_COMPAT_BASE		0x0f0000
+#define __ARM_NR_compat_cacheflush	(__ARM_NR_COMPAT_BASE+2)
+#define __ARM_NR_compat_set_tls		(__ARM_NR_COMPAT_BASE+5)
+
+#define __NR_compat_syscalls		383
 #endif
+
 #define __ARCH_WANT_SYS_CLONE
 #include <uapi/asm/unistd.h>
diff -duprN mm/arch/arm64/include/asm/unistd32.h n/arch/arm64/include/asm/unistd32.h
--- mm/arch/arm64/include/asm/unistd32.h	2016-09-20 17:30:03.000000000 +0530
+++ n/arch/arm64/include/asm/unistd32.h	2017-03-31 10:41:33.000000000 +0530
@@ -21,399 +21,763 @@
 #define __SYSCALL(x, y)
 #endif
 
-__SYSCALL(0,   sys_restart_syscall)
-__SYSCALL(1,   sys_exit)
-__SYSCALL(2,   sys_fork)
-__SYSCALL(3,   sys_read)
-__SYSCALL(4,   sys_write)
-__SYSCALL(5,   compat_sys_open)
-__SYSCALL(6,   sys_close)
-__SYSCALL(7,   sys_ni_syscall)			/* 7 was sys_waitpid */
-__SYSCALL(8,   sys_creat)
-__SYSCALL(9,   sys_link)
-__SYSCALL(10,  sys_unlink)
-__SYSCALL(11,  compat_sys_execve)
-__SYSCALL(12,  sys_chdir)
-__SYSCALL(13,  sys_ni_syscall)			/* 13 was sys_time */
-__SYSCALL(14,  sys_mknod)
-__SYSCALL(15,  sys_chmod)
-__SYSCALL(16,  sys_lchown16)
-__SYSCALL(17,  sys_ni_syscall)			/* 17 was sys_break */
-__SYSCALL(18,  sys_ni_syscall)			/* 18 was sys_stat */
-__SYSCALL(19,  compat_sys_lseek)
-__SYSCALL(20,  sys_getpid)
-__SYSCALL(21,  compat_sys_mount)
-__SYSCALL(22,  sys_ni_syscall)			/* 22 was sys_umount */
-__SYSCALL(23,  sys_setuid16)
-__SYSCALL(24,  sys_getuid16)
-__SYSCALL(25,  sys_ni_syscall)			/* 25 was sys_stime */
-__SYSCALL(26,  compat_sys_ptrace)
-__SYSCALL(27,  sys_ni_syscall)			/* 27 was sys_alarm */
-__SYSCALL(28,  sys_ni_syscall)			/* 28 was sys_fstat */
-__SYSCALL(29,  sys_pause)
-__SYSCALL(30,  sys_ni_syscall)			/* 30 was sys_utime */
-__SYSCALL(31,  sys_ni_syscall)			/* 31 was sys_stty */
-__SYSCALL(32,  sys_ni_syscall)			/* 32 was sys_gtty */
-__SYSCALL(33,  sys_access)
-__SYSCALL(34,  sys_nice)
-__SYSCALL(35,  sys_ni_syscall)			/* 35 was sys_ftime */
-__SYSCALL(36,  sys_sync)
-__SYSCALL(37,  sys_kill)
-__SYSCALL(38,  sys_rename)
-__SYSCALL(39,  sys_mkdir)
-__SYSCALL(40,  sys_rmdir)
-__SYSCALL(41,  sys_dup)
-__SYSCALL(42,  sys_pipe)
-__SYSCALL(43,  compat_sys_times)
-__SYSCALL(44,  sys_ni_syscall)			/* 44 was sys_prof */
-__SYSCALL(45,  sys_brk)
-__SYSCALL(46,  sys_setgid16)
-__SYSCALL(47,  sys_getgid16)
-__SYSCALL(48,  sys_ni_syscall)			/* 48 was sys_signal */
-__SYSCALL(49,  sys_geteuid16)
-__SYSCALL(50,  sys_getegid16)
-__SYSCALL(51,  sys_acct)
-__SYSCALL(52,  sys_umount)
-__SYSCALL(53,  sys_ni_syscall)			/* 53 was sys_lock */
-__SYSCALL(54,  compat_sys_ioctl)
-__SYSCALL(55,  compat_sys_fcntl)
-__SYSCALL(56,  sys_ni_syscall)			/* 56 was sys_mpx */
-__SYSCALL(57,  sys_setpgid)
-__SYSCALL(58,  sys_ni_syscall)			/* 58 was sys_ulimit */
-__SYSCALL(59,  sys_ni_syscall)			/* 59 was sys_olduname */
-__SYSCALL(60,  sys_umask)
-__SYSCALL(61,  sys_chroot)
-__SYSCALL(62,  compat_sys_ustat)
-__SYSCALL(63,  sys_dup2)
-__SYSCALL(64,  sys_getppid)
-__SYSCALL(65,  sys_getpgrp)
-__SYSCALL(66,  sys_setsid)
-__SYSCALL(67,  compat_sys_sigaction)
-__SYSCALL(68,  sys_ni_syscall)			/* 68 was sys_sgetmask */
-__SYSCALL(69,  sys_ni_syscall)			/* 69 was sys_ssetmask */
-__SYSCALL(70,  sys_setreuid16)
-__SYSCALL(71,  sys_setregid16)
-__SYSCALL(72,  sys_sigsuspend)
-__SYSCALL(73,  compat_sys_sigpending)
-__SYSCALL(74,  sys_sethostname)
-__SYSCALL(75,  compat_sys_setrlimit)
-__SYSCALL(76,  sys_ni_syscall)			/* 76 was compat_sys_getrlimit */
-__SYSCALL(77,  compat_sys_getrusage)
-__SYSCALL(78,  compat_sys_gettimeofday)
-__SYSCALL(79,  compat_sys_settimeofday)
-__SYSCALL(80,  sys_getgroups16)
-__SYSCALL(81,  sys_setgroups16)
-__SYSCALL(82,  sys_ni_syscall)			/* 82 was compat_sys_select */
-__SYSCALL(83,  sys_symlink)
-__SYSCALL(84,  sys_ni_syscall)			/* 84 was sys_lstat */
-__SYSCALL(85,  sys_readlink)
-__SYSCALL(86,  sys_uselib)
-__SYSCALL(87,  sys_swapon)
-__SYSCALL(88,  sys_reboot)
-__SYSCALL(89,  sys_ni_syscall)			/* 89 was sys_readdir */
-__SYSCALL(90,  sys_ni_syscall)			/* 90 was sys_mmap */
-__SYSCALL(91,  sys_munmap)
-__SYSCALL(92,  compat_sys_truncate)
-__SYSCALL(93,  compat_sys_ftruncate)
-__SYSCALL(94,  sys_fchmod)
-__SYSCALL(95,  sys_fchown16)
-__SYSCALL(96,  sys_getpriority)
-__SYSCALL(97,  sys_setpriority)
-__SYSCALL(98,  sys_ni_syscall)			/* 98 was sys_profil */
-__SYSCALL(99,  compat_sys_statfs)
-__SYSCALL(100, compat_sys_fstatfs)
-__SYSCALL(101, sys_ni_syscall)			/* 101 was sys_ioperm */
-__SYSCALL(102, sys_ni_syscall)			/* 102 was sys_socketcall */
-__SYSCALL(103, sys_syslog)
-__SYSCALL(104, compat_sys_setitimer)
-__SYSCALL(105, compat_sys_getitimer)
-__SYSCALL(106, compat_sys_newstat)
-__SYSCALL(107, compat_sys_newlstat)
-__SYSCALL(108, compat_sys_newfstat)
-__SYSCALL(109, sys_ni_syscall)			/* 109 was sys_uname */
-__SYSCALL(110, sys_ni_syscall)			/* 110 was sys_iopl */
-__SYSCALL(111, sys_vhangup)
-__SYSCALL(112, sys_ni_syscall)			/* 112 was sys_idle */
-__SYSCALL(113, sys_ni_syscall)			/* 113 was sys_syscall */
-__SYSCALL(114, compat_sys_wait4)
-__SYSCALL(115, sys_swapoff)
-__SYSCALL(116, compat_sys_sysinfo)
-__SYSCALL(117, sys_ni_syscall)			/* 117 was sys_ipc */
-__SYSCALL(118, sys_fsync)
-__SYSCALL(119, compat_sys_sigreturn_wrapper)
-__SYSCALL(120, sys_clone)
-__SYSCALL(121, sys_setdomainname)
-__SYSCALL(122, sys_newuname)
-__SYSCALL(123, sys_ni_syscall)			/* 123 was sys_modify_ldt */
-__SYSCALL(124, compat_sys_adjtimex)
-__SYSCALL(125, sys_mprotect)
-__SYSCALL(126, compat_sys_sigprocmask)
-__SYSCALL(127, sys_ni_syscall)			/* 127 was sys_create_module */
-__SYSCALL(128, sys_init_module)
-__SYSCALL(129, sys_delete_module)
-__SYSCALL(130, sys_ni_syscall)			/* 130 was sys_get_kernel_syms */
-__SYSCALL(131, sys_quotactl)
-__SYSCALL(132, sys_getpgid)
-__SYSCALL(133, sys_fchdir)
-__SYSCALL(134, sys_bdflush)
-__SYSCALL(135, sys_sysfs)
-__SYSCALL(136, sys_personality)
-__SYSCALL(137, sys_ni_syscall)			/* 137 was sys_afs_syscall */
-__SYSCALL(138, sys_setfsuid16)
-__SYSCALL(139, sys_setfsgid16)
-__SYSCALL(140, sys_llseek)
-__SYSCALL(141, compat_sys_getdents)
-__SYSCALL(142, compat_sys_select)
-__SYSCALL(143, sys_flock)
-__SYSCALL(144, sys_msync)
-__SYSCALL(145, compat_sys_readv)
-__SYSCALL(146, compat_sys_writev)
-__SYSCALL(147, sys_getsid)
-__SYSCALL(148, sys_fdatasync)
-__SYSCALL(149, compat_sys_sysctl)
-__SYSCALL(150, sys_mlock)
-__SYSCALL(151, sys_munlock)
-__SYSCALL(152, sys_mlockall)
-__SYSCALL(153, sys_munlockall)
-__SYSCALL(154, sys_sched_setparam)
-__SYSCALL(155, sys_sched_getparam)
-__SYSCALL(156, sys_sched_setscheduler)
-__SYSCALL(157, sys_sched_getscheduler)
-__SYSCALL(158, sys_sched_yield)
-__SYSCALL(159, sys_sched_get_priority_max)
-__SYSCALL(160, sys_sched_get_priority_min)
-__SYSCALL(161, compat_sys_sched_rr_get_interval)
-__SYSCALL(162, compat_sys_nanosleep)
-__SYSCALL(163, sys_mremap)
-__SYSCALL(164, sys_setresuid16)
-__SYSCALL(165, sys_getresuid16)
-__SYSCALL(166, sys_ni_syscall)			/* 166 was sys_vm86 */
-__SYSCALL(167, sys_ni_syscall)			/* 167 was sys_query_module */
-__SYSCALL(168, sys_poll)
-__SYSCALL(169, sys_ni_syscall)
-__SYSCALL(170, sys_setresgid16)
-__SYSCALL(171, sys_getresgid16)
-__SYSCALL(172, sys_prctl)
-__SYSCALL(173, compat_sys_rt_sigreturn_wrapper)
-__SYSCALL(174, compat_sys_rt_sigaction)
-__SYSCALL(175, compat_sys_rt_sigprocmask)
-__SYSCALL(176, compat_sys_rt_sigpending)
-__SYSCALL(177, compat_sys_rt_sigtimedwait)
-__SYSCALL(178, compat_sys_rt_sigqueueinfo)
-__SYSCALL(179, compat_sys_rt_sigsuspend)
-__SYSCALL(180, compat_sys_pread64_wrapper)
-__SYSCALL(181, compat_sys_pwrite64_wrapper)
-__SYSCALL(182, sys_chown16)
-__SYSCALL(183, sys_getcwd)
-__SYSCALL(184, sys_capget)
-__SYSCALL(185, sys_capset)
-__SYSCALL(186, compat_sys_sigaltstack)
-__SYSCALL(187, compat_sys_sendfile)
-__SYSCALL(188, sys_ni_syscall)			/* 188 reserved */
-__SYSCALL(189, sys_ni_syscall)			/* 189 reserved */
-__SYSCALL(190, sys_vfork)
-__SYSCALL(191, compat_sys_getrlimit)		/* SuS compliant getrlimit */
-__SYSCALL(192, sys_mmap_pgoff)
-__SYSCALL(193, compat_sys_truncate64_wrapper)
-__SYSCALL(194, compat_sys_ftruncate64_wrapper)
-__SYSCALL(195, sys_stat64)
-__SYSCALL(196, sys_lstat64)
-__SYSCALL(197, sys_fstat64)
-__SYSCALL(198, sys_lchown)
-__SYSCALL(199, sys_getuid)
-__SYSCALL(200, sys_getgid)
-__SYSCALL(201, sys_geteuid)
-__SYSCALL(202, sys_getegid)
-__SYSCALL(203, sys_setreuid)
-__SYSCALL(204, sys_setregid)
-__SYSCALL(205, sys_getgroups)
-__SYSCALL(206, sys_setgroups)
-__SYSCALL(207, sys_fchown)
-__SYSCALL(208, sys_setresuid)
-__SYSCALL(209, sys_getresuid)
-__SYSCALL(210, sys_setresgid)
-__SYSCALL(211, sys_getresgid)
-__SYSCALL(212, sys_chown)
-__SYSCALL(213, sys_setuid)
-__SYSCALL(214, sys_setgid)
-__SYSCALL(215, sys_setfsuid)
-__SYSCALL(216, sys_setfsgid)
-__SYSCALL(217, compat_sys_getdents64)
-__SYSCALL(218, sys_pivot_root)
-__SYSCALL(219, sys_mincore)
-__SYSCALL(220, sys_madvise)
-__SYSCALL(221, compat_sys_fcntl64)
-__SYSCALL(222, sys_ni_syscall)			/* 222 for tux */
-__SYSCALL(223, sys_ni_syscall)			/* 223 is unused */
-__SYSCALL(224, sys_gettid)
-__SYSCALL(225, compat_sys_readahead_wrapper)
-__SYSCALL(226, sys_setxattr)
-__SYSCALL(227, sys_lsetxattr)
-__SYSCALL(228, sys_fsetxattr)
-__SYSCALL(229, sys_getxattr)
-__SYSCALL(230, sys_lgetxattr)
-__SYSCALL(231, sys_fgetxattr)
-__SYSCALL(232, sys_listxattr)
-__SYSCALL(233, sys_llistxattr)
-__SYSCALL(234, sys_flistxattr)
-__SYSCALL(235, sys_removexattr)
-__SYSCALL(236, sys_lremovexattr)
-__SYSCALL(237, sys_fremovexattr)
-__SYSCALL(238, sys_tkill)
-__SYSCALL(239, sys_sendfile64)
-__SYSCALL(240, compat_sys_futex)
-__SYSCALL(241, compat_sys_sched_setaffinity)
-__SYSCALL(242, compat_sys_sched_getaffinity)
-__SYSCALL(243, compat_sys_io_setup)
-__SYSCALL(244, sys_io_destroy)
-__SYSCALL(245, compat_sys_io_getevents)
-__SYSCALL(246, compat_sys_io_submit)
-__SYSCALL(247, sys_io_cancel)
-__SYSCALL(248, sys_exit_group)
-__SYSCALL(249, compat_sys_lookup_dcookie)
-__SYSCALL(250, sys_epoll_create)
-__SYSCALL(251, sys_epoll_ctl)
-__SYSCALL(252, sys_epoll_wait)
-__SYSCALL(253, sys_remap_file_pages)
-__SYSCALL(254, sys_ni_syscall)			/* 254 for set_thread_area */
-__SYSCALL(255, sys_ni_syscall)			/* 255 for get_thread_area */
-__SYSCALL(256, sys_set_tid_address)
-__SYSCALL(257, compat_sys_timer_create)
-__SYSCALL(258, compat_sys_timer_settime)
-__SYSCALL(259, compat_sys_timer_gettime)
-__SYSCALL(260, sys_timer_getoverrun)
-__SYSCALL(261, sys_timer_delete)
-__SYSCALL(262, compat_sys_clock_settime)
-__SYSCALL(263, compat_sys_clock_gettime)
-__SYSCALL(264, compat_sys_clock_getres)
-__SYSCALL(265, compat_sys_clock_nanosleep)
-__SYSCALL(266, compat_sys_statfs64_wrapper)
-__SYSCALL(267, compat_sys_fstatfs64_wrapper)
-__SYSCALL(268, sys_tgkill)
-__SYSCALL(269, compat_sys_utimes)
-__SYSCALL(270, compat_sys_fadvise64_64_wrapper)
-__SYSCALL(271, sys_pciconfig_iobase)
-__SYSCALL(272, sys_pciconfig_read)
-__SYSCALL(273, sys_pciconfig_write)
-__SYSCALL(274, compat_sys_mq_open)
-__SYSCALL(275, sys_mq_unlink)
-__SYSCALL(276, compat_sys_mq_timedsend)
-__SYSCALL(277, compat_sys_mq_timedreceive)
-__SYSCALL(278, compat_sys_mq_notify)
-__SYSCALL(279, compat_sys_mq_getsetattr)
-__SYSCALL(280, compat_sys_waitid)
-__SYSCALL(281, sys_socket)
-__SYSCALL(282, sys_bind)
-__SYSCALL(283, sys_connect)
-__SYSCALL(284, sys_listen)
-__SYSCALL(285, sys_accept)
-__SYSCALL(286, sys_getsockname)
-__SYSCALL(287, sys_getpeername)
-__SYSCALL(288, sys_socketpair)
-__SYSCALL(289, sys_send)
-__SYSCALL(290, sys_sendto)
-__SYSCALL(291, compat_sys_recv)
-__SYSCALL(292, compat_sys_recvfrom)
-__SYSCALL(293, sys_shutdown)
-__SYSCALL(294, compat_sys_setsockopt)
-__SYSCALL(295, compat_sys_getsockopt)
-__SYSCALL(296, compat_sys_sendmsg)
-__SYSCALL(297, compat_sys_recvmsg)
-__SYSCALL(298, sys_semop)
-__SYSCALL(299, sys_semget)
-__SYSCALL(300, compat_sys_semctl)
-__SYSCALL(301, compat_sys_msgsnd)
-__SYSCALL(302, compat_sys_msgrcv)
-__SYSCALL(303, sys_msgget)
-__SYSCALL(304, compat_sys_msgctl)
-__SYSCALL(305, compat_sys_shmat)
-__SYSCALL(306, sys_shmdt)
-__SYSCALL(307, sys_shmget)
-__SYSCALL(308, compat_sys_shmctl)
-__SYSCALL(309, sys_add_key)
-__SYSCALL(310, sys_request_key)
-__SYSCALL(311, compat_sys_keyctl)
-__SYSCALL(312, compat_sys_semtimedop)
-__SYSCALL(313, sys_ni_syscall)
-__SYSCALL(314, sys_ioprio_set)
-__SYSCALL(315, sys_ioprio_get)
-__SYSCALL(316, sys_inotify_init)
-__SYSCALL(317, sys_inotify_add_watch)
-__SYSCALL(318, sys_inotify_rm_watch)
-__SYSCALL(319, compat_sys_mbind)
-__SYSCALL(320, compat_sys_get_mempolicy)
-__SYSCALL(321, compat_sys_set_mempolicy)
-__SYSCALL(322, compat_sys_openat)
-__SYSCALL(323, sys_mkdirat)
-__SYSCALL(324, sys_mknodat)
-__SYSCALL(325, sys_fchownat)
-__SYSCALL(326, compat_sys_futimesat)
-__SYSCALL(327, sys_fstatat64)
-__SYSCALL(328, sys_unlinkat)
-__SYSCALL(329, sys_renameat)
-__SYSCALL(330, sys_linkat)
-__SYSCALL(331, sys_symlinkat)
-__SYSCALL(332, sys_readlinkat)
-__SYSCALL(333, sys_fchmodat)
-__SYSCALL(334, sys_faccessat)
-__SYSCALL(335, compat_sys_pselect6)
-__SYSCALL(336, compat_sys_ppoll)
-__SYSCALL(337, sys_unshare)
-__SYSCALL(338, compat_sys_set_robust_list)
-__SYSCALL(339, compat_sys_get_robust_list)
-__SYSCALL(340, sys_splice)
-__SYSCALL(341, compat_sys_sync_file_range2_wrapper)
-__SYSCALL(342, sys_tee)
-__SYSCALL(343, compat_sys_vmsplice)
-__SYSCALL(344, compat_sys_move_pages)
-__SYSCALL(345, sys_getcpu)
-__SYSCALL(346, compat_sys_epoll_pwait)
-__SYSCALL(347, compat_sys_kexec_load)
-__SYSCALL(348, compat_sys_utimensat)
-__SYSCALL(349, compat_sys_signalfd)
-__SYSCALL(350, sys_timerfd_create)
-__SYSCALL(351, sys_eventfd)
-__SYSCALL(352, compat_sys_fallocate_wrapper)
-__SYSCALL(353, compat_sys_timerfd_settime)
-__SYSCALL(354, compat_sys_timerfd_gettime)
-__SYSCALL(355, compat_sys_signalfd4)
-__SYSCALL(356, sys_eventfd2)
-__SYSCALL(357, sys_epoll_create1)
-__SYSCALL(358, sys_dup3)
-__SYSCALL(359, sys_pipe2)
-__SYSCALL(360, sys_inotify_init1)
-__SYSCALL(361, compat_sys_preadv)
-__SYSCALL(362, compat_sys_pwritev)
-__SYSCALL(363, compat_sys_rt_tgsigqueueinfo)
-__SYSCALL(364, sys_perf_event_open)
-__SYSCALL(365, compat_sys_recvmmsg)
-__SYSCALL(366, sys_accept4)
-__SYSCALL(367, sys_fanotify_init)
-__SYSCALL(368, compat_sys_fanotify_mark)
-__SYSCALL(369, sys_prlimit64)
-__SYSCALL(370, sys_name_to_handle_at)
-__SYSCALL(371, compat_sys_open_by_handle_at)
-__SYSCALL(372, compat_sys_clock_adjtime)
-__SYSCALL(373, sys_syncfs)
-__SYSCALL(374, compat_sys_sendmmsg)
-__SYSCALL(375, sys_setns)
-__SYSCALL(376, compat_sys_process_vm_readv)
-__SYSCALL(377, compat_sys_process_vm_writev)
-__SYSCALL(378, sys_ni_syscall)			/* 378 for kcmp */
-
-#define __NR_compat_syscalls		379
-
-/*
- * Compat syscall numbers used by the AArch64 kernel.
- */
-#define __NR_compat_restart_syscall	0
-#define __NR_compat_sigreturn		119
-#define __NR_compat_rt_sigreturn	173
-
-
-/*
- * The following SVCs are ARM private.
- */
-#define __ARM_NR_COMPAT_BASE		0x0f0000
-#define __ARM_NR_compat_cacheflush	(__ARM_NR_COMPAT_BASE+2)
-#define __ARM_NR_compat_set_tls		(__ARM_NR_COMPAT_BASE+5)
+#define __NR_restart_syscall 0
+__SYSCALL(__NR_restart_syscall, sys_restart_syscall)
+#define __NR_exit 1
+__SYSCALL(__NR_exit, sys_exit)
+#define __NR_fork 2
+__SYSCALL(__NR_fork, sys_fork)
+#define __NR_read 3
+__SYSCALL(__NR_read, sys_read)
+#define __NR_write 4
+__SYSCALL(__NR_write, sys_write)
+#define __NR_open 5
+__SYSCALL(__NR_open, compat_sys_open)
+#define __NR_close 6
+__SYSCALL(__NR_close, sys_close)
+			/* 7 was sys_waitpid */
+__SYSCALL(7, sys_ni_syscall)
+#define __NR_creat 8
+__SYSCALL(__NR_creat, sys_creat)
+#define __NR_link 9
+__SYSCALL(__NR_link, sys_link)
+#define __NR_unlink 10
+__SYSCALL(__NR_unlink, sys_unlink)
+#define __NR_execve 11
+__SYSCALL(__NR_execve, compat_sys_execve)
+#define __NR_chdir 12
+__SYSCALL(__NR_chdir, sys_chdir)
+			/* 13 was sys_time */
+__SYSCALL(13, sys_ni_syscall)
+#define __NR_mknod 14
+__SYSCALL(__NR_mknod, sys_mknod)
+#define __NR_chmod 15
+__SYSCALL(__NR_chmod, sys_chmod)
+#define __NR_lchown 16
+__SYSCALL(__NR_lchown, sys_lchown16)
+			/* 17 was sys_break */
+__SYSCALL(17, sys_ni_syscall)
+			/* 18 was sys_stat */
+__SYSCALL(18, sys_ni_syscall)
+#define __NR_lseek 19
+__SYSCALL(__NR_lseek, compat_sys_lseek)
+#define __NR_getpid 20
+__SYSCALL(__NR_getpid, sys_getpid)
+#define __NR_mount 21
+__SYSCALL(__NR_mount, compat_sys_mount)
+			/* 22 was sys_umount */
+__SYSCALL(22, sys_ni_syscall)
+#define __NR_setuid 23
+__SYSCALL(__NR_setuid, sys_setuid16)
+#define __NR_getuid 24
+__SYSCALL(__NR_getuid, sys_getuid16)
+			/* 25 was sys_stime */
+__SYSCALL(25, sys_ni_syscall)
+#define __NR_ptrace 26
+__SYSCALL(__NR_ptrace, compat_sys_ptrace)
+			/* 27 was sys_alarm */
+__SYSCALL(27, sys_ni_syscall)
+			/* 28 was sys_fstat */
+__SYSCALL(28, sys_ni_syscall)
+#define __NR_pause 29
+__SYSCALL(__NR_pause, sys_pause)
+			/* 30 was sys_utime */
+__SYSCALL(30, sys_ni_syscall)
+			/* 31 was sys_stty */
+__SYSCALL(31, sys_ni_syscall)
+			/* 32 was sys_gtty */
+__SYSCALL(32, sys_ni_syscall)
+#define __NR_access 33
+__SYSCALL(__NR_access, sys_access)
+#define __NR_nice 34
+__SYSCALL(__NR_nice, sys_nice)
+			/* 35 was sys_ftime */
+__SYSCALL(35, sys_ni_syscall)
+#define __NR_sync 36
+__SYSCALL(__NR_sync, sys_sync)
+#define __NR_kill 37
+__SYSCALL(__NR_kill, sys_kill)
+#define __NR_rename 38
+__SYSCALL(__NR_rename, sys_rename)
+#define __NR_mkdir 39
+__SYSCALL(__NR_mkdir, sys_mkdir)
+#define __NR_rmdir 40
+__SYSCALL(__NR_rmdir, sys_rmdir)
+#define __NR_dup 41
+__SYSCALL(__NR_dup, sys_dup)
+#define __NR_pipe 42
+__SYSCALL(__NR_pipe, sys_pipe)
+#define __NR_times 43
+__SYSCALL(__NR_times, compat_sys_times)
+			/* 44 was sys_prof */
+__SYSCALL(44, sys_ni_syscall)
+#define __NR_brk 45
+__SYSCALL(__NR_brk, sys_brk)
+#define __NR_setgid 46
+__SYSCALL(__NR_setgid, sys_setgid16)
+#define __NR_getgid 47
+__SYSCALL(__NR_getgid, sys_getgid16)
+			/* 48 was sys_signal */
+__SYSCALL(48, sys_ni_syscall)
+#define __NR_geteuid 49
+__SYSCALL(__NR_geteuid, sys_geteuid16)
+#define __NR_getegid 50
+__SYSCALL(__NR_getegid, sys_getegid16)
+#define __NR_acct 51
+__SYSCALL(__NR_acct, sys_acct)
+#define __NR_umount2 52
+__SYSCALL(__NR_umount2, sys_umount)
+			/* 53 was sys_lock */
+__SYSCALL(53, sys_ni_syscall)
+#define __NR_ioctl 54
+__SYSCALL(__NR_ioctl, compat_sys_ioctl)
+#define __NR_fcntl 55
+__SYSCALL(__NR_fcntl, compat_sys_fcntl)
+			/* 56 was sys_mpx */
+__SYSCALL(56, sys_ni_syscall)
+#define __NR_setpgid 57
+__SYSCALL(__NR_setpgid, sys_setpgid)
+			/* 58 was sys_ulimit */
+__SYSCALL(58, sys_ni_syscall)
+			/* 59 was sys_olduname */
+__SYSCALL(59, sys_ni_syscall)
+#define __NR_umask 60
+__SYSCALL(__NR_umask, sys_umask)
+#define __NR_chroot 61
+__SYSCALL(__NR_chroot, sys_chroot)
+#define __NR_ustat 62
+__SYSCALL(__NR_ustat, compat_sys_ustat)
+#define __NR_dup2 63
+__SYSCALL(__NR_dup2, sys_dup2)
+#define __NR_getppid 64
+__SYSCALL(__NR_getppid, sys_getppid)
+#define __NR_getpgrp 65
+__SYSCALL(__NR_getpgrp, sys_getpgrp)
+#define __NR_setsid 66
+__SYSCALL(__NR_setsid, sys_setsid)
+#define __NR_sigaction 67
+__SYSCALL(__NR_sigaction, compat_sys_sigaction)
+			/* 68 was sys_sgetmask */
+__SYSCALL(68, sys_ni_syscall)
+			/* 69 was sys_ssetmask */
+__SYSCALL(69, sys_ni_syscall)
+#define __NR_setreuid 70
+__SYSCALL(__NR_setreuid, sys_setreuid16)
+#define __NR_setregid 71
+__SYSCALL(__NR_setregid, sys_setregid16)
+#define __NR_sigsuspend 72
+__SYSCALL(__NR_sigsuspend, sys_sigsuspend)
+#define __NR_sigpending 73
+__SYSCALL(__NR_sigpending, compat_sys_sigpending)
+#define __NR_sethostname 74
+__SYSCALL(__NR_sethostname, sys_sethostname)
+#define __NR_setrlimit 75
+__SYSCALL(__NR_setrlimit, compat_sys_setrlimit)
+			/* 76 was compat_sys_getrlimit */
+__SYSCALL(76, sys_ni_syscall)
+#define __NR_getrusage 77
+__SYSCALL(__NR_getrusage, compat_sys_getrusage)
+#define __NR_gettimeofday 78
+__SYSCALL(__NR_gettimeofday, compat_sys_gettimeofday)
+#define __NR_settimeofday 79
+__SYSCALL(__NR_settimeofday, compat_sys_settimeofday)
+#define __NR_getgroups 80
+__SYSCALL(__NR_getgroups, sys_getgroups16)
+#define __NR_setgroups 81
+__SYSCALL(__NR_setgroups, sys_setgroups16)
+			/* 82 was compat_sys_select */
+__SYSCALL(82, sys_ni_syscall)
+#define __NR_symlink 83
+__SYSCALL(__NR_symlink, sys_symlink)
+			/* 84 was sys_lstat */
+__SYSCALL(84, sys_ni_syscall)
+#define __NR_readlink 85
+__SYSCALL(__NR_readlink, sys_readlink)
+#define __NR_uselib 86
+__SYSCALL(__NR_uselib, sys_uselib)
+#define __NR_swapon 87
+__SYSCALL(__NR_swapon, sys_swapon)
+#define __NR_reboot 88
+__SYSCALL(__NR_reboot, sys_reboot)
+			/* 89 was sys_readdir */
+__SYSCALL(89, sys_ni_syscall)
+			/* 90 was sys_mmap */
+__SYSCALL(90, sys_ni_syscall)
+#define __NR_munmap 91
+__SYSCALL(__NR_munmap, sys_munmap)
+#define __NR_truncate 92
+__SYSCALL(__NR_truncate, compat_sys_truncate)
+#define __NR_ftruncate 93
+__SYSCALL(__NR_ftruncate, compat_sys_ftruncate)
+#define __NR_fchmod 94
+__SYSCALL(__NR_fchmod, sys_fchmod)
+#define __NR_fchown 95
+__SYSCALL(__NR_fchown, sys_fchown16)
+#define __NR_getpriority 96
+__SYSCALL(__NR_getpriority, sys_getpriority)
+#define __NR_setpriority 97
+__SYSCALL(__NR_setpriority, sys_setpriority)
+			/* 98 was sys_profil */
+__SYSCALL(98, sys_ni_syscall)
+#define __NR_statfs 99
+__SYSCALL(__NR_statfs, compat_sys_statfs)
+#define __NR_fstatfs 100
+__SYSCALL(__NR_fstatfs, compat_sys_fstatfs)
+			/* 101 was sys_ioperm */
+__SYSCALL(101, sys_ni_syscall)
+			/* 102 was sys_socketcall */
+__SYSCALL(102, sys_ni_syscall)
+#define __NR_syslog 103
+__SYSCALL(__NR_syslog, sys_syslog)
+#define __NR_setitimer 104
+__SYSCALL(__NR_setitimer, compat_sys_setitimer)
+#define __NR_getitimer 105
+__SYSCALL(__NR_getitimer, compat_sys_getitimer)
+#define __NR_stat 106
+__SYSCALL(__NR_stat, compat_sys_newstat)
+#define __NR_lstat 107
+__SYSCALL(__NR_lstat, compat_sys_newlstat)
+#define __NR_fstat 108
+__SYSCALL(__NR_fstat, compat_sys_newfstat)
+			/* 109 was sys_uname */
+__SYSCALL(109, sys_ni_syscall)
+			/* 110 was sys_iopl */
+__SYSCALL(110, sys_ni_syscall)
+#define __NR_vhangup 111
+__SYSCALL(__NR_vhangup, sys_vhangup)
+			/* 112 was sys_idle */
+__SYSCALL(112, sys_ni_syscall)
+			/* 113 was sys_syscall */
+__SYSCALL(113, sys_ni_syscall)
+#define __NR_wait4 114
+__SYSCALL(__NR_wait4, compat_sys_wait4)
+#define __NR_swapoff 115
+__SYSCALL(__NR_swapoff, sys_swapoff)
+#define __NR_sysinfo 116
+__SYSCALL(__NR_sysinfo, compat_sys_sysinfo)
+			/* 117 was sys_ipc */
+__SYSCALL(117, sys_ni_syscall)
+#define __NR_fsync 118
+__SYSCALL(__NR_fsync, sys_fsync)
+#define __NR_sigreturn 119
+__SYSCALL(__NR_sigreturn, compat_sys_sigreturn_wrapper)
+#define __NR_clone 120
+__SYSCALL(__NR_clone, sys_clone)
+#define __NR_setdomainname 121
+__SYSCALL(__NR_setdomainname, sys_setdomainname)
+#define __NR_uname 122
+__SYSCALL(__NR_uname, sys_newuname)
+			/* 123 was sys_modify_ldt */
+__SYSCALL(123, sys_ni_syscall)
+#define __NR_adjtimex 124
+__SYSCALL(__NR_adjtimex, compat_sys_adjtimex)
+#define __NR_mprotect 125
+__SYSCALL(__NR_mprotect, sys_mprotect)
+#define __NR_sigprocmask 126
+__SYSCALL(__NR_sigprocmask, compat_sys_sigprocmask)
+			/* 127 was sys_create_module */
+__SYSCALL(127, sys_ni_syscall)
+#define __NR_init_module 128
+__SYSCALL(__NR_init_module, sys_init_module)
+#define __NR_delete_module 129
+__SYSCALL(__NR_delete_module, sys_delete_module)
+			/* 130 was sys_get_kernel_syms */
+__SYSCALL(130, sys_ni_syscall)
+#define __NR_quotactl 131
+__SYSCALL(__NR_quotactl, sys_quotactl)
+#define __NR_getpgid 132
+__SYSCALL(__NR_getpgid, sys_getpgid)
+#define __NR_fchdir 133
+__SYSCALL(__NR_fchdir, sys_fchdir)
+#define __NR_bdflush 134
+__SYSCALL(__NR_bdflush, sys_bdflush)
+#define __NR_sysfs 135
+__SYSCALL(__NR_sysfs, sys_sysfs)
+#define __NR_personality 136
+__SYSCALL(__NR_personality, sys_personality)
+			/* 137 was sys_afs_syscall */
+__SYSCALL(137, sys_ni_syscall)
+#define __NR_setfsuid 138
+__SYSCALL(__NR_setfsuid, sys_setfsuid16)
+#define __NR_setfsgid 139
+__SYSCALL(__NR_setfsgid, sys_setfsgid16)
+#define __NR__llseek 140
+__SYSCALL(__NR__llseek, sys_llseek)
+#define __NR_getdents 141
+__SYSCALL(__NR_getdents, compat_sys_getdents)
+#define __NR__newselect 142
+__SYSCALL(__NR__newselect, compat_sys_select)
+#define __NR_flock 143
+__SYSCALL(__NR_flock, sys_flock)
+#define __NR_msync 144
+__SYSCALL(__NR_msync, sys_msync)
+#define __NR_readv 145
+__SYSCALL(__NR_readv, compat_sys_readv)
+#define __NR_writev 146
+__SYSCALL(__NR_writev, compat_sys_writev)
+#define __NR_getsid 147
+__SYSCALL(__NR_getsid, sys_getsid)
+#define __NR_fdatasync 148
+__SYSCALL(__NR_fdatasync, sys_fdatasync)
+#define __NR__sysctl 149
+__SYSCALL(__NR__sysctl, compat_sys_sysctl)
+#define __NR_mlock 150
+__SYSCALL(__NR_mlock, sys_mlock)
+#define __NR_munlock 151
+__SYSCALL(__NR_munlock, sys_munlock)
+#define __NR_mlockall 152
+__SYSCALL(__NR_mlockall, sys_mlockall)
+#define __NR_munlockall 153
+__SYSCALL(__NR_munlockall, sys_munlockall)
+#define __NR_sched_setparam 154
+__SYSCALL(__NR_sched_setparam, sys_sched_setparam)
+#define __NR_sched_getparam 155
+__SYSCALL(__NR_sched_getparam, sys_sched_getparam)
+#define __NR_sched_setscheduler 156
+__SYSCALL(__NR_sched_setscheduler, sys_sched_setscheduler)
+#define __NR_sched_getscheduler 157
+__SYSCALL(__NR_sched_getscheduler, sys_sched_getscheduler)
+#define __NR_sched_yield 158
+__SYSCALL(__NR_sched_yield, sys_sched_yield)
+#define __NR_sched_get_priority_max 159
+__SYSCALL(__NR_sched_get_priority_max, sys_sched_get_priority_max)
+#define __NR_sched_get_priority_min 160
+__SYSCALL(__NR_sched_get_priority_min, sys_sched_get_priority_min)
+#define __NR_sched_rr_get_interval 161
+__SYSCALL(__NR_sched_rr_get_interval, compat_sys_sched_rr_get_interval)
+#define __NR_nanosleep 162
+__SYSCALL(__NR_nanosleep, compat_sys_nanosleep)
+#define __NR_mremap 163
+__SYSCALL(__NR_mremap, sys_mremap)
+#define __NR_setresuid 164
+__SYSCALL(__NR_setresuid, sys_setresuid16)
+#define __NR_getresuid 165
+__SYSCALL(__NR_getresuid, sys_getresuid16)
+			/* 166 was sys_vm86 */
+__SYSCALL(166, sys_ni_syscall)
+			/* 167 was sys_query_module */
+__SYSCALL(167, sys_ni_syscall)
+#define __NR_poll 168
+__SYSCALL(__NR_poll, sys_poll)
+#define __NR_nfsservctl 169
+__SYSCALL(__NR_nfsservctl, sys_ni_syscall)
+#define __NR_setresgid 170
+__SYSCALL(__NR_setresgid, sys_setresgid16)
+#define __NR_getresgid 171
+__SYSCALL(__NR_getresgid, sys_getresgid16)
+#define __NR_prctl 172
+__SYSCALL(__NR_prctl, sys_prctl)
+#define __NR_rt_sigreturn 173
+__SYSCALL(__NR_rt_sigreturn, compat_sys_rt_sigreturn_wrapper)
+#define __NR_rt_sigaction 174
+__SYSCALL(__NR_rt_sigaction, compat_sys_rt_sigaction)
+#define __NR_rt_sigprocmask 175
+__SYSCALL(__NR_rt_sigprocmask, compat_sys_rt_sigprocmask)
+#define __NR_rt_sigpending 176
+__SYSCALL(__NR_rt_sigpending, compat_sys_rt_sigpending)
+#define __NR_rt_sigtimedwait 177
+__SYSCALL(__NR_rt_sigtimedwait, compat_sys_rt_sigtimedwait)
+#define __NR_rt_sigqueueinfo 178
+__SYSCALL(__NR_rt_sigqueueinfo, compat_sys_rt_sigqueueinfo)
+#define __NR_rt_sigsuspend 179
+__SYSCALL(__NR_rt_sigsuspend, compat_sys_rt_sigsuspend)
+#define __NR_pread64 180
+__SYSCALL(__NR_pread64, compat_sys_pread64_wrapper)
+#define __NR_pwrite64 181
+__SYSCALL(__NR_pwrite64, compat_sys_pwrite64_wrapper)
+#define __NR_chown 182
+__SYSCALL(__NR_chown, sys_chown16)
+#define __NR_getcwd 183
+__SYSCALL(__NR_getcwd, sys_getcwd)
+#define __NR_capget 184
+__SYSCALL(__NR_capget, sys_capget)
+#define __NR_capset 185
+__SYSCALL(__NR_capset, sys_capset)
+#define __NR_sigaltstack 186
+__SYSCALL(__NR_sigaltstack, compat_sys_sigaltstack)
+#define __NR_sendfile 187
+__SYSCALL(__NR_sendfile, compat_sys_sendfile)
+			/* 188 reserved */
+__SYSCALL(188, sys_ni_syscall)
+			/* 189 reserved */
+__SYSCALL(189, sys_ni_syscall)
+#define __NR_vfork 190
+__SYSCALL(__NR_vfork, sys_vfork)
+#define __NR_ugetrlimit 191	/* SuS compliant getrlimit */
+__SYSCALL(__NR_ugetrlimit, compat_sys_getrlimit)		/* SuS compliant getrlimit */
+#define __NR_mmap2 192
+__SYSCALL(__NR_mmap2, sys_mmap_pgoff)
+#define __NR_truncate64 193
+__SYSCALL(__NR_truncate64, compat_sys_truncate64_wrapper)
+#define __NR_ftruncate64 194
+__SYSCALL(__NR_ftruncate64, compat_sys_ftruncate64_wrapper)
+#define __NR_stat64 195
+__SYSCALL(__NR_stat64, sys_stat64)
+#define __NR_lstat64 196
+__SYSCALL(__NR_lstat64, sys_lstat64)
+#define __NR_fstat64 197
+__SYSCALL(__NR_fstat64, sys_fstat64)
+#define __NR_lchown32 198
+__SYSCALL(__NR_lchown32, sys_lchown)
+#define __NR_getuid32 199
+__SYSCALL(__NR_getuid32, sys_getuid)
+#define __NR_getgid32 200
+__SYSCALL(__NR_getgid32, sys_getgid)
+#define __NR_geteuid32 201
+__SYSCALL(__NR_geteuid32, sys_geteuid)
+#define __NR_getegid32 202
+__SYSCALL(__NR_getegid32, sys_getegid)
+#define __NR_setreuid32 203
+__SYSCALL(__NR_setreuid32, sys_setreuid)
+#define __NR_setregid32 204
+__SYSCALL(__NR_setregid32, sys_setregid)
+#define __NR_getgroups32 205
+__SYSCALL(__NR_getgroups32, sys_getgroups)
+#define __NR_setgroups32 206
+__SYSCALL(__NR_setgroups32, sys_setgroups)
+#define __NR_fchown32 207
+__SYSCALL(__NR_fchown32, sys_fchown)
+#define __NR_setresuid32 208
+__SYSCALL(__NR_setresuid32, sys_setresuid)
+#define __NR_getresuid32 209
+__SYSCALL(__NR_getresuid32, sys_getresuid)
+#define __NR_setresgid32 210
+__SYSCALL(__NR_setresgid32, sys_setresgid)
+#define __NR_getresgid32 211
+__SYSCALL(__NR_getresgid32, sys_getresgid)
+#define __NR_chown32 212
+__SYSCALL(__NR_chown32, sys_chown)
+#define __NR_setuid32 213
+__SYSCALL(__NR_setuid32, sys_setuid)
+#define __NR_setgid32 214
+__SYSCALL(__NR_setgid32, sys_setgid)
+#define __NR_setfsuid32 215
+__SYSCALL(__NR_setfsuid32, sys_setfsuid)
+#define __NR_setfsgid32 216
+__SYSCALL(__NR_setfsgid32, sys_setfsgid)
+#define __NR_getdents64 217
+__SYSCALL(__NR_getdents64, compat_sys_getdents64)
+#define __NR_pivot_root 218
+__SYSCALL(__NR_pivot_root, sys_pivot_root)
+#define __NR_mincore 219
+__SYSCALL(__NR_mincore, sys_mincore)
+#define __NR_madvise 220
+__SYSCALL(__NR_madvise, sys_madvise)
+#define __NR_fcntl64 221
+__SYSCALL(__NR_fcntl64, compat_sys_fcntl64)
+			/* 222 for tux */
+__SYSCALL(222, sys_ni_syscall)
+			/* 223 is unused */
+__SYSCALL(223, sys_ni_syscall)
+#define __NR_gettid 224
+__SYSCALL(__NR_gettid, sys_gettid)
+#define __NR_readahead 225
+__SYSCALL(__NR_readahead, compat_sys_readahead_wrapper)
+#define __NR_setxattr 226
+__SYSCALL(__NR_setxattr, sys_setxattr)
+#define __NR_lsetxattr 227
+__SYSCALL(__NR_lsetxattr, sys_lsetxattr)
+#define __NR_fsetxattr 228
+__SYSCALL(__NR_fsetxattr, sys_fsetxattr)
+#define __NR_getxattr 229
+__SYSCALL(__NR_getxattr, sys_getxattr)
+#define __NR_lgetxattr 230
+__SYSCALL(__NR_lgetxattr, sys_lgetxattr)
+#define __NR_fgetxattr 231
+__SYSCALL(__NR_fgetxattr, sys_fgetxattr)
+#define __NR_listxattr 232
+__SYSCALL(__NR_listxattr, sys_listxattr)
+#define __NR_llistxattr 233
+__SYSCALL(__NR_llistxattr, sys_llistxattr)
+#define __NR_flistxattr 234
+__SYSCALL(__NR_flistxattr, sys_flistxattr)
+#define __NR_removexattr 235
+__SYSCALL(__NR_removexattr, sys_removexattr)
+#define __NR_lremovexattr 236
+__SYSCALL(__NR_lremovexattr, sys_lremovexattr)
+#define __NR_fremovexattr 237
+__SYSCALL(__NR_fremovexattr, sys_fremovexattr)
+#define __NR_tkill 238
+__SYSCALL(__NR_tkill, sys_tkill)
+#define __NR_sendfile64 239
+__SYSCALL(__NR_sendfile64, sys_sendfile64)
+#define __NR_futex 240
+__SYSCALL(__NR_futex, compat_sys_futex)
+#define __NR_sched_setaffinity 241
+__SYSCALL(__NR_sched_setaffinity, compat_sys_sched_setaffinity)
+#define __NR_sched_getaffinity 242
+__SYSCALL(__NR_sched_getaffinity, compat_sys_sched_getaffinity)
+#define __NR_io_setup 243
+__SYSCALL(__NR_io_setup, compat_sys_io_setup)
+#define __NR_io_destroy 244
+__SYSCALL(__NR_io_destroy, sys_io_destroy)
+#define __NR_io_getevents 245
+__SYSCALL(__NR_io_getevents, compat_sys_io_getevents)
+#define __NR_io_submit 246
+__SYSCALL(__NR_io_submit, compat_sys_io_submit)
+#define __NR_io_cancel 247
+__SYSCALL(__NR_io_cancel, sys_io_cancel)
+#define __NR_exit_group 248
+__SYSCALL(__NR_exit_group, sys_exit_group)
+#define __NR_lookup_dcookie 249
+__SYSCALL(__NR_lookup_dcookie, compat_sys_lookup_dcookie)
+#define __NR_epoll_create 250
+__SYSCALL(__NR_epoll_create, sys_epoll_create)
+#define __NR_epoll_ctl 251
+__SYSCALL(__NR_epoll_ctl, sys_epoll_ctl)
+#define __NR_epoll_wait 252
+__SYSCALL(__NR_epoll_wait, sys_epoll_wait)
+#define __NR_remap_file_pages 253
+__SYSCALL(__NR_remap_file_pages, sys_remap_file_pages)
+			/* 254 for set_thread_area */
+__SYSCALL(254, sys_ni_syscall)
+			/* 255 for get_thread_area */
+__SYSCALL(255, sys_ni_syscall)
+#define __NR_set_tid_address 256
+__SYSCALL(__NR_set_tid_address, sys_set_tid_address)
+#define __NR_timer_create 257
+__SYSCALL(__NR_timer_create, compat_sys_timer_create)
+#define __NR_timer_settime 258
+__SYSCALL(__NR_timer_settime, compat_sys_timer_settime)
+#define __NR_timer_gettime 259
+__SYSCALL(__NR_timer_gettime, compat_sys_timer_gettime)
+#define __NR_timer_getoverrun 260
+__SYSCALL(__NR_timer_getoverrun, sys_timer_getoverrun)
+#define __NR_timer_delete 261
+__SYSCALL(__NR_timer_delete, sys_timer_delete)
+#define __NR_clock_settime 262
+__SYSCALL(__NR_clock_settime, compat_sys_clock_settime)
+#define __NR_clock_gettime 263
+__SYSCALL(__NR_clock_gettime, compat_sys_clock_gettime)
+#define __NR_clock_getres 264
+__SYSCALL(__NR_clock_getres, compat_sys_clock_getres)
+#define __NR_clock_nanosleep 265
+__SYSCALL(__NR_clock_nanosleep, compat_sys_clock_nanosleep)
+#define __NR_statfs64 266
+__SYSCALL(__NR_statfs64, compat_sys_statfs64_wrapper)
+#define __NR_fstatfs64 267
+__SYSCALL(__NR_fstatfs64, compat_sys_fstatfs64_wrapper)
+#define __NR_tgkill 268
+__SYSCALL(__NR_tgkill, sys_tgkill)
+#define __NR_utimes 269
+__SYSCALL(__NR_utimes, compat_sys_utimes)
+#define __NR_arm_fadvise64_64 270
+__SYSCALL(__NR_arm_fadvise64_64, compat_sys_fadvise64_64_wrapper)
+#define __NR_pciconfig_iobase 271
+__SYSCALL(__NR_pciconfig_iobase, sys_pciconfig_iobase)
+#define __NR_pciconfig_read 272
+__SYSCALL(__NR_pciconfig_read, sys_pciconfig_read)
+#define __NR_pciconfig_write 273
+__SYSCALL(__NR_pciconfig_write, sys_pciconfig_write)
+#define __NR_mq_open 274
+__SYSCALL(__NR_mq_open, compat_sys_mq_open)
+#define __NR_mq_unlink 275
+__SYSCALL(__NR_mq_unlink, sys_mq_unlink)
+#define __NR_mq_timedsend 276
+__SYSCALL(__NR_mq_timedsend, compat_sys_mq_timedsend)
+#define __NR_mq_timedreceive 277
+__SYSCALL(__NR_mq_timedreceive, compat_sys_mq_timedreceive)
+#define __NR_mq_notify 278
+__SYSCALL(__NR_mq_notify, compat_sys_mq_notify)
+#define __NR_mq_getsetattr 279
+__SYSCALL(__NR_mq_getsetattr, compat_sys_mq_getsetattr)
+#define __NR_waitid 280
+__SYSCALL(__NR_waitid, compat_sys_waitid)
+#define __NR_socket 281
+__SYSCALL(__NR_socket, sys_socket)
+#define __NR_bind 282
+__SYSCALL(__NR_bind, sys_bind)
+#define __NR_connect 283
+__SYSCALL(__NR_connect, sys_connect)
+#define __NR_listen 284
+__SYSCALL(__NR_listen, sys_listen)
+#define __NR_accept 285
+__SYSCALL(__NR_accept, sys_accept)
+#define __NR_getsockname 286
+__SYSCALL(__NR_getsockname, sys_getsockname)
+#define __NR_getpeername 287
+__SYSCALL(__NR_getpeername, sys_getpeername)
+#define __NR_socketpair 288
+__SYSCALL(__NR_socketpair, sys_socketpair)
+#define __NR_send 289
+__SYSCALL(__NR_send, sys_send)
+#define __NR_sendto 290
+__SYSCALL(__NR_sendto, sys_sendto)
+#define __NR_recv 291
+__SYSCALL(__NR_recv, compat_sys_recv)
+#define __NR_recvfrom 292
+__SYSCALL(__NR_recvfrom, compat_sys_recvfrom)
+#define __NR_shutdown 293
+__SYSCALL(__NR_shutdown, sys_shutdown)
+#define __NR_setsockopt 294
+__SYSCALL(__NR_setsockopt, compat_sys_setsockopt)
+#define __NR_getsockopt 295
+__SYSCALL(__NR_getsockopt, compat_sys_getsockopt)
+#define __NR_sendmsg 296
+__SYSCALL(__NR_sendmsg, compat_sys_sendmsg)
+#define __NR_recvmsg 297
+__SYSCALL(__NR_recvmsg, compat_sys_recvmsg)
+#define __NR_semop 298
+__SYSCALL(__NR_semop, sys_semop)
+#define __NR_semget 299
+__SYSCALL(__NR_semget, sys_semget)
+#define __NR_semctl 300
+__SYSCALL(__NR_semctl, compat_sys_semctl)
+#define __NR_msgsnd 301
+__SYSCALL(__NR_msgsnd, compat_sys_msgsnd)
+#define __NR_msgrcv 302
+__SYSCALL(__NR_msgrcv, compat_sys_msgrcv)
+#define __NR_msgget 303
+__SYSCALL(__NR_msgget, sys_msgget)
+#define __NR_msgctl 304
+__SYSCALL(__NR_msgctl, compat_sys_msgctl)
+#define __NR_shmat 305
+__SYSCALL(__NR_shmat, compat_sys_shmat)
+#define __NR_shmdt 306
+__SYSCALL(__NR_shmdt, sys_shmdt)
+#define __NR_shmget 307
+__SYSCALL(__NR_shmget, sys_shmget)
+#define __NR_shmctl 308
+__SYSCALL(__NR_shmctl, compat_sys_shmctl)
+#define __NR_add_key 309
+__SYSCALL(__NR_add_key, sys_add_key)
+#define __NR_request_key 310
+__SYSCALL(__NR_request_key, sys_request_key)
+#define __NR_keyctl 311
+__SYSCALL(__NR_keyctl, compat_sys_keyctl)
+#define __NR_semtimedop 312
+__SYSCALL(__NR_semtimedop, compat_sys_semtimedop)
+#define __NR_vserver 313
+__SYSCALL(__NR_vserver, sys_ni_syscall)
+#define __NR_ioprio_set 314
+__SYSCALL(__NR_ioprio_set, sys_ioprio_set)
+#define __NR_ioprio_get 315
+__SYSCALL(__NR_ioprio_get, sys_ioprio_get)
+#define __NR_inotify_init 316
+__SYSCALL(__NR_inotify_init, sys_inotify_init)
+#define __NR_inotify_add_watch 317
+__SYSCALL(__NR_inotify_add_watch, sys_inotify_add_watch)
+#define __NR_inotify_rm_watch 318
+__SYSCALL(__NR_inotify_rm_watch, sys_inotify_rm_watch)
+#define __NR_mbind 319
+__SYSCALL(__NR_mbind, compat_sys_mbind)
+#define __NR_get_mempolicy 320
+__SYSCALL(__NR_get_mempolicy, compat_sys_get_mempolicy)
+#define __NR_set_mempolicy 321
+__SYSCALL(__NR_set_mempolicy, compat_sys_set_mempolicy)
+#define __NR_openat 322
+__SYSCALL(__NR_openat, compat_sys_openat)
+#define __NR_mkdirat 323
+__SYSCALL(__NR_mkdirat, sys_mkdirat)
+#define __NR_mknodat 324
+__SYSCALL(__NR_mknodat, sys_mknodat)
+#define __NR_fchownat 325
+__SYSCALL(__NR_fchownat, sys_fchownat)
+#define __NR_futimesat 326
+__SYSCALL(__NR_futimesat, compat_sys_futimesat)
+#define __NR_fstatat64 327
+__SYSCALL(__NR_fstatat64, sys_fstatat64)
+#define __NR_unlinkat 328
+__SYSCALL(__NR_unlinkat, sys_unlinkat)
+#define __NR_renameat 329
+__SYSCALL(__NR_renameat, sys_renameat)
+#define __NR_linkat 330
+__SYSCALL(__NR_linkat, sys_linkat)
+#define __NR_symlinkat 331
+__SYSCALL(__NR_symlinkat, sys_symlinkat)
+#define __NR_readlinkat 332
+__SYSCALL(__NR_readlinkat, sys_readlinkat)
+#define __NR_fchmodat 333
+__SYSCALL(__NR_fchmodat, sys_fchmodat)
+#define __NR_faccessat 334
+__SYSCALL(__NR_faccessat, sys_faccessat)
+#define __NR_pselect6 335
+__SYSCALL(__NR_pselect6, compat_sys_pselect6)
+#define __NR_ppoll 336
+__SYSCALL(__NR_ppoll, compat_sys_ppoll)
+#define __NR_unshare 337
+__SYSCALL(__NR_unshare, sys_unshare)
+#define __NR_set_robust_list 338
+__SYSCALL(__NR_set_robust_list, compat_sys_set_robust_list)
+#define __NR_get_robust_list 339
+__SYSCALL(__NR_get_robust_list, compat_sys_get_robust_list)
+#define __NR_splice 340
+__SYSCALL(__NR_splice, sys_splice)
+#define __NR_sync_file_range2 341
+__SYSCALL(__NR_sync_file_range2, compat_sys_sync_file_range2_wrapper)
+#define __NR_tee 342
+__SYSCALL(__NR_tee, sys_tee)
+#define __NR_vmsplice 343
+__SYSCALL(__NR_vmsplice, compat_sys_vmsplice)
+#define __NR_move_pages 344
+__SYSCALL(__NR_move_pages, compat_sys_move_pages)
+#define __NR_getcpu 345
+__SYSCALL(__NR_getcpu, sys_getcpu)
+#define __NR_epoll_pwait 346
+__SYSCALL(__NR_epoll_pwait, compat_sys_epoll_pwait)
+#define __NR_kexec_load 347
+__SYSCALL(__NR_kexec_load, compat_sys_kexec_load)
+#define __NR_utimensat 348
+__SYSCALL(__NR_utimensat, compat_sys_utimensat)
+#define __NR_signalfd 349
+__SYSCALL(__NR_signalfd, compat_sys_signalfd)
+#define __NR_timerfd_create 350
+__SYSCALL(__NR_timerfd_create, sys_timerfd_create)
+#define __NR_eventfd 351
+__SYSCALL(__NR_eventfd, sys_eventfd)
+#define __NR_fallocate 352
+__SYSCALL(__NR_fallocate, compat_sys_fallocate_wrapper)
+#define __NR_timerfd_settime 353
+__SYSCALL(__NR_timerfd_settime, compat_sys_timerfd_settime)
+#define __NR_timerfd_gettime 354
+__SYSCALL(__NR_timerfd_gettime, compat_sys_timerfd_gettime)
+#define __NR_signalfd4 355
+__SYSCALL(__NR_signalfd4, compat_sys_signalfd4)
+#define __NR_eventfd2 356
+__SYSCALL(__NR_eventfd2, sys_eventfd2)
+#define __NR_epoll_create1 357
+__SYSCALL(__NR_epoll_create1, sys_epoll_create1)
+#define __NR_dup3 358
+__SYSCALL(__NR_dup3, sys_dup3)
+#define __NR_pipe2 359
+__SYSCALL(__NR_pipe2, sys_pipe2)
+#define __NR_inotify_init1 360
+__SYSCALL(__NR_inotify_init1, sys_inotify_init1)
+#define __NR_preadv 361
+__SYSCALL(__NR_preadv, compat_sys_preadv)
+#define __NR_pwritev 362
+__SYSCALL(__NR_pwritev, compat_sys_pwritev)
+#define __NR_rt_tgsigqueueinfo 363
+__SYSCALL(__NR_rt_tgsigqueueinfo, compat_sys_rt_tgsigqueueinfo)
+#define __NR_perf_event_open 364
+__SYSCALL(__NR_perf_event_open, sys_perf_event_open)
+#define __NR_recvmmsg 365
+__SYSCALL(__NR_recvmmsg, compat_sys_recvmmsg)
+#define __NR_accept4 366
+__SYSCALL(__NR_accept4, sys_accept4)
+#define __NR_fanotify_init 367
+__SYSCALL(__NR_fanotify_init, sys_fanotify_init)
+#define __NR_fanotify_mark 368
+__SYSCALL(__NR_fanotify_mark, compat_sys_fanotify_mark)
+#define __NR_prlimit64 369
+__SYSCALL(__NR_prlimit64, sys_prlimit64)
+#define __NR_name_to_handle_at 370
+__SYSCALL(__NR_name_to_handle_at, sys_name_to_handle_at)
+#define __NR_open_by_handle_at 371
+__SYSCALL(__NR_open_by_handle_at, compat_sys_open_by_handle_at)
+#define __NR_clock_adjtime 372
+__SYSCALL(__NR_clock_adjtime, compat_sys_clock_adjtime)
+#define __NR_syncfs 373
+__SYSCALL(__NR_syncfs, sys_syncfs)
+#define __NR_sendmmsg 374
+__SYSCALL(__NR_sendmmsg, compat_sys_sendmmsg)
+#define __NR_setns 375
+__SYSCALL(__NR_setns, sys_setns)
+#define __NR_process_vm_readv 376
+__SYSCALL(__NR_process_vm_readv, compat_sys_process_vm_readv)
+#define __NR_process_vm_writev 377
+__SYSCALL(__NR_process_vm_writev, compat_sys_process_vm_writev)
+#define __NR_kcmp 378
+__SYSCALL(__NR_kcmp, sys_kcmp)
+#define __NR_finit_module 379
+__SYSCALL(__NR_finit_module, sys_finit_module)
diff -duprN mm/arch/arm64/kernel/debug-monitors.c n/arch/arm64/kernel/debug-monitors.c
--- mm/arch/arm64/kernel/debug-monitors.c	2016-09-20 17:30:04.000000000 +0530
+++ n/arch/arm64/kernel/debug-monitors.c	2017-03-31 10:41:33.000000000 +0530
@@ -24,6 +24,7 @@
 #include <linux/init.h>
 #include <linux/ptrace.h>
 #include <linux/stat.h>
+#include <linux/uaccess.h>
 
 #include <asm/debug-monitors.h>
 #include <asm/local.h>
@@ -226,13 +227,74 @@ static int single_step_handler(unsigned
 	return 0;
 }
 
-static int __init single_step_init(void)
+static int brk_handler(unsigned long addr, unsigned int esr,
+		       struct pt_regs *regs)
+{
+	siginfo_t info;
+
+	if (!user_mode(regs))
+		return -EFAULT;
+
+	info = (siginfo_t) {
+		.si_signo = SIGTRAP,
+		.si_errno = 0,
+		.si_code  = TRAP_BRKPT,
+		.si_addr  = (void __user *)instruction_pointer(regs),
+	};
+
+	force_sig_info(SIGTRAP, &info, current);
+	return 0;
+}
+
+int aarch32_break_handler(struct pt_regs *regs)
+{
+	siginfo_t info;
+	unsigned int instr;
+	bool bp = false;
+	void __user *pc = (void __user *)instruction_pointer(regs);
+
+	if (!compat_user_mode(regs))
+		return -EFAULT;
+
+	if (compat_thumb_mode(regs)) {
+		/* get 16-bit Thumb instruction */
+		get_user(instr, (u16 __user *)pc);
+		if (instr == AARCH32_BREAK_THUMB2_LO) {
+			/* get second half of 32-bit Thumb-2 instruction */
+			get_user(instr, (u16 __user *)(pc + 2));
+			bp = instr == AARCH32_BREAK_THUMB2_HI;
+		} else {
+			bp = instr == AARCH32_BREAK_THUMB;
+		}
+	} else {
+		/* 32-bit ARM instruction */
+		get_user(instr, (u32 __user *)pc);
+		bp = (instr & ~0xf0000000) == AARCH32_BREAK_ARM;
+	}
+
+	if (!bp)
+		return -EFAULT;
+
+	info = (siginfo_t) {
+		.si_signo = SIGTRAP,
+		.si_errno = 0,
+		.si_code  = TRAP_BRKPT,
+		.si_addr  = pc,
+	};
+
+	force_sig_info(SIGTRAP, &info, current);
+	return 0;
+}
+
+static int __init debug_traps_init(void)
 {
 	hook_debug_fault_code(DBG_ESR_EVT_HWSS, single_step_handler, SIGTRAP,
 			      TRAP_HWBKPT, "single-step handler");
+	hook_debug_fault_code(DBG_ESR_EVT_BRK, brk_handler, SIGTRAP,
+			      TRAP_BRKPT, "ptrace BRK handler");
 	return 0;
 }
-arch_initcall(single_step_init);
+arch_initcall(debug_traps_init);
 
 /* Re-enable single step for syscall restarting. */
 void user_rewind_single_step(struct task_struct *task)
diff -duprN mm/arch/arm64/kernel/entry.S n/arch/arm64/kernel/entry.S
--- mm/arch/arm64/kernel/entry.S	2016-09-20 17:30:04.000000000 +0530
+++ n/arch/arm64/kernel/entry.S	2017-03-31 10:41:33.000000000 +0530
@@ -25,9 +25,9 @@
 #include <asm/asm-offsets.h>
 #include <asm/errno.h>
 #include <asm/esr.h>
+#include <asm/ptrace.h>
 #include <asm/thread_info.h>
 #include <asm/unistd.h>
-#include <asm/unistd32.h>
 
 /*
  * Bad Abort numbers
@@ -658,10 +658,13 @@ ENDPROC(el0_svc)
 	 * switches, and waiting for our parent to respond.
 	 */
 __sys_trace:
-	mov	x1, sp
-	mov	w0, #0				// trace entry
-	bl	syscall_trace
+	mov	x0, sp
+	bl	syscall_trace_enter
 	adr	lr, __sys_trace_return		// return address
+	cmp	w0, #RET_SKIP_SYSCALL_TRACE	// skip syscall and tracing?
+	b.eq	ret_to_user
+	cmp	w0, #RET_SKIP_SYSCALL		// skip syscall?
+	b.eq	__sys_trace_return_skipped
 	uxtw	scno, w0			// syscall number (possibly new)
 	mov	x1, sp				// pointer to regs
 	cmp	scno, sc_nr			// check upper syscall limit
@@ -675,9 +678,9 @@ __sys_trace:
 
 __sys_trace_return:
 	str	x0, [sp]			// save returned x0
-	mov	x1, sp
-	mov	w0, #1				// trace exit
-	bl	syscall_trace
+__sys_trace_return_skipped:			// x0 already in regs[0]
+	mov	x0, sp
+	bl	syscall_trace_exit
 	b	ret_to_user
 
 /*
diff -duprN mm/arch/arm64/kernel/kuser32.S n/arch/arm64/kernel/kuser32.S
--- mm/arch/arm64/kernel/kuser32.S	2016-09-20 17:30:01.000000000 +0530
+++ n/arch/arm64/kernel/kuser32.S	2017-03-31 10:41:33.000000000 +0530
@@ -27,6 +27,9 @@
  *
  * See Documentation/arm/kernel_user_helpers.txt for formal definitions.
  */
+
+#include <asm/unistd.h>
+
 	.align	5
 	.globl	__kuser_helper_start
 __kuser_helper_start:
diff -duprN mm/arch/arm64/kernel/perf_event.c n/arch/arm64/kernel/perf_event.c
--- mm/arch/arm64/kernel/perf_event.c	2016-09-20 17:30:04.000000000 +0530
+++ n/arch/arm64/kernel/perf_event.c	2017-03-31 10:41:33.000000000 +0530
@@ -310,16 +310,25 @@ out:
 }
 
 static int
-validate_event(struct pmu_hw_events *hw_events,
-	       struct perf_event *event)
+validate_event(struct pmu *pmu, struct pmu_hw_events *hw_events,
+				struct perf_event *event)
 {
-	struct arm_pmu *armpmu = to_arm_pmu(event->pmu);
+	struct arm_pmu *armpmu;
 	struct hw_perf_event fake_event = event->hw;
 	struct pmu *leader_pmu = event->group_leader->pmu;
 
+	/*
+	 * Reject groups spanning multiple HW PMUs (e.g. CPU + CCI). The
+	 * core perf code won't check that the pmu->ctx == leader->ctx
+	 * until after pmu->event_init(event).
+	 */
+	if (event->pmu != pmu)
+		return 0;
+
 	if (event->pmu != leader_pmu || event->state <= PERF_EVENT_STATE_OFF)
 		return 1;
 
+	armpmu = to_arm_pmu(event->pmu);
 	return armpmu->get_event_idx(hw_events, &fake_event) >= 0;
 }
 
@@ -337,15 +346,15 @@ validate_group(struct perf_event *event)
 	memset(fake_used_mask, 0, sizeof(fake_used_mask));
 	fake_pmu.used_mask = fake_used_mask;
 
-	if (!validate_event(&fake_pmu, leader))
+	if (!validate_event(event->pmu, &fake_pmu, leader))
 		return -EINVAL;
 
 	list_for_each_entry(sibling, &leader->sibling_list, group_entry) {
-		if (!validate_event(&fake_pmu, sibling))
+		if (!validate_event(event->pmu, &fake_pmu, sibling))
 			return -EINVAL;
 	}
 
-	if (!validate_event(&fake_pmu, event))
+	if (!validate_event(event->pmu, &fake_pmu, event))
 		return -EINVAL;
 
 	return 0;
diff -duprN mm/arch/arm64/kernel/ptrace.c n/arch/arm64/kernel/ptrace.c
--- mm/arch/arm64/kernel/ptrace.c	2016-09-20 17:30:04.000000000 +0530
+++ n/arch/arm64/kernel/ptrace.c	2017-03-31 10:41:33.000000000 +0530
@@ -19,12 +19,15 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
+#include <linux/audit.h>
+#include <linux/compat.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/mm.h>
 #include <linux/smp.h>
 #include <linux/ptrace.h>
 #include <linux/user.h>
+#include <linux/seccomp.h>
 #include <linux/security.h>
 #include <linux/init.h>
 #include <linux/signal.h>
@@ -38,6 +41,7 @@
 #include <asm/compat.h>
 #include <asm/debug-monitors.h>
 #include <asm/pgtable.h>
+#include <asm/syscall.h>
 #include <asm/traps.h>
 #include <asm/system_misc.h>
 
@@ -53,28 +57,6 @@ void ptrace_disable(struct task_struct *
 {
 }
 
-/*
- * Handle hitting a breakpoint.
- */
-static int ptrace_break(struct pt_regs *regs)
-{
-	siginfo_t info = {
-		.si_signo = SIGTRAP,
-		.si_errno = 0,
-		.si_code  = TRAP_BRKPT,
-		.si_addr  = (void __user *)instruction_pointer(regs),
-	};
-
-	force_sig_info(SIGTRAP, &info, current);
-	return 0;
-}
-
-static int arm64_break_trap(unsigned long addr, unsigned int esr,
-			    struct pt_regs *regs)
-{
-	return ptrace_break(regs);
-}
-
 #ifdef CONFIG_HAVE_HW_BREAKPOINT
 /*
  * Handle hitting a HW-breakpoint.
@@ -817,33 +799,6 @@ static const struct user_regset_view use
 	.regsets = aarch32_regsets, .n = ARRAY_SIZE(aarch32_regsets)
 };
 
-int aarch32_break_trap(struct pt_regs *regs)
-{
-	unsigned int instr;
-	bool bp = false;
-	void __user *pc = (void __user *)instruction_pointer(regs);
-
-	if (compat_thumb_mode(regs)) {
-		/* get 16-bit Thumb instruction */
-		get_user(instr, (u16 __user *)pc);
-		if (instr == AARCH32_BREAK_THUMB2_LO) {
-			/* get second half of 32-bit Thumb-2 instruction */
-			get_user(instr, (u16 __user *)(pc + 2));
-			bp = instr == AARCH32_BREAK_THUMB2_HI;
-		} else {
-			bp = instr == AARCH32_BREAK_THUMB;
-		}
-	} else {
-		/* 32-bit ARM instruction */
-		get_user(instr, (u32 __user *)pc);
-		bp = (instr & ~0xf0000000) == AARCH32_BREAK_ARM;
-	}
-
-	if (bp)
-		return ptrace_break(regs);
-	return 1;
-}
-
 static int compat_ptrace_read_user(struct task_struct *tsk, compat_ulong_t off,
 				   compat_ulong_t __user *ret)
 {
@@ -1111,45 +1066,72 @@ long arch_ptrace(struct task_struct *chi
 	return ptrace_request(child, request, addr, data);
 }
 
+enum ptrace_syscall_dir {
+	PTRACE_SYSCALL_ENTER = 0,
+	PTRACE_SYSCALL_EXIT,
+};
 
-static int __init ptrace_break_init(void)
+static void tracehook_report_syscall(struct pt_regs *regs,
+				     enum ptrace_syscall_dir dir)
 {
-	hook_debug_fault_code(DBG_ESR_EVT_BRK, arm64_break_trap, SIGTRAP,
-			      TRAP_BRKPT, "ptrace BRK handler");
-	return 0;
-}
-core_initcall(ptrace_break_init);
+	int regno;
+	unsigned long saved_reg;
+
+	/*
+	 * A scratch register (ip(r12) on AArch32, x7 on AArch64) is
+	 * used to denote syscall entry/exit:
+	 */
+	regno = (is_compat_task() ? 12 : 7);
+	saved_reg = regs->regs[regno];
+	regs->regs[regno] = dir;
 
+	if (dir == PTRACE_SYSCALL_EXIT)
+		tracehook_report_syscall_exit(regs, 0);
+	else if (tracehook_report_syscall_entry(regs))
+		regs->syscallno = ~0UL;
 
-asmlinkage int syscall_trace(int dir, struct pt_regs *regs)
+	regs->regs[regno] = saved_reg;
+}
+
+asmlinkage int syscall_trace_enter(struct pt_regs *regs)
 {
-	unsigned long saved_reg;
+	unsigned int saved_syscallno = regs->syscallno;
 
-	if (!test_thread_flag(TIF_SYSCALL_TRACE))
-		return regs->syscallno;
+	/* Do the secure computing check first; failures should be fast. */
+	if (secure_computing(regs->syscallno) == -1)
+		return RET_SKIP_SYSCALL_TRACE;
 
-	if (is_compat_task()) {
-		/* AArch32 uses ip (r12) for scratch */
-		saved_reg = regs->regs[12];
-		regs->regs[12] = dir;
-	} else {
+	if (test_thread_flag(TIF_SYSCALL_TRACE))
+		tracehook_report_syscall(regs, PTRACE_SYSCALL_ENTER);
+
+	if (IS_SKIP_SYSCALL(regs->syscallno)) {
 		/*
-		 * Save X7. X7 is used to denote syscall entry/exit:
-		 *   X7 = 0 -> entry, = 1 -> exit
+		 * RESTRICTION: we can't modify a return value of user
+		 * issued syscall(-1) here. In order to ease this flavor,
+		 * we need to treat whatever value in x0 as a return value,
+		 * but this might result in a bogus value being returned.
 		 */
-		saved_reg = regs->regs[7];
-		regs->regs[7] = dir;
+		/*
+		 * NOTE: syscallno may also be set to -1 if fatal signal is
+		 * detected in tracehook_report_syscall_entry(), but since
+		 * a value set to x0 here is not used in this case, we may
+		 * neglect the case.
+		 */
+		if (!test_thread_flag(TIF_SYSCALL_TRACE) ||
+				(IS_SKIP_SYSCALL(saved_syscallno)))
+			regs->regs[0] = -ENOSYS;
 	}
 
-	if (dir)
-		tracehook_report_syscall_exit(regs, 0);
-	else if (tracehook_report_syscall_entry(regs))
-		regs->syscallno = ~0UL;
-
-	if (is_compat_task())
-		regs->regs[12] = saved_reg;
-	else
-		regs->regs[7] = saved_reg;
+	audit_syscall_entry(syscall_get_arch(), regs->syscallno,
+		regs->orig_x0, regs->regs[1], regs->regs[2], regs->regs[3]);
 
 	return regs->syscallno;
 }
+
+asmlinkage void syscall_trace_exit(struct pt_regs *regs)
+{
+	audit_syscall_exit(regs);
+
+	if (test_thread_flag(TIF_SYSCALL_TRACE))
+		tracehook_report_syscall(regs, PTRACE_SYSCALL_EXIT);
+}
diff -duprN mm/arch/arm64/kernel/signal32.c n/arch/arm64/kernel/signal32.c
--- mm/arch/arm64/kernel/signal32.c	2016-09-20 17:30:04.000000000 +0530
+++ n/arch/arm64/kernel/signal32.c	2017-03-31 10:41:34.000000000 +0530
@@ -26,7 +26,7 @@
 #include <asm/fpsimd.h>
 #include <asm/signal32.h>
 #include <asm/uaccess.h>
-#include <asm/unistd32.h>
+#include <asm/unistd.h>
 
 struct compat_sigcontext {
 	/* We always set these two fields to 0 */
diff -duprN mm/arch/arm64/kernel/sys_compat.c n/arch/arm64/kernel/sys_compat.c
--- mm/arch/arm64/kernel/sys_compat.c	2016-09-20 17:30:01.000000000 +0530
+++ n/arch/arm64/kernel/sys_compat.c	2017-03-31 10:41:34.000000000 +0530
@@ -26,7 +26,7 @@
 #include <linux/uaccess.h>
 
 #include <asm/cacheflush.h>
-#include <asm/unistd32.h>
+#include <asm/unistd.h>
 
 static inline void
 do_compat_cache_op(unsigned long start, unsigned long end, int flags)
diff -duprN mm/arch/arm64/kernel/traps.c n/arch/arm64/kernel/traps.c
--- mm/arch/arm64/kernel/traps.c	2016-09-20 17:30:04.000000000 +0530
+++ n/arch/arm64/kernel/traps.c	2017-03-31 10:41:34.000000000 +0530
@@ -32,6 +32,7 @@
 #include <linux/syscalls.h>
 
 #include <asm/atomic.h>
+#include <asm/debug-monitors.h>
 #include <asm/traps.h>
 #include <asm/stacktrace.h>
 #include <asm/exception.h>
@@ -261,11 +262,9 @@ asmlinkage void __exception do_undefinst
 	siginfo_t info;
 	void __user *pc = (void __user *)instruction_pointer(regs);
 
-#ifdef CONFIG_COMPAT
 	/* check for AArch32 breakpoint instructions */
-	if (compat_user_mode(regs) && aarch32_break_trap(regs) == 0)
+	if (!aarch32_break_handler(regs))
 		return;
-#endif
 
 	if (show_unhandled_signals && unhandled_signal(current, SIGILL) &&
 	    printk_ratelimit()) {
diff -duprN mm/arch/arm64/mm/mmap.c n/arch/arm64/mm/mmap.c
--- mm/arch/arm64/mm/mmap.c	2016-09-20 17:30:01.000000000 +0530
+++ n/arch/arm64/mm/mmap.c	2017-03-31 10:41:34.000000000 +0530
@@ -47,22 +47,19 @@ static int mmap_is_legacy(void)
 	return sysctl_legacy_va_layout;
 }
 
-/*
- * Since get_random_int() returns the same value within a 1 jiffy window, we
- * will almost always get the same randomisation for the stack and mmap
- * region. This will mean the relative distance between stack and mmap will be
- * the same.
- *
- * To avoid this we can shift the randomness by 1 bit.
- */
 static unsigned long mmap_rnd(void)
 {
 	unsigned long rnd = 0;
 
-	if (current->flags & PF_RANDOMIZE)
-		rnd = (long)get_random_int() & (STACK_RND_MASK >> 1);
-
-	return rnd << (PAGE_SHIFT + 1);
+	if (current->flags & PF_RANDOMIZE) {
+#ifdef CONFIG_COMPAT
+		if (test_thread_flag(TIF_32BIT))
+			rnd = get_random_long() & ((1UL << mmap_rnd_compat_bits) - 1);
+		else
+#endif
+			rnd = get_random_long() & ((1UL << mmap_rnd_bits) - 1);
+	}
+	return rnd << PAGE_SHIFT;
 }
 
 static unsigned long mmap_base(void)
